[
  {
    "name": "OnRebuildAdminCache",
    "type": "forward",
    "source_file": "admin.inc",
    "return_type": "void",
    "comment": "Called when part of the cache needs to be rebuilt.",
    "tags": {
      "param": [
        {
          "name": "part",
          "description": "Part of the admin cache to rebuild."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "part",
        "type": "AdminCachePart",
        "default": null,
        "description": "Part of the admin cache to rebuild."
      }
    ],
    "full_declaration": "forward void OnRebuildAdminCache(AdminCachePart part);"
  },
  {
    "name": "DumpAdminCache",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "void",
    "comment": "Tells the admin system to dump a portion of the cache.",
    "tags": {
      "param": [
        {
          "name": "part",
          "description": "Part of the cache to dump.  Specifying groups also dumps admins."
        },
        {
          "name": "rebuild",
          "description": "If true, the rebuild forwards will fire."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "part",
        "type": "AdminCachePart",
        "default": null,
        "description": "Part of the cache to dump.  Specifying groups also dumps admins."
      },
      {
        "name": "rebuild",
        "type": "bool",
        "default": null,
        "description": "If true, the rebuild forwards will fire."
      }
    ],
    "full_declaration": "native void DumpAdminCache(AdminCachePart part, bool rebuild);"
  },
  {
    "name": "AddCommandOverride",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "void",
    "comment": "Adds a global command flag override.  Any command registered with this name\nwill assume the new flag.  This is applied retroactively as well.",
    "tags": {
      "param": [
        {
          "name": "cmd",
          "description": "String containing command name (case sensitive)."
        },
        {
          "name": "type",
          "description": "Override type (specific command or group)."
        },
        {
          "name": "flags",
          "description": "New admin flag."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "cmd",
        "type": "char[]",
        "default": null,
        "description": "String containing command name (case sensitive)."
      },
      {
        "name": "type",
        "type": "OverrideType",
        "default": null,
        "description": "Override type (specific command or group)."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "New admin flag."
      }
    ],
    "full_declaration": "native void AddCommandOverride(const char[] cmd, OverrideType type, int flags);"
  },
  {
    "name": "GetCommandOverride",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "bool",
    "comment": "Returns a command override.",
    "tags": {
      "param": [
        {
          "name": "cmd",
          "description": "String containing command name (case sensitive)."
        },
        {
          "name": "type",
          "description": "Override type (specific command or group)."
        },
        {
          "name": "flags",
          "description": "By-reference cell to store the flag (undefined if not found)."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if there is an override, false otherwise."
    },
    "params": [
      {
        "name": "cmd",
        "type": "char[]",
        "default": null,
        "description": "String containing command name (case sensitive)."
      },
      {
        "name": "type",
        "type": "OverrideType",
        "default": null,
        "description": "Override type (specific command or group)."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "By-reference cell to store the flag (undefined if not found)."
      }
    ],
    "full_declaration": "native bool GetCommandOverride(const char[] cmd, OverrideType type, int &flags);"
  },
  {
    "name": "UnsetCommandOverride",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "void",
    "comment": "Unsets a command override.",
    "tags": {
      "param": [
        {
          "name": "cmd",
          "description": "String containing command name (case sensitive)."
        },
        {
          "name": "type",
          "description": "Override type (specific command or group)."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "cmd",
        "type": "char[]",
        "default": null,
        "description": "String containing command name (case sensitive)."
      },
      {
        "name": "type",
        "type": "OverrideType",
        "default": null,
        "description": "Override type (specific command or group)."
      }
    ],
    "full_declaration": "native void UnsetCommandOverride(const char[] cmd, OverrideType type);"
  },
  {
    "name": "CreateAdmGroup",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "GroupId",
    "comment": "Adds a new group.  Name must be unique.",
    "tags": {
      "param": [
        {
          "name": "group_name",
          "description": "String containing the group name."
        }
      ],
      "error": [],
      "note": [],
      "return": "A new group id, INVALID_GROUP_ID if it already exists."
    },
    "params": [
      {
        "name": "group_name",
        "type": "char[]",
        "default": null,
        "description": "String containing the group name."
      }
    ],
    "full_declaration": "native GroupId CreateAdmGroup(const char[] group_name);"
  },
  {
    "name": "FindAdmGroup",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "GroupId",
    "comment": "Finds a group by name.",
    "tags": {
      "param": [
        {
          "name": "group_name",
          "description": "String containing the group name."
        }
      ],
      "error": [],
      "note": [],
      "return": "A group id, or INVALID_GROUP_ID if not found."
    },
    "params": [
      {
        "name": "group_name",
        "type": "char[]",
        "default": null,
        "description": "String containing the group name."
      }
    ],
    "full_declaration": "native GroupId FindAdmGroup(const char[] group_name);"
  },
  {
    "name": "SetAdmGroupAddFlag",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "void",
    "comment": "Adds or removes a flag from a group's flag set.",
    "tags": {
      "param": [
        {
          "name": "id",
          "description": "Group id."
        },
        {
          "name": "flag",
          "description": "Admin flag to toggle."
        },
        {
          "name": "enabled",
          "description": "True to set the flag, false to unset/disable."
        }
      ],
      "error": [],
      "note": [
        "These are called \"add flags\" because they add to a user's flags."
      ],
      "return": ""
    },
    "params": [
      {
        "name": "id",
        "type": "GroupId",
        "default": null,
        "description": "Group id."
      },
      {
        "name": "flag",
        "type": "AdminFlag",
        "default": null,
        "description": "Admin flag to toggle."
      },
      {
        "name": "enabled",
        "type": "bool",
        "default": null,
        "description": "True to set the flag, false to unset/disable."
      }
    ],
    "full_declaration": "native void SetAdmGroupAddFlag(GroupId id, AdminFlag flag, bool enabled);"
  },
  {
    "name": "GetAdmGroupAddFlag",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "bool",
    "comment": "Gets the set value of an add flag on a group's flag set.",
    "tags": {
      "param": [
        {
          "name": "id",
          "description": "Group id."
        },
        {
          "name": "flag",
          "description": "Admin flag to retrieve."
        }
      ],
      "error": [],
      "note": [
        "These are called \"add flags\" because they add to a user's flags."
      ],
      "return": "True if enabled, false otherwise,"
    },
    "params": [
      {
        "name": "id",
        "type": "GroupId",
        "default": null,
        "description": "Group id."
      },
      {
        "name": "flag",
        "type": "AdminFlag",
        "default": null,
        "description": "Admin flag to retrieve."
      }
    ],
    "full_declaration": "native bool GetAdmGroupAddFlag(GroupId id, AdminFlag flag);"
  },
  {
    "name": "GetAdmGroupAddFlags",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "int",
    "comment": "Returns the flag set that is added to a user from their group.",
    "tags": {
      "param": [
        {
          "name": "id",
          "description": "GroupId of the group."
        }
      ],
      "error": [],
      "note": [
        "These are called \"add flags\" because they add to a user's flags."
      ],
      "return": "Bitstring containing the flags enabled."
    },
    "params": [
      {
        "name": "id",
        "type": "GroupId",
        "default": null,
        "description": "GroupId of the group."
      }
    ],
    "full_declaration": "native int GetAdmGroupAddFlags(GroupId id);"
  },
  {
    "name": "SetAdmGroupImmunity",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "void",
    "comment": "@deprecated          Functionality removed.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "id",
        "type": "GroupId",
        "default": null,
        "description": ""
      },
      {
        "name": "type",
        "type": "ImmunityType",
        "default": null,
        "description": ""
      },
      {
        "name": "enabled",
        "type": "bool",
        "default": null,
        "description": ""
      }
    ],
    "full_declaration": "native void SetAdmGroupImmunity(GroupId id, ImmunityType type, bool enabled);"
  },
  {
    "name": "GetAdmGroupImmunity",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "bool",
    "comment": "@deprecated          Functionality removed.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "id",
        "type": "GroupId",
        "default": null,
        "description": ""
      },
      {
        "name": "type",
        "type": "ImmunityType",
        "default": null,
        "description": ""
      }
    ],
    "full_declaration": "native bool GetAdmGroupImmunity(GroupId id, ImmunityType type);"
  },
  {
    "name": "SetAdmGroupImmuneFrom",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "void",
    "comment": "Adds immunity to a specific group.",
    "tags": {
      "param": [
        {
          "name": "id",
          "description": "Group id."
        },
        {
          "name": "other_id",
          "description": "Group id to receive immunity to."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "id",
        "type": "GroupId",
        "default": null,
        "description": "Group id."
      },
      {
        "name": "other_id",
        "type": "GroupId",
        "default": null,
        "description": "Group id to receive immunity to."
      }
    ],
    "full_declaration": "native void SetAdmGroupImmuneFrom(GroupId id, GroupId other_id);"
  },
  {
    "name": "GetAdmGroupImmuneCount",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "int",
    "comment": "Returns the number of specific group immunities.",
    "tags": {
      "param": [
        {
          "name": "id",
          "description": "Group id."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of group immunities."
    },
    "params": [
      {
        "name": "id",
        "type": "GroupId",
        "default": null,
        "description": "Group id."
      }
    ],
    "full_declaration": "native int GetAdmGroupImmuneCount(GroupId id);"
  },
  {
    "name": "GetAdmGroupImmuneFrom",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "GroupId",
    "comment": "Returns a group that this group is immune to given an index.",
    "tags": {
      "param": [
        {
          "name": "id",
          "description": "Group id."
        },
        {
          "name": "number",
          "description": "Index from 0 to N-1, from GetAdmGroupImmuneCount()."
        }
      ],
      "error": [],
      "note": [],
      "return": "GroupId that this group is immune to, or INVALID_GROUP_ID on failure."
    },
    "params": [
      {
        "name": "id",
        "type": "GroupId",
        "default": null,
        "description": "Group id."
      },
      {
        "name": "number",
        "type": "int",
        "default": null,
        "description": "Index from 0 to N-1, from GetAdmGroupImmuneCount()."
      }
    ],
    "full_declaration": "native GroupId GetAdmGroupImmuneFrom(GroupId id, int number);"
  },
  {
    "name": "AddAdmGroupCmdOverride",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "void",
    "comment": "Adds a group-specific override type.",
    "tags": {
      "param": [
        {
          "name": "id",
          "description": "Group id."
        },
        {
          "name": "name",
          "description": "String containing command name (case sensitive)."
        },
        {
          "name": "type",
          "description": "Override type (specific command or group)."
        },
        {
          "name": "rule",
          "description": "Override allow/deny setting."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "id",
        "type": "GroupId",
        "default": null,
        "description": "Group id."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "String containing command name (case sensitive)."
      },
      {
        "name": "type",
        "type": "OverrideType",
        "default": null,
        "description": "Override type (specific command or group)."
      },
      {
        "name": "rule",
        "type": "OverrideRule",
        "default": null,
        "description": "Override allow/deny setting."
      }
    ],
    "full_declaration": "native void AddAdmGroupCmdOverride(GroupId id, const char[] name, OverrideType type, OverrideRule rule);"
  },
  {
    "name": "GetAdmGroupCmdOverride",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "bool",
    "comment": "Retrieves a group-specific command override.",
    "tags": {
      "param": [
        {
          "name": "id",
          "description": "Group id."
        },
        {
          "name": "name",
          "description": "String containing command name (case sensitive)."
        },
        {
          "name": "type",
          "description": "Override type (specific command or group)."
        },
        {
          "name": "rule",
          "description": "Optional pointer to store allow/deny setting."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if an override exists, false otherwise."
    },
    "params": [
      {
        "name": "id",
        "type": "GroupId",
        "default": null,
        "description": "Group id."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "String containing command name (case sensitive)."
      },
      {
        "name": "type",
        "type": "OverrideType",
        "default": null,
        "description": "Override type (specific command or group)."
      },
      {
        "name": "rule",
        "type": "OverrideRule",
        "default": null,
        "description": "Optional pointer to store allow/deny setting."
      }
    ],
    "full_declaration": "native bool GetAdmGroupCmdOverride(GroupId id, const char[] name, OverrideType type, OverrideRule &rule);"
  },
  {
    "name": "RegisterAuthIdentType",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "void",
    "comment": "Registers an authentication identity type.  You normally never need to call this except for\nvery specific systems.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Codename to use for your authentication type."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Codename to use for your authentication type."
      }
    ],
    "full_declaration": "native void RegisterAuthIdentType(const char[] name);"
  },
  {
    "name": "CreateAdmin",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "AdminId",
    "comment": "Creates a new admin entry in the permissions cache and returns the generated AdminId index.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Name for this entry (does not have to be unique). Specify an empty string for an anonymous admin."
        }
      ],
      "error": [],
      "note": [],
      "return": "New AdminId index or INVALID_ADMIN_ID if name is empty"
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": "",
        "description": "Name for this entry (does not have to be unique). Specify an empty string for an anonymous admin."
      }
    ],
    "full_declaration": "native AdminId CreateAdmin(const char[] name=\"\");"
  },
  {
    "name": "GetAdminUsername",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "int",
    "comment": "Retrieves an admin's user name as made with CreateAdmin().",
    "tags": {
      "param": [
        {
          "name": "id",
          "description": "AdminId of the admin."
        },
        {
          "name": "name",
          "description": "String buffer to store name."
        },
        {
          "name": "maxlength",
          "description": "Maximum size of string buffer."
        }
      ],
      "error": [],
      "note": [
        "This function can return UTF-8 strings, and will safely chop UTF-8 strings."
      ],
      "return": "Number of bytes written."
    },
    "params": [
      {
        "name": "id",
        "type": "AdminId",
        "default": null,
        "description": "AdminId of the admin."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "String buffer to store name."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum size of string buffer."
      }
    ],
    "full_declaration": "native int GetAdminUsername(AdminId id, char[] name, int maxlength);"
  },
  {
    "name": "BindAdminIdentity",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "bool",
    "comment": "Binds an admin to an identity for fast lookup later on.  The bind must be unique.",
    "tags": {
      "param": [
        {
          "name": "id",
          "description": "AdminId of the admin."
        },
        {
          "name": "auth",
          "description": "Auth method to use, predefined or from RegisterAuthIdentType()."
        },
        {
          "name": "ident",
          "description": "String containing the arbitrary, unique identity."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false if the auth method was not found, ident was already taken, or ident invalid for auth method."
    },
    "params": [
      {
        "name": "id",
        "type": "AdminId",
        "default": null,
        "description": "AdminId of the admin."
      },
      {
        "name": "auth",
        "type": "char[]",
        "default": null,
        "description": "Auth method to use, predefined or from RegisterAuthIdentType()."
      },
      {
        "name": "ident",
        "type": "char[]",
        "default": null,
        "description": "String containing the arbitrary, unique identity."
      }
    ],
    "full_declaration": "native bool BindAdminIdentity(AdminId id, const char[] auth, const char[] ident);"
  },
  {
    "name": "SetAdminFlag",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "void",
    "comment": "Sets whether or not a flag is enabled on an admin.",
    "tags": {
      "param": [
        {
          "name": "id",
          "description": "AdminId index of the admin."
        },
        {
          "name": "flag",
          "description": "Admin flag to use."
        },
        {
          "name": "enabled",
          "description": "True to enable, false to disable."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "id",
        "type": "AdminId",
        "default": null,
        "description": "AdminId index of the admin."
      },
      {
        "name": "flag",
        "type": "AdminFlag",
        "default": null,
        "description": "Admin flag to use."
      },
      {
        "name": "enabled",
        "type": "bool",
        "default": null,
        "description": "True to enable, false to disable."
      }
    ],
    "full_declaration": "native void SetAdminFlag(AdminId id, AdminFlag flag, bool enabled);"
  },
  {
    "name": "GetAdminFlag",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "bool",
    "comment": "Returns whether or not a flag is enabled on an admin.",
    "tags": {
      "param": [
        {
          "name": "id",
          "description": "AdminId index of the admin."
        },
        {
          "name": "flag",
          "description": "Admin flag to use."
        },
        {
          "name": "mode",
          "description": "Access mode to check."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if enabled, false otherwise."
    },
    "params": [
      {
        "name": "id",
        "type": "AdminId",
        "default": null,
        "description": "AdminId index of the admin."
      },
      {
        "name": "flag",
        "type": "AdminFlag",
        "default": null,
        "description": "Admin flag to use."
      },
      {
        "name": "mode",
        "type": "AdmAccessMode",
        "default": "",
        "description": "Access mode to check."
      }
    ],
    "full_declaration": "native bool GetAdminFlag(AdminId id, AdminFlag flag, AdmAccessMode mode=Access_Effective);"
  },
  {
    "name": "GetAdminFlags",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "int",
    "comment": "Returns the bitstring of access flags on an admin.",
    "tags": {
      "param": [
        {
          "name": "id",
          "description": "AdminId index of the admin."
        },
        {
          "name": "mode",
          "description": "Access mode to use."
        }
      ],
      "error": [],
      "note": [],
      "return": "A bitstring containing which flags are enabled."
    },
    "params": [
      {
        "name": "id",
        "type": "AdminId",
        "default": null,
        "description": "AdminId index of the admin."
      },
      {
        "name": "mode",
        "type": "AdmAccessMode",
        "default": null,
        "description": "Access mode to use."
      }
    ],
    "full_declaration": "native int GetAdminFlags(AdminId id, AdmAccessMode mode);"
  },
  {
    "name": "AdminInheritGroup",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "bool",
    "comment": "Adds a group to an admin's inherited group list.  Any flags the group has\nwill be added to the admin's effective flags.",
    "tags": {
      "param": [
        {
          "name": "id",
          "description": "AdminId index of the admin."
        },
        {
          "name": "gid",
          "description": "GroupId index of the group."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false on invalid input or duplicate membership."
    },
    "params": [
      {
        "name": "id",
        "type": "AdminId",
        "default": null,
        "description": "AdminId index of the admin."
      },
      {
        "name": "gid",
        "type": "GroupId",
        "default": null,
        "description": "GroupId index of the group."
      }
    ],
    "full_declaration": "native bool AdminInheritGroup(AdminId id, GroupId gid);"
  },
  {
    "name": "GetAdminGroupCount",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "int",
    "comment": "Returns the number of groups this admin is a member of.",
    "tags": {
      "param": [
        {
          "name": "id",
          "description": "AdminId index of the admin."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of groups this admin is a member of."
    },
    "params": [
      {
        "name": "id",
        "type": "AdminId",
        "default": null,
        "description": "AdminId index of the admin."
      }
    ],
    "full_declaration": "native int GetAdminGroupCount(AdminId id);"
  },
  {
    "name": "GetAdminGroup",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "GroupId",
    "comment": "Returns group information from an admin.",
    "tags": {
      "param": [
        {
          "name": "id",
          "description": "AdminId index of the admin."
        },
        {
          "name": "index",
          "description": "Group number to retrieve, from 0 to N-1, where N is the value of GetAdminGroupCount(id)."
        },
        {
          "name": "name",
          "description": "Buffer to store the group's name. Note: This will safely chop UTF-8 strings."
        },
        {
          "name": "maxlength",
          "description": "Maximum size of the output name buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "A GroupId index and a name pointer, or INVALID_GROUP_ID and NULL if an error occurred."
    },
    "params": [
      {
        "name": "id",
        "type": "AdminId",
        "default": null,
        "description": "AdminId index of the admin."
      },
      {
        "name": "index",
        "type": "int",
        "default": null,
        "description": "Group number to retrieve, from 0 to N-1, where N is the value of GetAdminGroupCount(id)."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the group's name. Note: This will safely chop UTF-8 strings."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum size of the output name buffer."
      }
    ],
    "full_declaration": "native GroupId GetAdminGroup(AdminId id, int index, char[] name, int maxlength);"
  },
  {
    "name": "SetAdminPassword",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "void",
    "comment": "Sets a password on an admin.",
    "tags": {
      "param": [
        {
          "name": "id",
          "description": "AdminId index of the admin."
        },
        {
          "name": "password",
          "description": "String containing the password."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "id",
        "type": "AdminId",
        "default": null,
        "description": "AdminId index of the admin."
      },
      {
        "name": "password",
        "type": "char[]",
        "default": null,
        "description": "String containing the password."
      }
    ],
    "full_declaration": "native void SetAdminPassword(AdminId id, const char[] password);"
  },
  {
    "name": "GetAdminPassword",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "bool",
    "comment": "Gets an admin's password.",
    "tags": {
      "param": [
        {
          "name": "id",
          "description": "AdminId index of the admin."
        },
        {
          "name": "buffer",
          "description": "Optional buffer to store the admin's password."
        },
        {
          "name": "maxlength",
          "description": "Maximum size of the output name buffer. Note: This will safely chop UTF-8 strings."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if there was a password set, false otherwise."
    },
    "params": [
      {
        "name": "id",
        "type": "AdminId",
        "default": null,
        "description": "AdminId index of the admin."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": "",
        "description": "Optional buffer to store the admin's password."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": "",
        "description": "Maximum size of the output name buffer. Note: This will safely chop UTF-8 strings."
      }
    ],
    "full_declaration": "native bool GetAdminPassword(AdminId id, char[] buffer=\"\", int maxlength=0);"
  },
  {
    "name": "FindAdminByIdentity",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "AdminId",
    "comment": "Attempts to find an admin by an auth method and an identity.",
    "tags": {
      "param": [
        {
          "name": "auth",
          "description": "Auth method to try."
        },
        {
          "name": "identity",
          "description": "Identity string to look up."
        }
      ],
      "error": [],
      "note": [],
      "return": "An AdminId index if found, INVALID_ADMIN_ID otherwise."
    },
    "params": [
      {
        "name": "auth",
        "type": "char[]",
        "default": null,
        "description": "Auth method to try."
      },
      {
        "name": "identity",
        "type": "char[]",
        "default": null,
        "description": "Identity string to look up."
      }
    ],
    "full_declaration": "native AdminId FindAdminByIdentity(const char[] auth, const char[] identity);"
  },
  {
    "name": "RemoveAdmin",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "bool",
    "comment": "Removes an admin entry from the cache.",
    "tags": {
      "param": [
        {
          "name": "id",
          "description": "AdminId index to remove/invalidate."
        }
      ],
      "error": [],
      "note": [
        "This will remove any bindings to a specific user."
      ],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "id",
        "type": "AdminId",
        "default": null,
        "description": "AdminId index to remove/invalidate."
      }
    ],
    "full_declaration": "native bool RemoveAdmin(AdminId id);"
  },
  {
    "name": "FlagBitsToBitArray",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "int",
    "comment": "Converts a flag bit string to a bit array.",
    "tags": {
      "param": [
        {
          "name": "bits",
          "description": "Bit string containing the flags."
        },
        {
          "name": "array",
          "description": "Array to write the flags to.  Enabled flags will be 'true'."
        },
        {
          "name": "maxSize",
          "description": "Maximum number of flags the array can store."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of flags written."
    },
    "params": [
      {
        "name": "bits",
        "type": "int",
        "default": null,
        "description": "Bit string containing the flags."
      },
      {
        "name": "array",
        "type": "bool[]",
        "default": null,
        "description": "Array to write the flags to.  Enabled flags will be 'true'."
      },
      {
        "name": "maxSize",
        "type": "int",
        "default": null,
        "description": "Maximum number of flags the array can store."
      }
    ],
    "full_declaration": "native int FlagBitsToBitArray(int bits, bool[] array, int maxSize);"
  },
  {
    "name": "FlagBitArrayToBits",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "int",
    "comment": "Converts a flag array to a bit string.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array containing true or false for each AdminFlag."
        },
        {
          "name": "maxSize",
          "description": "Maximum size of the flag array."
        }
      ],
      "error": [],
      "note": [],
      "return": "A bit string composed of the array bits."
    },
    "params": [
      {
        "name": "array",
        "type": "bool[]",
        "default": null,
        "description": "Array containing true or false for each AdminFlag."
      },
      {
        "name": "maxSize",
        "type": "int",
        "default": null,
        "description": "Maximum size of the flag array."
      }
    ],
    "full_declaration": "native int FlagBitArrayToBits(const bool[] array, int maxSize);"
  },
  {
    "name": "FlagArrayToBits",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "int",
    "comment": "Converts an array of flags to bits.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array containing flags that are enabled."
        },
        {
          "name": "numFlags",
          "description": "Number of flags in the array."
        }
      ],
      "error": [],
      "note": [],
      "return": "A bit string composed of the array flags."
    },
    "params": [
      {
        "name": "array",
        "type": "AdminFlag[]",
        "default": null,
        "description": "Array containing flags that are enabled."
      },
      {
        "name": "numFlags",
        "type": "int",
        "default": null,
        "description": "Number of flags in the array."
      }
    ],
    "full_declaration": "native int FlagArrayToBits(const AdminFlag[] array, int numFlags);"
  },
  {
    "name": "FlagBitsToArray",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "int",
    "comment": "Converts a bit string to an array of flags.",
    "tags": {
      "param": [
        {
          "name": "bits",
          "description": "Bit string containing the flags."
        },
        {
          "name": "array",
          "description": "Output array to write flags."
        },
        {
          "name": "maxSize",
          "description": "Maximum size of the flag array."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of flags written."
    },
    "params": [
      {
        "name": "bits",
        "type": "int",
        "default": null,
        "description": "Bit string containing the flags."
      },
      {
        "name": "array",
        "type": "AdminFlag[]",
        "default": null,
        "description": "Output array to write flags."
      },
      {
        "name": "maxSize",
        "type": "int",
        "default": null,
        "description": "Maximum size of the flag array."
      }
    ],
    "full_declaration": "native int FlagBitsToArray(int bits, AdminFlag[] array, int maxSize);"
  },
  {
    "name": "FindFlagByName",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "bool",
    "comment": "Finds a flag by its string name.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Flag name (like \"kick\"), case sensitive."
        },
        {
          "name": "flag",
          "description": "Variable to store flag in."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false if not found."
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Flag name (like \"kick\"), case sensitive."
      },
      {
        "name": "flag",
        "type": "AdminFlag",
        "default": null,
        "description": "Variable to store flag in."
      }
    ],
    "full_declaration": "native bool FindFlagByName(const char[] name, AdminFlag &flag);"
  },
  {
    "name": "FindFlagByChar",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "bool",
    "comment": "Finds a flag by a given character.",
    "tags": {
      "param": [
        {
          "name": "c",
          "description": "Flag ASCII character/token."
        },
        {
          "name": "flag",
          "description": "Variable to store flag in."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false if not found."
    },
    "params": [
      {
        "name": "c",
        "type": "int",
        "default": null,
        "description": "Flag ASCII character/token."
      },
      {
        "name": "flag",
        "type": "AdminFlag",
        "default": null,
        "description": "Variable to store flag in."
      }
    ],
    "full_declaration": "native bool FindFlagByChar(int c, AdminFlag &flag);"
  },
  {
    "name": "FindFlagChar",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "bool",
    "comment": "Finds the flag char for a given admin flag.",
    "tags": {
      "param": [
        {
          "name": "flag",
          "description": "Flag to look up."
        },
        {
          "name": "c",
          "description": "Variable to store flag char."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false if not found."
    },
    "params": [
      {
        "name": "flag",
        "type": "AdminFlag",
        "default": null,
        "description": "Flag to look up."
      },
      {
        "name": "c",
        "type": "int",
        "default": null,
        "description": "Variable to store flag char."
      }
    ],
    "full_declaration": "native bool FindFlagChar(AdminFlag flag, int &c);"
  },
  {
    "name": "ReadFlagString",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "int",
    "comment": "Converts a string of flag characters to a bit string.",
    "tags": {
      "param": [
        {
          "name": "flags",
          "description": "Flag ASCII string."
        },
        {
          "name": "numchars",
          "description": "Optional variable to store the number of bytes read."
        }
      ],
      "error": [],
      "note": [],
      "return": "Bit string of ADMFLAG values."
    },
    "params": [
      {
        "name": "flags",
        "type": "char[]",
        "default": null,
        "description": "Flag ASCII string."
      },
      {
        "name": "numchars",
        "type": "int",
        "default": "",
        "description": "Optional variable to store the number of bytes read."
      }
    ],
    "full_declaration": "native int ReadFlagString(const char[] flags, int &numchars=0);"
  },
  {
    "name": "CanAdminTarget",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "bool",
    "comment": "Tests whether one admin can target another.\n\nThe heuristics for this check are as follows:\n0. If the targeting AdminId is INVALID_ADMIN_ID, targeting fails.\n1. If the targeted AdminId is INVALID_ADMIN_ID, targeting succeeds.\n2. If the targeted AdminId is the same as the targeting AdminId,\n(self) targeting succeeds.\n3. If the targeting admin is root, targeting succeeds.\n4. If the targeted admin has access higher (as interpreted by\n(sm_immunity_mode) than the targeting admin, then targeting fails.\n5. If the targeted admin has specific immunity from the\ntargeting admin via group immunities, targeting fails.\n6. Targeting succeeds.",
    "tags": {
      "param": [
        {
          "name": "admin",
          "description": "Admin doing the targetting (may be INVALID_ADMIN_ID)."
        },
        {
          "name": "target",
          "description": "Target admin (may be INVALID_ADMIN_ID)."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if targetable, false if immune."
    },
    "params": [
      {
        "name": "admin",
        "type": "AdminId",
        "default": null,
        "description": "Admin doing the targetting (may be INVALID_ADMIN_ID)."
      },
      {
        "name": "target",
        "type": "AdminId",
        "default": null,
        "description": "Target admin (may be INVALID_ADMIN_ID)."
      }
    ],
    "full_declaration": "native bool CanAdminTarget(AdminId admin, AdminId target);"
  },
  {
    "name": "CreateAuthMethod",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "bool",
    "comment": "Creates an admin auth method.  This does not need to be called more than once\nper method, ever.",
    "tags": {
      "param": [
        {
          "name": "method",
          "description": "Name of the authentication method."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false on failure."
    },
    "params": [
      {
        "name": "method",
        "type": "char[]",
        "default": null,
        "description": "Name of the authentication method."
      }
    ],
    "full_declaration": "native bool CreateAuthMethod(const char[] method);"
  },
  {
    "name": "SetAdmGroupImmunityLevel",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "int",
    "comment": "Sets a group's immunity level.",
    "tags": {
      "param": [
        {
          "name": "gid",
          "description": "Group Id."
        },
        {
          "name": "level",
          "description": "Immunity level value."
        }
      ],
      "error": [],
      "note": [],
      "return": "Old immunity level value."
    },
    "params": [
      {
        "name": "gid",
        "type": "GroupId",
        "default": null,
        "description": "Group Id."
      },
      {
        "name": "level",
        "type": "int",
        "default": null,
        "description": "Immunity level value."
      }
    ],
    "full_declaration": "native int SetAdmGroupImmunityLevel(GroupId gid, int level);"
  },
  {
    "name": "GetAdmGroupImmunityLevel",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "int",
    "comment": "Gets a group's immunity level (defaults to 0).",
    "tags": {
      "param": [
        {
          "name": "gid",
          "description": "Group Id."
        }
      ],
      "error": [],
      "note": [],
      "return": "Immunity level value."
    },
    "params": [
      {
        "name": "gid",
        "type": "GroupId",
        "default": null,
        "description": "Group Id."
      }
    ],
    "full_declaration": "native int GetAdmGroupImmunityLevel(GroupId gid);"
  },
  {
    "name": "SetAdminImmunityLevel",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "int",
    "comment": "Sets an admin's immunity level.",
    "tags": {
      "param": [
        {
          "name": "id",
          "description": "Admin Id."
        },
        {
          "name": "level",
          "description": "Immunity level value."
        }
      ],
      "error": [],
      "note": [],
      "return": "Old immunity level value."
    },
    "params": [
      {
        "name": "id",
        "type": "AdminId",
        "default": null,
        "description": "Admin Id."
      },
      {
        "name": "level",
        "type": "int",
        "default": null,
        "description": "Immunity level value."
      }
    ],
    "full_declaration": "native int SetAdminImmunityLevel(AdminId id, int level);"
  },
  {
    "name": "GetAdminImmunityLevel",
    "type": "native",
    "source_file": "admin.inc",
    "return_type": "int",
    "comment": "Gets an admin's immunity level.",
    "tags": {
      "param": [
        {
          "name": "id",
          "description": "Admin Id."
        }
      ],
      "error": [],
      "note": [],
      "return": "Immunity level value."
    },
    "params": [
      {
        "name": "id",
        "type": "AdminId",
        "default": null,
        "description": "Admin Id."
      }
    ],
    "full_declaration": "native int GetAdminImmunityLevel(AdminId id);"
  },
  {
    "name": "FlagToBit",
    "type": "stock",
    "source_file": "admin.inc",
    "return_type": "int",
    "comment": "Converts a flag to its single bit.",
    "tags": {
      "param": [
        {
          "name": "flag",
          "description": "Flag to convert."
        }
      ],
      "error": [],
      "note": [],
      "return": "Bit representation of the flag."
    },
    "params": [
      {
        "name": "flag",
        "type": "AdminFlag",
        "default": null,
        "description": "Flag to convert."
      }
    ],
    "full_declaration": "stock int FlagToBit(AdminFlag flag) { \treturn (1 << view_as<int>(flag));"
  },
  {
    "name": "FlagBitsToString",
    "type": "stock",
    "source_file": "admin.inc",
    "return_type": "int",
    "comment": "Converts a bit string to a string of flag characters.",
    "tags": {
      "param": [
        {
          "name": "bits",
          "description": "Bit string containing the flags."
        },
        {
          "name": "flags",
          "description": "Output array to write a string of flag characters."
        },
        {
          "name": "maxSize",
          "description": "Maximum size of the string array."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of flag characters written."
    },
    "params": [
      {
        "name": "bits",
        "type": "int",
        "default": null,
        "description": "Bit string containing the flags."
      },
      {
        "name": "flags",
        "type": "char[]",
        "default": null,
        "description": "Output array to write a string of flag characters."
      },
      {
        "name": "maxSize",
        "type": "int",
        "default": null,
        "description": "Maximum size of the string array."
      }
    ],
    "full_declaration": "stock int FlagBitsToString(const int bits, char[] flags, const int maxSize) { \tAdminFlag array[AdminFlags_TOTAL]; \tint numFlags = FlagBitsToArray(bits, array, AdminFlags_TOTAL);"
  },
  {
    "name": "OnAdminMenuCreated",
    "type": "forward",
    "source_file": "adminmenu.inc",
    "return_type": "void",
    "comment": "Called when the admin menu is created and 3rd party plugins can grab\nthe Handle or add categories.",
    "tags": {
      "param": [
        {
          "name": "topmenu",
          "description": "Handle to the admin menu's TopMenu."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "topmenu",
        "type": "Handle",
        "default": null,
        "description": "Handle to the admin menu's TopMenu."
      }
    ],
    "full_declaration": "forward void OnAdminMenuCreated(Handle topmenu);"
  },
  {
    "name": "OnAdminMenuReady",
    "type": "forward",
    "source_file": "adminmenu.inc",
    "return_type": "void",
    "comment": "Called when the admin menu is ready to have items added.",
    "tags": {
      "param": [
        {
          "name": "topmenu",
          "description": "Handle to the admin menu's TopMenu."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "topmenu",
        "type": "Handle",
        "default": null,
        "description": "Handle to the admin menu's TopMenu."
      }
    ],
    "full_declaration": "forward void OnAdminMenuReady(Handle topmenu);"
  },
  {
    "name": "GetAdminTopMenu",
    "type": "native",
    "source_file": "adminmenu.inc",
    "return_type": "TopMenu",
    "comment": "Retrieves the Handle to the admin top menu.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "Handle to the admin menu's TopMenu, or INVALID_HANDLE if not created yet."
    },
    "params": [],
    "full_declaration": "native TopMenu GetAdminTopMenu();"
  },
  {
    "name": "AddTargetsToMenu",
    "type": "native",
    "source_file": "adminmenu.inc",
    "return_type": "int",
    "comment": "Adds targets to an admin menu.\n\nEach client is displayed as: name (userid)\nEach item contains the userid as a string for its info.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        },
        {
          "name": "source_client",
          "description": "Source client, or 0 to ignore immunity."
        },
        {
          "name": "in_game_only",
          "description": "True to only select in-game players."
        },
        {
          "name": "alive_only",
          "description": "True to only select alive players."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of clients added."
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      },
      {
        "name": "source_client",
        "type": "int",
        "default": null,
        "description": "Source client, or 0 to ignore immunity."
      },
      {
        "name": "in_game_only",
        "type": "bool",
        "default": "",
        "description": "True to only select in-game players."
      },
      {
        "name": "alive_only",
        "type": "bool",
        "default": "",
        "description": "True to only select alive players."
      }
    ],
    "full_declaration": "native int AddTargetsToMenu(Handle menu,  \t\t\t\t\t\t\tint source_client,  \t\t\t\t\t\t\tbool in_game_only=true,  \t\t\t\t\t\t\tbool alive_only=false);"
  },
  {
    "name": "AddTargetsToMenu2",
    "type": "native",
    "source_file": "adminmenu.inc",
    "return_type": "int",
    "comment": "Adds targets to an admin menu.\n\nEach client is displayed as: name (userid)\nEach item contains the userid as a string for its info.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        },
        {
          "name": "source_client",
          "description": "Source client, or 0 to ignore immunity."
        },
        {
          "name": "flags",
          "description": "COMMAND_FILTER flags from commandfilters.inc."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of clients added."
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      },
      {
        "name": "source_client",
        "type": "int",
        "default": null,
        "description": "Source client, or 0 to ignore immunity."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "COMMAND_FILTER flags from commandfilters.inc."
      }
    ],
    "full_declaration": "native int AddTargetsToMenu2(Handle menu, int source_client, int flags);"
  },
  {
    "name": "RedisplayAdminMenu",
    "type": "stock",
    "source_file": "adminmenu.inc",
    "return_type": "bool",
    "comment": "Re-displays the admin menu to a client after selecting an item.\nAuto-aborts if the Handle is invalid.",
    "tags": {
      "param": [
        {
          "name": "topmenu",
          "description": "TopMenu Handle."
        },
        {
          "name": "client",
          "description": "Client index."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false on failure."
    },
    "params": [
      {
        "name": "topmenu",
        "type": "Handle",
        "default": null,
        "description": "TopMenu Handle."
      },
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      }
    ],
    "full_declaration": "stock bool RedisplayAdminMenu(Handle topmenu, int client) { \tif (topmenu == INVALID_HANDLE) \t{ \t\treturn false; \t}  \treturn DisplayTopMenu(topmenu, client, TopMenuPosition_LastCategory);"
  },
  {
    "name": "ByteCountToCells",
    "type": "stock",
    "source_file": "adt_array.inc",
    "return_type": "int",
    "comment": "Given a maximum string size (including the null terminator),\nreturns the number of cells required to fit that string.",
    "tags": {
      "param": [
        {
          "name": "size",
          "description": "Number of bytes."
        }
      ],
      "error": [],
      "note": [],
      "return": "Minimum number of cells required to fit the byte count."
    },
    "params": [
      {
        "name": "size",
        "type": "int",
        "default": null,
        "description": "Number of bytes."
      },
      {
        "name": "is",
        "type": "which",
        "default": null,
        "description": ""
      },
      {
        "name": "cells",
        "type": "32",
        "default": null,
        "description": ""
      },
      {
        "name": "startsize",
        "type": "int",
        "default": "",
        "description": ""
      }
    ],
    "full_declaration": "stock int ByteCountToCells(int size) { \tif (!size) \t{ \t\treturn 1; \t} \t \treturn (size + 3) / 4; }  methodmap ArrayList < Handle { \t// Creates a dynamic global cell array.  While slower than a normal array, \t// it can be used globally AND dynamically, which is otherwise impossible. \t// \t// The contents of the array are uniform; i.e. storing a string at index X \t// and then retrieving it as an integer is NOT the same as StringToInt()! \t// The \"blocksize\" determines how many cells each array slot has; it cannot \t// be changed after creation. \t// \t// @param blocksize     The number of cells each member of the array can \t//                      hold.  For example, 32 cells is equivalent to: \t//                      new Array[X][32] \t// @param startsize     Initial size of the array.  Note that data will \t//                      NOT be auto-initialized. \t// @return              New Handle to the array object. \tpublic native ArrayList(int blocksize=1, int startsize=0);"
  },
  {
    "name": "CreateArray",
    "type": "native",
    "source_file": "adt_array.inc",
    "return_type": "ArrayList",
    "comment": "Creates a dynamic global cell array.  While slower than a normal array,\nit can be used globally AND dynamically, which is otherwise impossible.\n\nThe contents of the array are uniform; i.e. storing a string at index X\nand then retrieving it as an integer is NOT the same as StringToInt()!\nThe \"blocksize\" determines how many cells each array slot has; it cannot\nbe changed after creation.",
    "tags": {
      "param": [
        {
          "name": "blocksize",
          "description": "The number of cells each member of the array can hold.  For example, 32 cells is equivalent to: new Array[X][32]"
        },
        {
          "name": "startsize",
          "description": "Initial size of the array.  Note that data will NOT be auto-initialized."
        }
      ],
      "error": [],
      "note": [],
      "return": "New Handle to the array object."
    },
    "params": [
      {
        "name": "blocksize",
        "type": "int",
        "default": "",
        "description": "The number of cells each member of the array can hold.  For example, 32 cells is equivalent to: new Array[X][32]"
      },
      {
        "name": "startsize",
        "type": "int",
        "default": "",
        "description": "Initial size of the array.  Note that data will NOT be auto-initialized."
      }
    ],
    "full_declaration": "native ArrayList CreateArray(int blocksize=1, int startsize=0);"
  },
  {
    "name": "ClearArray",
    "type": "native",
    "source_file": "adt_array.inc",
    "return_type": "void",
    "comment": "Clears an array of all entries.  This is the same as ResizeArray(0).",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array Handle."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "array",
        "type": "Handle",
        "default": null,
        "description": "Array Handle."
      }
    ],
    "full_declaration": "native void ClearArray(Handle array);"
  },
  {
    "name": "CloneArray",
    "type": "native",
    "source_file": "adt_array.inc",
    "return_type": "Handle",
    "comment": "Clones an array, returning a new handle with the same size and data. This should NOT\nbe confused with CloneHandle. This is a completely new handle with the same data but\nno relation to the original. You MUST close it.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array handle to be cloned"
        }
      ],
      "error": [
        "Invalid Handle"
      ],
      "note": [],
      "return": "New handle to the cloned array object"
    },
    "params": [
      {
        "name": "array",
        "type": "Handle",
        "default": null,
        "description": "Array handle to be cloned"
      }
    ],
    "full_declaration": "native Handle CloneArray(Handle array);"
  },
  {
    "name": "ResizeArray",
    "type": "native",
    "source_file": "adt_array.inc",
    "return_type": "void",
    "comment": "Resizes an array.  If the size is smaller than the current size,\nthe array is truncated.  If the size is larger than the current size,\nthe data at the additional indexes will not be initialized.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array Handle."
        },
        {
          "name": "newsize",
          "description": "New size."
        }
      ],
      "error": [
        "Invalid Handle or out of memory."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "array",
        "type": "Handle",
        "default": null,
        "description": "Array Handle."
      },
      {
        "name": "newsize",
        "type": "int",
        "default": null,
        "description": "New size."
      }
    ],
    "full_declaration": "native void ResizeArray(Handle array, int newsize);"
  },
  {
    "name": "GetArraySize",
    "type": "native",
    "source_file": "adt_array.inc",
    "return_type": "int",
    "comment": "Returns the array size.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array Handle."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Number of elements in the array."
    },
    "params": [
      {
        "name": "array",
        "type": "Handle",
        "default": null,
        "description": "Array Handle."
      }
    ],
    "full_declaration": "native int GetArraySize(Handle array);"
  },
  {
    "name": "PushArrayCell",
    "type": "native",
    "source_file": "adt_array.inc",
    "return_type": "int",
    "comment": "Pushes a value onto the end of an array, adding a new index.\n\nThis may safely be used even if the array has a blocksize\ngreater than 1.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array Handle."
        },
        {
          "name": "value",
          "description": "Value to push."
        }
      ],
      "error": [
        "Invalid Handle or out of memory."
      ],
      "note": [],
      "return": "Index of the new entry."
    },
    "params": [
      {
        "name": "array",
        "type": "Handle",
        "default": null,
        "description": "Array Handle."
      },
      {
        "name": "value",
        "type": "any",
        "default": null,
        "description": "Value to push."
      }
    ],
    "full_declaration": "native int PushArrayCell(Handle array, any value);"
  },
  {
    "name": "PushArrayString",
    "type": "native",
    "source_file": "adt_array.inc",
    "return_type": "int",
    "comment": "Pushes a string onto the end of an array, truncating it\nif it is too big.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array Handle."
        },
        {
          "name": "value",
          "description": "String to push."
        }
      ],
      "error": [
        "Invalid Handle or out of memory."
      ],
      "note": [],
      "return": "Index of the new entry."
    },
    "params": [
      {
        "name": "array",
        "type": "Handle",
        "default": null,
        "description": "Array Handle."
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "String to push."
      }
    ],
    "full_declaration": "native int PushArrayString(Handle array, const char[] value);"
  },
  {
    "name": "PushArrayArray",
    "type": "native",
    "source_file": "adt_array.inc",
    "return_type": "int",
    "comment": "Pushes an array of cells onto the end of an array.  The cells\nare pushed as a block (i.e. the entire array sits at the index),\nrather than pushing each cell individually.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array Handle."
        },
        {
          "name": "values",
          "description": "Block of values to copy."
        },
        {
          "name": "size",
          "description": "If not set, the number of elements copied from the array will be equal to the blocksize.  If set higher than the blocksize, the operation will be truncated."
        }
      ],
      "error": [
        "Invalid Handle or out of memory."
      ],
      "note": [],
      "return": "Index of the new entry."
    },
    "params": [
      {
        "name": "array",
        "type": "Handle",
        "default": null,
        "description": "Array Handle."
      },
      {
        "name": "values",
        "type": "any[]",
        "default": null,
        "description": "Block of values to copy."
      },
      {
        "name": "size",
        "type": "int",
        "default": "",
        "description": "If not set, the number of elements copied from the array will be equal to the blocksize.  If set higher than the blocksize, the operation will be truncated."
      }
    ],
    "full_declaration": "native int PushArrayArray(Handle array, const any[] values, int size=-1);"
  },
  {
    "name": "GetArrayCell",
    "type": "native",
    "source_file": "adt_array.inc",
    "return_type": "any",
    "comment": "Retrieves a cell value from an array.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array Handle."
        },
        {
          "name": "index",
          "description": "Index in the array."
        },
        {
          "name": "block",
          "description": "Optionally specify which block to read from (useful if the blocksize > 0)."
        },
        {
          "name": "asChar",
          "description": "Optionally read as a byte instead of a cell."
        }
      ],
      "error": [
        "Invalid Handle, invalid index, or invalid block."
      ],
      "note": [],
      "return": "Value read."
    },
    "params": [
      {
        "name": "array",
        "type": "Handle",
        "default": null,
        "description": "Array Handle."
      },
      {
        "name": "index",
        "type": "int",
        "default": null,
        "description": "Index in the array."
      },
      {
        "name": "block",
        "type": "int",
        "default": "",
        "description": "Optionally specify which block to read from (useful if the blocksize > 0)."
      },
      {
        "name": "asChar",
        "type": "bool",
        "default": "",
        "description": "Optionally read as a byte instead of a cell."
      }
    ],
    "full_declaration": "native any GetArrayCell(Handle array, int index, int block=0, bool asChar=false);"
  },
  {
    "name": "GetArrayString",
    "type": "native",
    "source_file": "adt_array.inc",
    "return_type": "int",
    "comment": "Retrieves a string value from an array.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array Handle."
        },
        {
          "name": "index",
          "description": "Index in the array."
        },
        {
          "name": "buffer",
          "description": "Buffer to copy to."
        },
        {
          "name": "maxlength",
          "description": "Maximum size of the buffer."
        },
        {
          "name": "block",
          "description": "Optionally specify which block to read from (useful if the blocksize > 0)."
        }
      ],
      "error": [
        "Invalid Handle or invalid index."
      ],
      "note": [],
      "return": "Number of characters copied."
    },
    "params": [
      {
        "name": "array",
        "type": "Handle",
        "default": null,
        "description": "Array Handle."
      },
      {
        "name": "index",
        "type": "int",
        "default": null,
        "description": "Index in the array."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Buffer to copy to."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum size of the buffer."
      },
      {
        "name": "block",
        "type": "int",
        "default": "",
        "description": "Optionally specify which block to read from (useful if the blocksize > 0)."
      }
    ],
    "full_declaration": "native int GetArrayString(Handle array, int index, char[] buffer, int maxlength, int block=0);"
  },
  {
    "name": "GetArrayArray",
    "type": "native",
    "source_file": "adt_array.inc",
    "return_type": "int",
    "comment": "Retrieves an array of cells from an array.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array Handle."
        },
        {
          "name": "index",
          "description": "Index in the array."
        },
        {
          "name": "buffer",
          "description": "Buffer to store the array in."
        },
        {
          "name": "size",
          "description": "If not set, assumes the buffer size is equal to the blocksize.  Otherwise, the size passed is used."
        },
        {
          "name": "block",
          "description": "Optionally specify which block to read from (useful if the blocksize > 0)."
        }
      ],
      "error": [
        "Invalid Handle or invalid index."
      ],
      "note": [],
      "return": "Number of cells copied."
    },
    "params": [
      {
        "name": "array",
        "type": "Handle",
        "default": null,
        "description": "Array Handle."
      },
      {
        "name": "index",
        "type": "int",
        "default": null,
        "description": "Index in the array."
      },
      {
        "name": "buffer",
        "type": "any[]",
        "default": null,
        "description": "Buffer to store the array in."
      },
      {
        "name": "size",
        "type": "int",
        "default": "",
        "description": "If not set, assumes the buffer size is equal to the blocksize.  Otherwise, the size passed is used."
      },
      {
        "name": "block",
        "type": "int",
        "default": "",
        "description": "Optionally specify which block to read from (useful if the blocksize > 0)."
      }
    ],
    "full_declaration": "native int GetArrayArray(Handle array, int index, any[] buffer, int size=-1, int block=0);"
  },
  {
    "name": "SetArrayCell",
    "type": "native",
    "source_file": "adt_array.inc",
    "return_type": "void",
    "comment": "Sets a cell value in an array.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array Handle."
        },
        {
          "name": "index",
          "description": "Index in the array."
        },
        {
          "name": "value",
          "description": "Cell value to set."
        },
        {
          "name": "block",
          "description": "Optionally specify which block to write to (useful if the blocksize > 0)."
        },
        {
          "name": "asChar",
          "description": "Optionally set as a byte instead of a cell."
        }
      ],
      "error": [
        "Invalid Handle, invalid index, or invalid block."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "array",
        "type": "Handle",
        "default": null,
        "description": "Array Handle."
      },
      {
        "name": "index",
        "type": "int",
        "default": null,
        "description": "Index in the array."
      },
      {
        "name": "value",
        "type": "any",
        "default": null,
        "description": "Cell value to set."
      },
      {
        "name": "block",
        "type": "int",
        "default": "",
        "description": "Optionally specify which block to write to (useful if the blocksize > 0)."
      },
      {
        "name": "asChar",
        "type": "bool",
        "default": "",
        "description": "Optionally set as a byte instead of a cell."
      }
    ],
    "full_declaration": "native void SetArrayCell(Handle array, int index, any value, int block=0, bool asChar=false);"
  },
  {
    "name": "SetArrayString",
    "type": "native",
    "source_file": "adt_array.inc",
    "return_type": "int",
    "comment": "Sets a string value in an array.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array Handle."
        },
        {
          "name": "index",
          "description": "Index in the array."
        },
        {
          "name": "value",
          "description": "String value to set."
        },
        {
          "name": "size",
          "description": "If not set, assumes the buffer size is equal to the blocksize.  Otherwise, the size passed is used."
        },
        {
          "name": "block",
          "description": "Optionally specify which block to write to (useful if the blocksize > 0)."
        }
      ],
      "error": [
        "Invalid Handle or invalid index."
      ],
      "note": [],
      "return": "Number of characters copied."
    },
    "params": [
      {
        "name": "array",
        "type": "Handle",
        "default": null,
        "description": "Array Handle."
      },
      {
        "name": "index",
        "type": "int",
        "default": null,
        "description": "Index in the array."
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "String value to set."
      },
      {
        "name": "size",
        "type": "int",
        "default": "",
        "description": "If not set, assumes the buffer size is equal to the blocksize.  Otherwise, the size passed is used."
      },
      {
        "name": "block",
        "type": "int",
        "default": "",
        "description": "Optionally specify which block to write to (useful if the blocksize > 0)."
      }
    ],
    "full_declaration": "native int SetArrayString(Handle array, int index, const char[] value, int size=-1, int block=0);"
  },
  {
    "name": "SetArrayArray",
    "type": "native",
    "source_file": "adt_array.inc",
    "return_type": "int",
    "comment": "Sets an array of cells in an array.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array Handle."
        },
        {
          "name": "index",
          "description": "Index in the array."
        },
        {
          "name": "values",
          "description": "Array to copy."
        },
        {
          "name": "size",
          "description": "If not set, assumes the buffer size is equal to the blocksize.  Otherwise, the size passed is used."
        },
        {
          "name": "block",
          "description": "Optionally specify which block to write to (useful if the blocksize > 0)."
        }
      ],
      "error": [
        "Invalid Handle or invalid index."
      ],
      "note": [],
      "return": "Number of cells copied."
    },
    "params": [
      {
        "name": "array",
        "type": "Handle",
        "default": null,
        "description": "Array Handle."
      },
      {
        "name": "index",
        "type": "int",
        "default": null,
        "description": "Index in the array."
      },
      {
        "name": "values",
        "type": "any[]",
        "default": null,
        "description": "Array to copy."
      },
      {
        "name": "size",
        "type": "int",
        "default": "",
        "description": "If not set, assumes the buffer size is equal to the blocksize.  Otherwise, the size passed is used."
      },
      {
        "name": "block",
        "type": "int",
        "default": "",
        "description": "Optionally specify which block to write to (useful if the blocksize > 0)."
      }
    ],
    "full_declaration": "native int SetArrayArray(Handle array, int index, const any[] values, int size=-1, int block=0);"
  },
  {
    "name": "ShiftArrayUp",
    "type": "native",
    "source_file": "adt_array.inc",
    "return_type": "void",
    "comment": "Shifts an array up.  All array contents after and including the given\nindex are shifted up by one, and the given index is then \"free.\"\nAfter shifting, the contents of the given index is undefined.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array Handle."
        },
        {
          "name": "index",
          "description": "Index in the array to shift up from."
        }
      ],
      "error": [
        "Invalid Handle or invalid index."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "array",
        "type": "Handle",
        "default": null,
        "description": "Array Handle."
      },
      {
        "name": "index",
        "type": "int",
        "default": null,
        "description": "Index in the array to shift up from."
      }
    ],
    "full_declaration": "native void ShiftArrayUp(Handle array, int index);"
  },
  {
    "name": "RemoveFromArray",
    "type": "native",
    "source_file": "adt_array.inc",
    "return_type": "void",
    "comment": "Removes an array index, shifting the entire array down from that position\non.  For example, if item 8 of 10 is removed, the last 3 items will then be\n(6,7,8) instead of (7,8,9), and all indexes before 8 will remain unchanged.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array Handle."
        },
        {
          "name": "index",
          "description": "Index in the array to remove at."
        }
      ],
      "error": [
        "Invalid Handle or invalid index."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "array",
        "type": "Handle",
        "default": null,
        "description": "Array Handle."
      },
      {
        "name": "index",
        "type": "int",
        "default": null,
        "description": "Index in the array to remove at."
      }
    ],
    "full_declaration": "native void RemoveFromArray(Handle array, int index);"
  },
  {
    "name": "SwapArrayItems",
    "type": "native",
    "source_file": "adt_array.inc",
    "return_type": "void",
    "comment": "Swaps two items in the array.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array Handle."
        },
        {
          "name": "index1",
          "description": "First index."
        },
        {
          "name": "index2",
          "description": "Second index."
        }
      ],
      "error": [
        "Invalid Handle or invalid index."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "array",
        "type": "Handle",
        "default": null,
        "description": "Array Handle."
      },
      {
        "name": "index1",
        "type": "int",
        "default": null,
        "description": "First index."
      },
      {
        "name": "index2",
        "type": "int",
        "default": null,
        "description": "Second index."
      }
    ],
    "full_declaration": "native void SwapArrayItems(Handle array, int index1, int index2);"
  },
  {
    "name": "FindStringInArray",
    "type": "native",
    "source_file": "adt_array.inc",
    "return_type": "int",
    "comment": "Returns the index for the first occurrence of the provided string. If the string\ncannot be located, -1 will be returned.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array Handle."
        },
        {
          "name": "item",
          "description": "String to search for"
        },
        {
          "name": "block",
          "description": "Optionally which block to search in"
        }
      ],
      "error": [
        "Invalid Handle"
      ],
      "note": [],
      "return": "Array index, or -1 on failure"
    },
    "params": [
      {
        "name": "array",
        "type": "Handle",
        "default": null,
        "description": "Array Handle."
      },
      {
        "name": "item",
        "type": "char[]",
        "default": null,
        "description": "String to search for"
      },
      {
        "name": "block",
        "type": "int",
        "default": "",
        "description": "Optionally which block to search in"
      }
    ],
    "full_declaration": "native int FindStringInArray(Handle array, const char[] item, int block=0);"
  },
  {
    "name": "FindValueInArray",
    "type": "native",
    "source_file": "adt_array.inc",
    "return_type": "int",
    "comment": "Returns the index for the first occurrence of the provided value. If the value\ncannot be located, -1 will be returned.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array Handle."
        },
        {
          "name": "item",
          "description": "Value to search for"
        },
        {
          "name": "block",
          "description": "Optionally which block to search in"
        }
      ],
      "error": [
        "Invalid Handle or invalid block"
      ],
      "note": [],
      "return": "Array index, or -1 on failure"
    },
    "params": [
      {
        "name": "array",
        "type": "Handle",
        "default": null,
        "description": "Array Handle."
      },
      {
        "name": "item",
        "type": "any",
        "default": null,
        "description": "Value to search for"
      },
      {
        "name": "block",
        "type": "int",
        "default": "",
        "description": "Optionally which block to search in"
      }
    ],
    "full_declaration": "native int FindValueInArray(Handle array, any item, int block=0);"
  },
  {
    "name": "GetArrayBlockSize",
    "type": "native",
    "source_file": "adt_array.inc",
    "return_type": "int",
    "comment": "Returns the blocksize the array was created with.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array Handle."
        }
      ],
      "error": [
        "Invalid Handle"
      ],
      "note": [],
      "return": "The blocksize of the array."
    },
    "params": [
      {
        "name": "array",
        "type": "Handle",
        "default": null,
        "description": "Array Handle."
      }
    ],
    "full_declaration": "native int GetArrayBlockSize(Handle array);"
  },
  {
    "name": "CreateStack",
    "type": "native",
    "source_file": "adt_stack.inc",
    "return_type": "ArrayStack",
    "comment": "Creates a stack structure.  A stack is a LIFO (last in, first out)\nvector (array) of items.  It has O(1) insertion and O(1) removal.\n\nStacks have two operations: Push (adding an item) and Pop (removes\nitems in reverse-push order).\n\nThe contents of the stack are uniform; i.e. storing a string and then\nretrieving it as an integer is NOT the same as StringToInt()!\n\nThe \"blocksize\" determines how many cells each slot has; it cannot\nbe changed after creation.",
    "tags": {
      "param": [
        {
          "name": "blocksize",
          "description": "The number of cells each entry in the stack can hold.  For example, 32 cells is equivalent to: new Array[X][32]"
        }
      ],
      "error": [],
      "note": [],
      "return": "New stack Handle."
    },
    "params": [
      {
        "name": "blocksize",
        "type": "int",
        "default": "",
        "description": "The number of cells each entry in the stack can hold.  For example, 32 cells is equivalent to: new Array[X][32]"
      }
    ],
    "full_declaration": "native ArrayStack CreateStack(int blocksize=1);"
  },
  {
    "name": "PushStackCell",
    "type": "native",
    "source_file": "adt_stack.inc",
    "return_type": "void",
    "comment": "Pushes a value onto the end of the stack, adding a new index.\n\nThis may safely be used even if the stack has a blocksize\ngreater than 1.",
    "tags": {
      "param": [
        {
          "name": "stack",
          "description": "Stack Handle."
        },
        {
          "name": "value",
          "description": "Value to push."
        }
      ],
      "error": [
        "Invalid Handle or out of memory."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "stack",
        "type": "Handle",
        "default": null,
        "description": "Stack Handle."
      },
      {
        "name": "value",
        "type": "any",
        "default": null,
        "description": "Value to push."
      }
    ],
    "full_declaration": "native void PushStackCell(Handle stack, any value);"
  },
  {
    "name": "PushStackString",
    "type": "native",
    "source_file": "adt_stack.inc",
    "return_type": "void",
    "comment": "Pushes a copy of a string onto the end of a stack, truncating it if it is\ntoo big.",
    "tags": {
      "param": [
        {
          "name": "stack",
          "description": "Stack Handle."
        },
        {
          "name": "value",
          "description": "String to push."
        }
      ],
      "error": [
        "Invalid Handle or out of memory."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "stack",
        "type": "Handle",
        "default": null,
        "description": "Stack Handle."
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "String to push."
      }
    ],
    "full_declaration": "native void PushStackString(Handle stack, const char[] value);"
  },
  {
    "name": "PushStackArray",
    "type": "native",
    "source_file": "adt_stack.inc",
    "return_type": "void",
    "comment": "Pushes a copy of an array of cells onto the end of a stack.  The cells\nare pushed as a block (i.e. the entire array takes up one stack slot),\nrather than pushing each cell individually.",
    "tags": {
      "param": [
        {
          "name": "stack",
          "description": "Stack Handle."
        },
        {
          "name": "values",
          "description": "Block of values to copy."
        },
        {
          "name": "size",
          "description": "If not set, the number of elements copied from the array will be equal to the blocksize.  If set higher than the blocksize, the operation will be truncated."
        }
      ],
      "error": [
        "Invalid Handle or out of memory."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "stack",
        "type": "Handle",
        "default": null,
        "description": "Stack Handle."
      },
      {
        "name": "values",
        "type": "any[]",
        "default": null,
        "description": "Block of values to copy."
      },
      {
        "name": "size",
        "type": "int",
        "default": "",
        "description": "If not set, the number of elements copied from the array will be equal to the blocksize.  If set higher than the blocksize, the operation will be truncated."
      }
    ],
    "full_declaration": "native void PushStackArray(Handle stack, const any[] values, int size=-1);"
  },
  {
    "name": "PopStackCell",
    "type": "native",
    "source_file": "adt_stack.inc",
    "return_type": "bool",
    "comment": "Pops a cell value from a stack.",
    "tags": {
      "param": [
        {
          "name": "stack",
          "description": "Stack Handle."
        },
        {
          "name": "value",
          "description": "Variable to store the value."
        },
        {
          "name": "block",
          "description": "Optionally specify which block to read from (useful if the blocksize > 0)."
        },
        {
          "name": "asChar",
          "description": "Optionally read as a byte instead of a cell."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false if the stack is empty."
    },
    "params": [
      {
        "name": "stack",
        "type": "Handle",
        "default": null,
        "description": "Stack Handle."
      },
      {
        "name": "value",
        "type": "any",
        "default": null,
        "description": "Variable to store the value."
      },
      {
        "name": "block",
        "type": "int",
        "default": "",
        "description": "Optionally specify which block to read from (useful if the blocksize > 0)."
      },
      {
        "name": "asChar",
        "type": "bool",
        "default": "",
        "description": "Optionally read as a byte instead of a cell."
      }
    ],
    "full_declaration": "native bool PopStackCell(Handle stack, any &value, int block=0, bool asChar=false);"
  },
  {
    "name": "PopStackString",
    "type": "native",
    "source_file": "adt_stack.inc",
    "return_type": "bool",
    "comment": "Pops a string value from a stack.",
    "tags": {
      "param": [
        {
          "name": "stack",
          "description": "Stack Handle."
        },
        {
          "name": "buffer",
          "description": "Buffer to store string."
        },
        {
          "name": "maxlength",
          "description": "Maximum size of the buffer."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false if the stack is empty."
    },
    "params": [
      {
        "name": "stack",
        "type": "Handle",
        "default": null,
        "description": "Stack Handle."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store string."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum size of the buffer."
      },
      {
        "name": "written",
        "type": "int",
        "default": "",
        "description": ""
      }
    ],
    "full_declaration": "native bool PopStackString(Handle stack, char[] buffer, int maxlength, int &written=0);"
  },
  {
    "name": "PopStackArray",
    "type": "native",
    "source_file": "adt_stack.inc",
    "return_type": "bool",
    "comment": "Pops an array of cells from a stack.",
    "tags": {
      "param": [
        {
          "name": "stack",
          "description": "Stack Handle."
        },
        {
          "name": "buffer",
          "description": "Buffer to store the array in."
        },
        {
          "name": "size",
          "description": "If not set, assumes the buffer size is equal to the blocksize.  Otherwise, the size passed is used."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false if the stack is empty."
    },
    "params": [
      {
        "name": "stack",
        "type": "Handle",
        "default": null,
        "description": "Stack Handle."
      },
      {
        "name": "buffer",
        "type": "any[]",
        "default": null,
        "description": "Buffer to store the array in."
      },
      {
        "name": "size",
        "type": "int",
        "default": "",
        "description": "If not set, assumes the buffer size is equal to the blocksize.  Otherwise, the size passed is used."
      }
    ],
    "full_declaration": "native bool PopStackArray(Handle stack, any[] buffer, int size=-1);"
  },
  {
    "name": "IsStackEmpty",
    "type": "native",
    "source_file": "adt_stack.inc",
    "return_type": "bool",
    "comment": "Checks if a stack is empty.",
    "tags": {
      "param": [
        {
          "name": "stack",
          "description": "Stack Handle."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True if empty, false if not empty."
    },
    "params": [
      {
        "name": "stack",
        "type": "Handle",
        "default": null,
        "description": "Stack Handle."
      }
    ],
    "full_declaration": "native bool IsStackEmpty(Handle stack);"
  },
  {
    "name": "PopStack",
    "type": "stock",
    "source_file": "adt_stack.inc",
    "return_type": "bool",
    "comment": "Pops a value off a stack, ignoring it completely.",
    "tags": {
      "param": [
        {
          "name": "stack",
          "description": "Stack Handle."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True if something was popped, false otherwise."
    },
    "params": [
      {
        "name": "stack",
        "type": "Handle",
        "default": null,
        "description": "Stack Handle."
      }
    ],
    "full_declaration": "stock bool PopStack(Handle stack) { \tint value; \treturn PopStackCell(stack, value);"
  },
  {
    "name": "GetStackBlockSize",
    "type": "native",
    "source_file": "adt_stack.inc",
    "return_type": "int",
    "comment": "Returns the blocksize the stack was created with.",
    "tags": {
      "param": [
        {
          "name": "stack",
          "description": "Stack Handle."
        }
      ],
      "error": [
        "Invalid Handle"
      ],
      "note": [],
      "return": "The blocksize of the stack."
    },
    "params": [
      {
        "name": "stack",
        "type": "Handle",
        "default": null,
        "description": "Stack Handle."
      }
    ],
    "full_declaration": "native int GetStackBlockSize(Handle stack);"
  },
  {
    "name": "StringMapSnapshot",
    "type": "methodmap",
    "source_file": "adt_trie.inc",
    "inherits": "Handle",
    "comment": "A StringMapSnapshot is created via StringMap.Snapshot(). It captures the\nkeys on a map so they can be read. Snapshots must be freed with delete or\nCloseHandle().",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "methods": [],
    "properties": [],
    "full_declaration": "methodmap StringMapSnapshot < Handle"
  },
  {
    "name": "CreateTrie",
    "type": "native",
    "source_file": "adt_trie.inc",
    "return_type": "StringMap",
    "comment": "Creates a hash map. A hash map is a container that can map strings (called\n\"keys\") to arbitrary values (cells, arrays, or strings). Keys in a hash map\nare unique. That is, there is at most one entry in the map for a given key.\n\nInsertion, deletion, and lookup in a hash map are all considered to be fast\noperations, amortized to O(1), or constant time.\n\nThe word \"Trie\" in this API is historical. As of SourceMod 1.6, tries have\nbeen internally replaced with hash tables, which have O(1) insertion time\ninstead of O(n).",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "New Map Handle, which must be freed via CloseHandle()."
    },
    "params": [],
    "full_declaration": "native StringMap CreateTrie();"
  },
  {
    "name": "SetTrieValue",
    "type": "native",
    "source_file": "adt_trie.inc",
    "return_type": "bool",
    "comment": "Sets a value in a hash map, either inserting a new entry or replacing an old one.",
    "tags": {
      "param": [
        {
          "name": "map",
          "description": "Map Handle."
        },
        {
          "name": "key",
          "description": "Key string."
        },
        {
          "name": "value",
          "description": "Value to store at this key."
        },
        {
          "name": "replace",
          "description": "If false, operation will fail if the key is already set."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false on failure."
    },
    "params": [
      {
        "name": "map",
        "type": "Handle",
        "default": null,
        "description": "Map Handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Key string."
      },
      {
        "name": "value",
        "type": "any",
        "default": null,
        "description": "Value to store at this key."
      },
      {
        "name": "replace",
        "type": "bool",
        "default": "",
        "description": "If false, operation will fail if the key is already set."
      }
    ],
    "full_declaration": "native bool SetTrieValue(Handle map, const char[] key, any value, bool replace=true);"
  },
  {
    "name": "SetTrieArray",
    "type": "native",
    "source_file": "adt_trie.inc",
    "return_type": "bool",
    "comment": "Sets an array value in a Map, either inserting a new entry or replacing an old one.",
    "tags": {
      "param": [
        {
          "name": "map",
          "description": "Map Handle."
        },
        {
          "name": "key",
          "description": "Key string."
        },
        {
          "name": "array",
          "description": "Array to store."
        },
        {
          "name": "num_items",
          "description": "Number of items in the array."
        },
        {
          "name": "replace",
          "description": "If false, operation will fail if the key is already set."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false on failure."
    },
    "params": [
      {
        "name": "map",
        "type": "Handle",
        "default": null,
        "description": "Map Handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Key string."
      },
      {
        "name": "array",
        "type": "any[]",
        "default": null,
        "description": "Array to store."
      },
      {
        "name": "num_items",
        "type": "int",
        "default": null,
        "description": "Number of items in the array."
      },
      {
        "name": "replace",
        "type": "bool",
        "default": "",
        "description": "If false, operation will fail if the key is already set."
      }
    ],
    "full_declaration": "native bool SetTrieArray(Handle map, const char[] key, const any[] array, int num_items, bool replace=true);"
  },
  {
    "name": "SetTrieString",
    "type": "native",
    "source_file": "adt_trie.inc",
    "return_type": "bool",
    "comment": "Sets a string value in a Map, either inserting a new entry or replacing an old one.",
    "tags": {
      "param": [
        {
          "name": "map",
          "description": "Map Handle."
        },
        {
          "name": "key",
          "description": "Key string."
        },
        {
          "name": "value",
          "description": "String to store."
        },
        {
          "name": "replace",
          "description": "If false, operation will fail if the key is already set."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false on failure."
    },
    "params": [
      {
        "name": "map",
        "type": "Handle",
        "default": null,
        "description": "Map Handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Key string."
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "String to store."
      },
      {
        "name": "replace",
        "type": "bool",
        "default": "",
        "description": "If false, operation will fail if the key is already set."
      }
    ],
    "full_declaration": "native bool SetTrieString(Handle map, const char[] key, const char[] value, bool replace=true);"
  },
  {
    "name": "GetTrieValue",
    "type": "native",
    "source_file": "adt_trie.inc",
    "return_type": "bool",
    "comment": "Retrieves a value in a Map.",
    "tags": {
      "param": [
        {
          "name": "map",
          "description": "Map Handle."
        },
        {
          "name": "key",
          "description": "Key string."
        },
        {
          "name": "value",
          "description": "Variable to store value."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success.  False if the key is not set, or the key is set as an array or string (not a value)."
    },
    "params": [
      {
        "name": "map",
        "type": "Handle",
        "default": null,
        "description": "Map Handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Key string."
      },
      {
        "name": "value",
        "type": "any",
        "default": null,
        "description": "Variable to store value."
      }
    ],
    "full_declaration": "native bool GetTrieValue(Handle map, const char[] key, any &value);"
  },
  {
    "name": "GetTrieArray",
    "type": "native",
    "source_file": "adt_trie.inc",
    "return_type": "bool",
    "comment": "Retrieves an array in a Map.",
    "tags": {
      "param": [
        {
          "name": "map",
          "description": "Map Handle."
        },
        {
          "name": "key",
          "description": "Key string."
        },
        {
          "name": "array",
          "description": "Buffer to store array."
        },
        {
          "name": "max_size",
          "description": "Maximum size of array buffer."
        },
        {
          "name": "size",
          "description": "Optional parameter to store the number of elements written to the buffer."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success.  False if the key is not set, or the key is set as a value or string (not an array)."
    },
    "params": [
      {
        "name": "map",
        "type": "Handle",
        "default": null,
        "description": "Map Handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Key string."
      },
      {
        "name": "array",
        "type": "any[]",
        "default": null,
        "description": "Buffer to store array."
      },
      {
        "name": "max_size",
        "type": "int",
        "default": null,
        "description": "Maximum size of array buffer."
      },
      {
        "name": "size",
        "type": "int",
        "default": "",
        "description": "Optional parameter to store the number of elements written to the buffer."
      }
    ],
    "full_declaration": "native bool GetTrieArray(Handle map, const char[] key, any[] array, int max_size, int &size=0);"
  },
  {
    "name": "GetTrieString",
    "type": "native",
    "source_file": "adt_trie.inc",
    "return_type": "bool",
    "comment": "Retrieves a string in a Map.",
    "tags": {
      "param": [
        {
          "name": "map",
          "description": "Map Handle."
        },
        {
          "name": "key",
          "description": "Key string."
        },
        {
          "name": "value",
          "description": "Buffer to store value."
        },
        {
          "name": "max_size",
          "description": "Maximum size of string buffer."
        },
        {
          "name": "size",
          "description": "Optional parameter to store the number of bytes written to the buffer."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success.  False if the key is not set, or the key is set as a value or array (not a string)."
    },
    "params": [
      {
        "name": "map",
        "type": "Handle",
        "default": null,
        "description": "Map Handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Key string."
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store value."
      },
      {
        "name": "max_size",
        "type": "int",
        "default": null,
        "description": "Maximum size of string buffer."
      },
      {
        "name": "size",
        "type": "int",
        "default": "",
        "description": "Optional parameter to store the number of bytes written to the buffer."
      }
    ],
    "full_declaration": "native bool GetTrieString(Handle map, const char[] key, char[] value, int max_size, int &size=0);"
  },
  {
    "name": "RemoveFromTrie",
    "type": "native",
    "source_file": "adt_trie.inc",
    "return_type": "bool",
    "comment": "Removes a key entry from a Map.",
    "tags": {
      "param": [
        {
          "name": "map",
          "description": "Map Handle."
        },
        {
          "name": "key",
          "description": "Key string."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false if the value was never set."
    },
    "params": [
      {
        "name": "map",
        "type": "Handle",
        "default": null,
        "description": "Map Handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Key string."
      }
    ],
    "full_declaration": "native bool RemoveFromTrie(Handle map, const char[] key);"
  },
  {
    "name": "ClearTrie",
    "type": "native",
    "source_file": "adt_trie.inc",
    "return_type": "void",
    "comment": "Clears all entries from a Map.",
    "tags": {
      "param": [
        {
          "name": "map",
          "description": "Map Handle."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "map",
        "type": "Handle",
        "default": null,
        "description": "Map Handle."
      }
    ],
    "full_declaration": "native void ClearTrie(Handle map);"
  },
  {
    "name": "GetTrieSize",
    "type": "native",
    "source_file": "adt_trie.inc",
    "return_type": "int",
    "comment": "Retrieves the number of elements in a map.",
    "tags": {
      "param": [
        {
          "name": "map",
          "description": "Map Handle."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Number of elements in the trie."
    },
    "params": [
      {
        "name": "map",
        "type": "Handle",
        "default": null,
        "description": "Map Handle."
      }
    ],
    "full_declaration": "native int GetTrieSize(Handle map);"
  },
  {
    "name": "CreateTrieSnapshot",
    "type": "native",
    "source_file": "adt_trie.inc",
    "return_type": "Handle",
    "comment": "Creates a snapshot of all keys in the map. If the map is changed after this\ncall, the changes are not reflected in the snapshot. Keys are not sorted.",
    "tags": {
      "param": [
        {
          "name": "map",
          "description": "Map Handle."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "New Map Snapshot Handle, which must be closed via CloseHandle()."
    },
    "params": [
      {
        "name": "map",
        "type": "Handle",
        "default": null,
        "description": "Map Handle."
      }
    ],
    "full_declaration": "native Handle CreateTrieSnapshot(Handle map);"
  },
  {
    "name": "TrieSnapshotLength",
    "type": "native",
    "source_file": "adt_trie.inc",
    "return_type": "int",
    "comment": "Returns the number of keys in a map snapshot. Note that this may be\ndifferent from the size of the map, since the map can change after the\nsnapshot of its keys was taken.",
    "tags": {
      "param": [
        {
          "name": "snapshot",
          "description": "Map snapshot."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Number of keys."
    },
    "params": [
      {
        "name": "snapshot",
        "type": "Handle",
        "default": null,
        "description": "Map snapshot."
      }
    ],
    "full_declaration": "native int TrieSnapshotLength(Handle snapshot);"
  },
  {
    "name": "TrieSnapshotKeyBufferSize",
    "type": "native",
    "source_file": "adt_trie.inc",
    "return_type": "int",
    "comment": "Returns the buffer size required to store a given key. That is, it returns\nthe length of the key plus one.",
    "tags": {
      "param": [
        {
          "name": "snapshot",
          "description": "Map snapshot."
        },
        {
          "name": "index",
          "description": "Key index (starting from 0)."
        }
      ],
      "error": [
        "Invalid Handle or index out of range."
      ],
      "note": [],
      "return": "Buffer size required to store the key string."
    },
    "params": [
      {
        "name": "snapshot",
        "type": "Handle",
        "default": null,
        "description": "Map snapshot."
      },
      {
        "name": "index",
        "type": "int",
        "default": null,
        "description": "Key index (starting from 0)."
      }
    ],
    "full_declaration": "native int TrieSnapshotKeyBufferSize(Handle snapshot, int index);"
  },
  {
    "name": "GetTrieSnapshotKey",
    "type": "native",
    "source_file": "adt_trie.inc",
    "return_type": "int",
    "comment": "Retrieves the key string of a given key in a map snapshot.",
    "tags": {
      "param": [
        {
          "name": "snapshot",
          "description": "Map snapshot."
        },
        {
          "name": "index",
          "description": "Key index (starting from 0)."
        },
        {
          "name": "buffer",
          "description": "String buffer."
        },
        {
          "name": "maxlength",
          "description": "Maximum buffer length."
        }
      ],
      "error": [
        "Invalid Handle or index out of range."
      ],
      "note": [],
      "return": "Number of bytes written to the buffer."
    },
    "params": [
      {
        "name": "snapshot",
        "type": "Handle",
        "default": null,
        "description": "Map snapshot."
      },
      {
        "name": "index",
        "type": "int",
        "default": null,
        "description": "Key index (starting from 0)."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "String buffer."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum buffer length."
      }
    ],
    "full_declaration": "native int GetTrieSnapshotKey(Handle snapshot, int index, char[] buffer, int maxlength);"
  },
  {
    "name": "OnBanClient",
    "type": "forward",
    "source_file": "banning.inc",
    "return_type": "Action",
    "comment": "Called for calls to BanClient() with a non-empty command.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client being banned."
        },
        {
          "name": "time",
          "description": "Time the client is being banned for (0 = permanent)."
        },
        {
          "name": "flags",
          "description": "One if AUTHID or IP will be enabled.  If AUTO is also enabled, it means Core autodetected which to use."
        },
        {
          "name": "reason",
          "description": "Reason passed via BanClient()."
        },
        {
          "name": "kick_message",
          "description": "Kick message passed via BanClient()."
        },
        {
          "name": "command",
          "description": "Command string to identify the ban source."
        },
        {
          "name": "source",
          "description": "Source value passed via BanClient()."
        }
      ],
      "error": [],
      "note": [],
      "return": "Plugin_Handled to block the actual server banning. Kicking will still occur."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client being banned."
      },
      {
        "name": "time",
        "type": "int",
        "default": null,
        "description": "Time the client is being banned for (0 = permanent)."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "One if AUTHID or IP will be enabled.  If AUTO is also enabled, it means Core autodetected which to use."
      },
      {
        "name": "reason",
        "type": "char[]",
        "default": null,
        "description": "Reason passed via BanClient()."
      },
      {
        "name": "kick_message",
        "type": "char[]",
        "default": null,
        "description": "Kick message passed via BanClient()."
      },
      {
        "name": "command",
        "type": "char[]",
        "default": null,
        "description": "Command string to identify the ban source."
      },
      {
        "name": "source",
        "type": "any",
        "default": null,
        "description": "Source value passed via BanClient()."
      }
    ],
    "full_declaration": "forward Action OnBanClient(int client, \t\t\t\t\t\t   int time,  \t\t\t\t\t\t   int flags,  \t\t\t\t\t\t   const char[] reason,  \t\t\t\t\t\t   const char[] kick_message,  \t\t\t\t\t\t   const char[] command, \t\t\t\t\t\t   any source);"
  },
  {
    "name": "OnBanIdentity",
    "type": "forward",
    "source_file": "banning.inc",
    "return_type": "Action",
    "comment": "Called for calls to BanIdentity() with a non-empty command.",
    "tags": {
      "param": [
        {
          "name": "identity",
          "description": "Identity string being banned (authstring or ip)."
        },
        {
          "name": "time",
          "description": "Time the client is being banned for (0 = permanent)."
        },
        {
          "name": "flags",
          "description": "Ban flags (only IP or AUTHID are valid here)."
        },
        {
          "name": "reason",
          "description": "Reason passed via BanIdentity()."
        },
        {
          "name": "command",
          "description": "Command string to identify the ban source."
        },
        {
          "name": "source",
          "description": "Source value passed via BanIdentity()."
        }
      ],
      "error": [],
      "note": [],
      "return": "Plugin_Handled to block the actual server banning."
    },
    "params": [
      {
        "name": "identity",
        "type": "char[]",
        "default": null,
        "description": "Identity string being banned (authstring or ip)."
      },
      {
        "name": "time",
        "type": "int",
        "default": null,
        "description": "Time the client is being banned for (0 = permanent)."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "Ban flags (only IP or AUTHID are valid here)."
      },
      {
        "name": "reason",
        "type": "char[]",
        "default": null,
        "description": "Reason passed via BanIdentity()."
      },
      {
        "name": "command",
        "type": "char[]",
        "default": null,
        "description": "Command string to identify the ban source."
      },
      {
        "name": "source",
        "type": "any",
        "default": null,
        "description": "Source value passed via BanIdentity()."
      }
    ],
    "full_declaration": "forward Action OnBanIdentity(const char[] identity, \t\t\t\t\t\t\t int time, \t\t\t\t\t\t\t int flags, \t\t\t\t\t\t\t const char[] reason, \t\t\t\t\t\t\t const char[] command, \t\t\t\t\t\t\t any source);"
  },
  {
    "name": "OnRemoveBan",
    "type": "forward",
    "source_file": "banning.inc",
    "return_type": "Action",
    "comment": "Called for calls to RemoveBan() with a non-empty command.",
    "tags": {
      "param": [
        {
          "name": "identity",
          "description": "Identity string being banned (authstring or ip)."
        },
        {
          "name": "flags",
          "description": "Ban flags (only IP or AUTHID are valid here)."
        },
        {
          "name": "command",
          "description": "Command string to identify the ban source."
        },
        {
          "name": "source",
          "description": "Source value passed via BanIdentity()."
        }
      ],
      "error": [],
      "note": [],
      "return": "Plugin_Handled to block the actual unbanning."
    },
    "params": [
      {
        "name": "identity",
        "type": "char[]",
        "default": null,
        "description": "Identity string being banned (authstring or ip)."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "Ban flags (only IP or AUTHID are valid here)."
      },
      {
        "name": "command",
        "type": "char[]",
        "default": null,
        "description": "Command string to identify the ban source."
      },
      {
        "name": "source",
        "type": "any",
        "default": null,
        "description": "Source value passed via BanIdentity()."
      }
    ],
    "full_declaration": "forward Action OnRemoveBan(const char[] identity, \t\t\t\t\t\t   int flags, \t\t\t\t\t\t   const char[] command, \t\t\t\t\t\t   any source);"
  },
  {
    "name": "BanClient",
    "type": "native",
    "source_file": "banning.inc",
    "return_type": "bool",
    "comment": "Bans a client.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client being banned."
        },
        {
          "name": "time",
          "description": "Time (in minutes) to ban (0 = permanent)."
        },
        {
          "name": "flags",
          "description": "Flags for controlling the ban mechanism.  If AUTHID is set and no AUTHID is available, the ban will fail unless AUTO is also flagged."
        },
        {
          "name": "reason",
          "description": "Reason to ban the client for."
        },
        {
          "name": "kick_message",
          "description": "Message to display to the user when kicking."
        },
        {
          "name": "command",
          "description": "Command string to identify the source.  If this is left empty, then the OnBanClient forward will not be called."
        },
        {
          "name": "source",
          "description": "A source value that could be interpreted as a player index of any sort (not actually checked by Core)."
        }
      ],
      "error": [
        "Invalid client index or client not in game."
      ],
      "note": [],
      "return": "True on success, false on failure."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client being banned."
      },
      {
        "name": "time",
        "type": "int",
        "default": null,
        "description": "Time (in minutes) to ban (0 = permanent)."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "Flags for controlling the ban mechanism.  If AUTHID is set and no AUTHID is available, the ban will fail unless AUTO is also flagged."
      },
      {
        "name": "reason",
        "type": "char[]",
        "default": null,
        "description": "Reason to ban the client for."
      },
      {
        "name": "kick_message",
        "type": "char[]",
        "default": "",
        "description": "Message to display to the user when kicking."
      },
      {
        "name": "command",
        "type": "char[]",
        "default": "",
        "description": "Command string to identify the source.  If this is left empty, then the OnBanClient forward will not be called."
      },
      {
        "name": "source",
        "type": "any",
        "default": "",
        "description": "A source value that could be interpreted as a player index of any sort (not actually checked by Core)."
      }
    ],
    "full_declaration": "native bool BanClient(int client,  \t\t\t\t\t  int time,  \t\t\t\t\t  int flags,  \t\t\t\t\t  const char[] reason,  \t\t\t\t\t  const char[] kick_message=\"\",  \t\t\t\t\t  const char[] command=\"\", \t\t\t\t\t  any source=0);"
  },
  {
    "name": "BanIdentity",
    "type": "native",
    "source_file": "banning.inc",
    "return_type": "bool",
    "comment": "Bans an identity (either an IP address or auth string).",
    "tags": {
      "param": [
        {
          "name": "identity",
          "description": "String to ban (ip or authstring)."
        },
        {
          "name": "time",
          "description": "Time to ban for (0 = permanent)."
        },
        {
          "name": "flags",
          "description": "Flags (only IP and AUTHID are valid flags here)."
        },
        {
          "name": "reason",
          "description": "Ban reason string."
        },
        {
          "name": "command",
          "description": "Command string to identify the source.  If this is left empty, then the OnBanIdentity forward will not be called."
        },
        {
          "name": "source",
          "description": "A source value that could be interpreted as a player index of any sort (not actually checked by Core)."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false on failure."
    },
    "params": [
      {
        "name": "identity",
        "type": "char[]",
        "default": null,
        "description": "String to ban (ip or authstring)."
      },
      {
        "name": "time",
        "type": "int",
        "default": null,
        "description": "Time to ban for (0 = permanent)."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "Flags (only IP and AUTHID are valid flags here)."
      },
      {
        "name": "reason",
        "type": "char[]",
        "default": null,
        "description": "Ban reason string."
      },
      {
        "name": "command",
        "type": "char[]",
        "default": "",
        "description": "Command string to identify the source.  If this is left empty, then the OnBanIdentity forward will not be called."
      },
      {
        "name": "source",
        "type": "any",
        "default": "",
        "description": "A source value that could be interpreted as a player index of any sort (not actually checked by Core)."
      }
    ],
    "full_declaration": "native bool BanIdentity(const char[] identity,  \t\t\t\t\t\tint time,  \t\t\t\t\t\tint flags,  \t\t\t\t\t\tconst char[] reason, \t\t\t\t\t\tconst char[] command=\"\", \t\t\t\t\t\tany source=0);"
  },
  {
    "name": "RemoveBan",
    "type": "native",
    "source_file": "banning.inc",
    "return_type": "bool",
    "comment": "Removes a ban that was written to the server (either in memory or on disk).",
    "tags": {
      "param": [
        {
          "name": "identity",
          "description": "String to unban (ip or authstring)."
        },
        {
          "name": "flags",
          "description": "Flags (only IP and AUTHID are valid flags here)."
        },
        {
          "name": "command",
          "description": "Command string to identify the source.  If this is left empty, then OnRemoveBan will not be called."
        },
        {
          "name": "source",
          "description": "A source value that could be interpreted as a player index of any sort (not actually checked by Core)."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false on failure."
    },
    "params": [
      {
        "name": "identity",
        "type": "char[]",
        "default": null,
        "description": "String to unban (ip or authstring)."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "Flags (only IP and AUTHID are valid flags here)."
      },
      {
        "name": "command",
        "type": "char[]",
        "default": "",
        "description": "Command string to identify the source.  If this is left empty, then OnRemoveBan will not be called."
      },
      {
        "name": "source",
        "type": "any",
        "default": "",
        "description": "A source value that could be interpreted as a player index of any sort (not actually checked by Core)."
      }
    ],
    "full_declaration": "native bool RemoveBan(const char[] identity,  \t\t\t\t\t  int flags,  \t\t\t\t\t  const char[] command=\"\",  \t\t\t\t\t  any source=0);"
  },
  {
    "name": "BaseComm_OnClientMute",
    "type": "forward",
    "source_file": "basecomm.inc",
    "return_type": "void",
    "comment": "Called when a client is muted or unmuted",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index"
        },
        {
          "name": "muteState",
          "description": "True if client was muted, false otherwise"
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index"
      },
      {
        "name": "muteState",
        "type": "bool",
        "default": null,
        "description": "True if client was muted, false otherwise"
      }
    ],
    "full_declaration": "forward void BaseComm_OnClientMute(int client, bool muteState);"
  },
  {
    "name": "BaseComm_OnClientGag",
    "type": "forward",
    "source_file": "basecomm.inc",
    "return_type": "void",
    "comment": "Called when a client is gagged or ungagged",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index"
        },
        {
          "name": "gagState",
          "description": "True if client was gaged, false otherwise"
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index"
      },
      {
        "name": "gagState",
        "type": "bool",
        "default": null,
        "description": "True if client was gaged, false otherwise"
      }
    ],
    "full_declaration": "forward void BaseComm_OnClientGag(int client, bool gagState);"
  },
  {
    "name": "BaseComm_IsClientGagged",
    "type": "native",
    "source_file": "basecomm.inc",
    "return_type": "bool",
    "comment": "Returns whether or not a client is gagged",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if client is gagged, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      }
    ],
    "full_declaration": "native bool BaseComm_IsClientGagged(int client);"
  },
  {
    "name": "BaseComm_IsClientMuted",
    "type": "native",
    "source_file": "basecomm.inc",
    "return_type": "bool",
    "comment": "Returns whether or not a client is muted",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if client is muted, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      }
    ],
    "full_declaration": "native bool BaseComm_IsClientMuted(int client);"
  },
  {
    "name": "BaseComm_SetClientGag",
    "type": "native",
    "source_file": "basecomm.inc",
    "return_type": "bool",
    "comment": "Sets a client's gag state",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "gagState",
          "description": "True to gag client, false to ungag."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if this caused a change in gag state, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "gagState",
        "type": "bool",
        "default": null,
        "description": "True to gag client, false to ungag."
      }
    ],
    "full_declaration": "native bool BaseComm_SetClientGag(int client, bool gagState);"
  },
  {
    "name": "BaseComm_SetClientMute",
    "type": "native",
    "source_file": "basecomm.inc",
    "return_type": "bool",
    "comment": "Sets a client's mute state",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "muteState",
          "description": "True to mute client, false to unmute."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if this caused a change in mute state, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "muteState",
        "type": "bool",
        "default": null,
        "description": "True to mute client, false to unmute."
      }
    ],
    "full_declaration": "native bool BaseComm_SetClientMute(int client, bool muteState);"
  },
  {
    "name": "BfWriteBool",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "void",
    "comment": "Writes a single bit to a writable bitbuffer (bf_write).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_write handle to write to."
        },
        {
          "name": "bit",
          "description": "Bit to write (true for 1, false for 0)."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_write handle to write to."
      },
      {
        "name": "bit",
        "type": "bool",
        "default": null,
        "description": "Bit to write (true for 1, false for 0)."
      }
    ],
    "full_declaration": "native void BfWriteBool(Handle bf, bool bit);"
  },
  {
    "name": "BfWriteByte",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "void",
    "comment": "Writes a byte to a writable bitbuffer (bf_write).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_write handle to write to."
        },
        {
          "name": "byte",
          "description": "Byte to write (value will be written as 8bit)."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_write handle to write to."
      },
      {
        "name": "byte",
        "type": "int",
        "default": null,
        "description": "Byte to write (value will be written as 8bit)."
      }
    ],
    "full_declaration": "native void BfWriteByte(Handle bf, int byte);"
  },
  {
    "name": "BfWriteChar",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "void",
    "comment": "Writes a byte to a writable bitbuffer (bf_write).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_write handle to write to."
        },
        {
          "name": "chr",
          "description": "Character to write."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_write handle to write to."
      },
      {
        "name": "chr",
        "type": "int",
        "default": null,
        "description": "Character to write."
      }
    ],
    "full_declaration": "native void BfWriteChar(Handle bf, int chr);"
  },
  {
    "name": "BfWriteShort",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "void",
    "comment": "Writes a 16bit integer to a writable bitbuffer (bf_write).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_write handle to write to."
        },
        {
          "name": "num",
          "description": "Integer to write (value will be written as 16bit)."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_write handle to write to."
      },
      {
        "name": "num",
        "type": "int",
        "default": null,
        "description": "Integer to write (value will be written as 16bit)."
      }
    ],
    "full_declaration": "native void BfWriteShort(Handle bf, int num);"
  },
  {
    "name": "BfWriteWord",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "void",
    "comment": "Writes a 16bit unsigned integer to a writable bitbuffer (bf_write).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_write handle to write to."
        },
        {
          "name": "num",
          "description": "Integer to write (value will be written as 16bit)."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_write handle to write to."
      },
      {
        "name": "num",
        "type": "int",
        "default": null,
        "description": "Integer to write (value will be written as 16bit)."
      }
    ],
    "full_declaration": "native void BfWriteWord(Handle bf, int num);"
  },
  {
    "name": "BfWriteNum",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "void",
    "comment": "Writes a normal integer to a writable bitbuffer (bf_write).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_write handle to write to."
        },
        {
          "name": "num",
          "description": "Integer to write (value will be written as 32bit)."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_write handle to write to."
      },
      {
        "name": "num",
        "type": "int",
        "default": null,
        "description": "Integer to write (value will be written as 32bit)."
      }
    ],
    "full_declaration": "native void BfWriteNum(Handle bf, int num);"
  },
  {
    "name": "BfWriteFloat",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "void",
    "comment": "Writes a floating point number to a writable bitbuffer (bf_write).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_write handle to write to."
        },
        {
          "name": "num",
          "description": "Number to write."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_write handle to write to."
      },
      {
        "name": "num",
        "type": "float",
        "default": null,
        "description": "Number to write."
      }
    ],
    "full_declaration": "native void BfWriteFloat(Handle bf, float num);"
  },
  {
    "name": "BfWriteString",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "void",
    "comment": "Writes a string to a writable bitbuffer (bf_write).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_write handle to write to."
        },
        {
          "name": "string",
          "description": "Text string to write."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_write handle to write to."
      },
      {
        "name": "string",
        "type": "char[]",
        "default": null,
        "description": "Text string to write."
      }
    ],
    "full_declaration": "native void BfWriteString(Handle bf, const char[] string);"
  },
  {
    "name": "BfWriteEntity",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "void",
    "comment": "Writes an entity to a writable bitbuffer (bf_write).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_write handle to write to."
        },
        {
          "name": "ent",
          "description": "Entity index to write."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, or invalid entity."
      ],
      "note": [
        "This is a wrapper around BfWriteShort()."
      ],
      "return": ""
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_write handle to write to."
      },
      {
        "name": "ent",
        "type": "int",
        "default": null,
        "description": "Entity index to write."
      }
    ],
    "full_declaration": "native void BfWriteEntity(Handle bf, int ent);"
  },
  {
    "name": "BfWriteAngle",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "void",
    "comment": "Writes a bit angle to a writable bitbuffer (bf_write).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_write handle to write to."
        },
        {
          "name": "angle",
          "description": "Angle to write."
        },
        {
          "name": "numBits",
          "description": "Optional number of bits to use."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_write handle to write to."
      },
      {
        "name": "angle",
        "type": "float",
        "default": null,
        "description": "Angle to write."
      },
      {
        "name": "numBits",
        "type": "int",
        "default": "",
        "description": "Optional number of bits to use."
      }
    ],
    "full_declaration": "native void BfWriteAngle(Handle bf, float angle, int numBits=8);"
  },
  {
    "name": "BfWriteCoord",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "void",
    "comment": "Writes a coordinate to a writable bitbuffer (bf_write).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_write handle to write to."
        },
        {
          "name": "coord",
          "description": "Coordinate to write."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_write handle to write to."
      },
      {
        "name": "coord",
        "type": "float",
        "default": null,
        "description": "Coordinate to write."
      }
    ],
    "full_declaration": "native void BfWriteCoord(Handle bf, float coord);"
  },
  {
    "name": "BfWriteVecCoord",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "void",
    "comment": "Writes a 3D vector of coordinates to a writable bitbuffer (bf_write).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_write handle to write to."
        },
        {
          "name": "coord",
          "description": "Coordinate array to write."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_write handle to write to."
      },
      {
        "name": "coord",
        "type": "float",
        "default": null,
        "description": "Coordinate array to write."
      }
    ],
    "full_declaration": "native void BfWriteVecCoord(Handle bf, float coord[3]);"
  },
  {
    "name": "BfWriteVecNormal",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "void",
    "comment": "Writes a 3D normal vector to a writable bitbuffer (bf_write).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_write handle to write to."
        },
        {
          "name": "vec",
          "description": "Vector to write."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_write handle to write to."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Vector to write."
      }
    ],
    "full_declaration": "native void BfWriteVecNormal(Handle bf, float vec[3]);"
  },
  {
    "name": "BfWriteAngles",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "void",
    "comment": "Writes a 3D angle vector to a writable bitbuffer (bf_write).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_write handle to write to."
        },
        {
          "name": "angles",
          "description": "Angle vector to write."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_write handle to write to."
      },
      {
        "name": "angles",
        "type": "float",
        "default": null,
        "description": "Angle vector to write."
      }
    ],
    "full_declaration": "native void BfWriteAngles(Handle bf, float angles[3]);"
  },
  {
    "name": "BfReadBool",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "bool",
    "comment": "Reads a single bit from a readable bitbuffer (bf_read).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_read handle to read from."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": "Bit value read."
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_read handle to read from."
      }
    ],
    "full_declaration": "native bool BfReadBool(Handle bf);"
  },
  {
    "name": "BfReadByte",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "int",
    "comment": "Reads a byte from a readable bitbuffer (bf_read).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_read handle to read from."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": "Byte value read (read as 8bit)."
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_read handle to read from."
      }
    ],
    "full_declaration": "native int BfReadByte(Handle bf);"
  },
  {
    "name": "BfReadChar",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "int",
    "comment": "Reads a character from a readable bitbuffer (bf_read).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_read handle to read from."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": "Character value read."
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_read handle to read from."
      }
    ],
    "full_declaration": "native int BfReadChar(Handle bf);"
  },
  {
    "name": "BfReadShort",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "int",
    "comment": "Reads a 16bit integer from a readable bitbuffer (bf_read).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_read handle to read from."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": "Integer value read (read as 16bit)."
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_read handle to read from."
      }
    ],
    "full_declaration": "native int BfReadShort(Handle bf);"
  },
  {
    "name": "BfReadWord",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "int",
    "comment": "Reads a 16bit unsigned integer from a readable bitbuffer (bf_read).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_read handle to read from."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": "Integer value read (read as 16bit)."
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_read handle to read from."
      }
    ],
    "full_declaration": "native int BfReadWord(Handle bf);"
  },
  {
    "name": "BfReadNum",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "int",
    "comment": "Reads a normal integer to a readable bitbuffer (bf_read).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_read handle to read from."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": "Integer value read (read as 32bit)."
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_read handle to read from."
      }
    ],
    "full_declaration": "native int BfReadNum(Handle bf);"
  },
  {
    "name": "BfReadFloat",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "float",
    "comment": "Reads a floating point number from a readable bitbuffer (bf_read).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_read handle to read from."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": "Floating point value read."
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_read handle to read from."
      }
    ],
    "full_declaration": "native float BfReadFloat(Handle bf);"
  },
  {
    "name": "BfReadString",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "int",
    "comment": "Reads a string from a readable bitbuffer (bf_read).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_read handle to read from."
        },
        {
          "name": "buffer",
          "description": "Destination string buffer."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of output string buffer."
        },
        {
          "name": "line",
          "description": "If true the buffer will be copied until it reaches a '\\n' or a null terminator."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": "Number of bytes written to the buffer.  If the bitbuffer stream overflowed, that is, had no terminator before the end of the stream, then a negative number will be returned equal to the number of characters written to the buffer minus 1.  The buffer will be null terminated regardless of the return value."
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_read handle to read from."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Destination string buffer."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of output string buffer."
      },
      {
        "name": "line",
        "type": "bool",
        "default": "",
        "description": "If true the buffer will be copied until it reaches a '\\n' or a null terminator."
      }
    ],
    "full_declaration": "native int BfReadString(Handle bf, char[] buffer, int maxlength, bool line=false);"
  },
  {
    "name": "BfReadEntity",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "int",
    "comment": "Reads an entity from a readable bitbuffer (bf_read).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_read handle to read from."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [
        "This is a wrapper around BfReadShort()."
      ],
      "return": "Entity index read."
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_read handle to read from."
      }
    ],
    "full_declaration": "native int BfReadEntity(Handle bf);"
  },
  {
    "name": "BfReadAngle",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "float",
    "comment": "Reads a bit angle from a readable bitbuffer (bf_read).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_read handle to read from."
        },
        {
          "name": "numBits",
          "description": "Optional number of bits to use."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": "Angle read."
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_read handle to read from."
      },
      {
        "name": "numBits",
        "type": "int",
        "default": "",
        "description": "Optional number of bits to use."
      }
    ],
    "full_declaration": "native float BfReadAngle(Handle bf, int numBits=8);"
  },
  {
    "name": "BfReadCoord",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "float",
    "comment": "Reads a coordinate from a readable bitbuffer (bf_read).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_read handle to read from."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": "Coordinate read."
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_read handle to read from."
      }
    ],
    "full_declaration": "native float BfReadCoord(Handle bf);"
  },
  {
    "name": "BfReadVecCoord",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "void",
    "comment": "Reads a 3D vector of coordinates from a readable bitbuffer (bf_read).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_read handle to read from."
        },
        {
          "name": "coord",
          "description": "Destination coordinate array."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_read handle to read from."
      },
      {
        "name": "coord",
        "type": "float",
        "default": null,
        "description": "Destination coordinate array."
      }
    ],
    "full_declaration": "native void BfReadVecCoord(Handle bf, float coord[3]);"
  },
  {
    "name": "BfReadVecNormal",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "void",
    "comment": "Reads a 3D normal vector from a readable bitbuffer (bf_read).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_read handle to read from."
        },
        {
          "name": "vec",
          "description": "Destination vector array."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_read handle to read from."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Destination vector array."
      }
    ],
    "full_declaration": "native void BfReadVecNormal(Handle bf, float vec[3]);"
  },
  {
    "name": "BfReadAngles",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "void",
    "comment": "Reads a 3D angle vector from a readable bitbuffer (bf_read).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_read handle to read from."
        },
        {
          "name": "angles",
          "description": "Destination angle vector."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_read handle to read from."
      },
      {
        "name": "angles",
        "type": "float",
        "default": null,
        "description": "Destination angle vector."
      }
    ],
    "full_declaration": "native void BfReadAngles(Handle bf, float angles[3]);"
  },
  {
    "name": "BfGetNumBytesLeft",
    "type": "native",
    "source_file": "bitbuffer.inc",
    "return_type": "int",
    "comment": "Returns the number of bytes left in a readable bitbuffer (bf_read).",
    "tags": {
      "param": [
        {
          "name": "bf",
          "description": "bf_read handle to read from."
        }
      ],
      "error": [
        "Invalid or incorrect Handle."
      ],
      "note": [],
      "return": "Number of bytes left unread."
    },
    "params": [
      {
        "name": "bf",
        "type": "Handle",
        "default": null,
        "description": "bf_read handle to read from."
      }
    ],
    "full_declaration": "native int BfGetNumBytesLeft(Handle bf);"
  },
  {
    "name": "Cookie",
    "type": "methodmap",
    "source_file": "clientprefs.inc",
    "inherits": "Handle",
    "comment": "Note:\n\nA successful return value/result on any client prefs native only guarantees that the local cache has been updated.\nDatabase connection problems can still prevent the data from being permanently saved. Connection problems will be logged as\nerrors by the clientprefs extension.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "methods": [],
    "properties": [],
    "full_declaration": "methodmap Cookie < Handle"
  },
  {
    "name": "RegClientCookie",
    "type": "native",
    "source_file": "clientprefs.inc",
    "return_type": "Cookie",
    "comment": "Creates a new Client preference cookie.\n\nHandles returned by RegClientCookie can be closed via CloseHandle() when\nno longer needed.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Name of the new preference cookie."
        },
        {
          "name": "description",
          "description": "Optional description of the preference cookie."
        },
        {
          "name": "access",
          "description": "What CookieAccess level to assign to this cookie."
        }
      ],
      "error": [
        "Cookie name is blank."
      ],
      "note": [],
      "return": "A handle to the newly created cookie. If the cookie already exists, a handle to it will still be returned."
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Name of the new preference cookie."
      },
      {
        "name": "description",
        "type": "char[]",
        "default": null,
        "description": "Optional description of the preference cookie."
      },
      {
        "name": "access",
        "type": "CookieAccess",
        "default": null,
        "description": "What CookieAccess level to assign to this cookie."
      }
    ],
    "full_declaration": "native Cookie RegClientCookie(const char[] name, const char[] description, CookieAccess access);"
  },
  {
    "name": "FindClientCookie",
    "type": "native",
    "source_file": "clientprefs.inc",
    "return_type": "Cookie",
    "comment": "Searches for a Client preference cookie.\n\nHandles returned by FindClientCookie can be closed via CloseHandle() when\nno longer needed.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Name of cookie to find."
        }
      ],
      "error": [],
      "note": [],
      "return": "A handle to the cookie if it is found, null otherwise."
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Name of cookie to find."
      }
    ],
    "full_declaration": "native Cookie FindClientCookie(const char[] name);"
  },
  {
    "name": "SetClientCookie",
    "type": "native",
    "source_file": "clientprefs.inc",
    "return_type": "void",
    "comment": "Set the value of a Client preference cookie.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "cookie",
          "description": "Client preference cookie handle."
        },
        {
          "name": "value",
          "description": "String value to set."
        }
      ],
      "error": [
        "Invalid cookie handle or invalid client index."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "cookie",
        "type": "Handle",
        "default": null,
        "description": "Client preference cookie handle."
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "String value to set."
      }
    ],
    "full_declaration": "native void SetClientCookie(int client, Handle cookie, const char[] value);"
  },
  {
    "name": "GetClientCookie",
    "type": "native",
    "source_file": "clientprefs.inc",
    "return_type": "void",
    "comment": "Retrieve the value of a Client preference cookie.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "cookie",
          "description": "Client preference cookie handle."
        },
        {
          "name": "buffer",
          "description": "Copyback buffer for value."
        },
        {
          "name": "maxlen",
          "description": "Maximum length of the buffer."
        }
      ],
      "error": [
        "Invalid cookie handle or invalid client index."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "cookie",
        "type": "Handle",
        "default": null,
        "description": "Client preference cookie handle."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Copyback buffer for value."
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "Maximum length of the buffer."
      }
    ],
    "full_declaration": "native void GetClientCookie(int client, Handle cookie, char[] buffer, int maxlen);"
  },
  {
    "name": "SetAuthIdCookie",
    "type": "native",
    "source_file": "clientprefs.inc",
    "return_type": "void",
    "comment": "Sets the value of a Client preference cookie based on an authID string.",
    "tags": {
      "param": [
        {
          "name": "authID",
          "description": "String Auth/STEAM ID of player to set."
        },
        {
          "name": "cookie",
          "description": "Client preference cookie handle."
        },
        {
          "name": "value",
          "description": "String value to set."
        }
      ],
      "error": [
        "Invalid cookie handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "authID",
        "type": "char[]",
        "default": null,
        "description": "String Auth/STEAM ID of player to set."
      },
      {
        "name": "cookie",
        "type": "Handle",
        "default": null,
        "description": "Client preference cookie handle."
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "String value to set."
      }
    ],
    "full_declaration": "native void SetAuthIdCookie(const char[] authID, Handle cookie, const char[] value);"
  },
  {
    "name": "AreClientCookiesCached",
    "type": "native",
    "source_file": "clientprefs.inc",
    "return_type": "bool",
    "comment": "Checks if a clients cookies have been loaded from the database.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        }
      ],
      "error": [
        "Invalid client index."
      ],
      "note": [],
      "return": "True if loaded, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      }
    ],
    "full_declaration": "native bool AreClientCookiesCached(int client);"
  },
  {
    "name": "OnClientCookiesCached",
    "type": "forward",
    "source_file": "clientprefs.inc",
    "return_type": "void",
    "comment": "Called once a client's saved cookies have been loaded from the database.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      }
    ],
    "full_declaration": "forward void OnClientCookiesCached(int client);"
  },
  {
    "name": "SetCookiePrefabMenu",
    "type": "native",
    "source_file": "clientprefs.inc",
    "return_type": "void",
    "comment": "Add a new prefab item to the client cookie settings menu.\n\nNote: This handles everything automatically and does not require a callback",
    "tags": {
      "param": [
        {
          "name": "cookie",
          "description": "Client preference cookie handle."
        },
        {
          "name": "type",
          "description": "A CookieMenu prefab menu type."
        },
        {
          "name": "display",
          "description": "Text to show on the menu."
        },
        {
          "name": "handler",
          "description": "Optional handler callback for translations and output on selection"
        },
        {
          "name": "info",
          "description": "Info data to pass to the callback."
        }
      ],
      "error": [
        "Invalid cookie handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "cookie",
        "type": "Handle",
        "default": null,
        "description": "Client preference cookie handle."
      },
      {
        "name": "type",
        "type": "CookieMenu",
        "default": null,
        "description": "A CookieMenu prefab menu type."
      },
      {
        "name": "display",
        "type": "char[]",
        "default": null,
        "description": "Text to show on the menu."
      },
      {
        "name": "handler",
        "type": "CookieMenuHandler",
        "default": "",
        "description": "Optional handler callback for translations and output on selection"
      },
      {
        "name": "info",
        "type": "any",
        "default": "",
        "description": "Info data to pass to the callback."
      }
    ],
    "full_declaration": "native void SetCookiePrefabMenu(Handle cookie, CookieMenu type, const char[] display, CookieMenuHandler handler=INVALID_FUNCTION, any info=0);"
  },
  {
    "name": "SetCookieMenuItem",
    "type": "native",
    "source_file": "clientprefs.inc",
    "return_type": "void",
    "comment": "Adds a new item to the client cookie settings menu.\n\nNote: This only adds the top level menu item. You need to handle any submenus from the callback.",
    "tags": {
      "param": [
        {
          "name": "handler",
          "description": "A MenuHandler callback function."
        },
        {
          "name": "info",
          "description": "Data to pass to the callback."
        },
        {
          "name": "display",
          "description": "Text to show on the menu."
        }
      ],
      "error": [
        "Invalid cookie handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "handler",
        "type": "CookieMenuHandler",
        "default": null,
        "description": "A MenuHandler callback function."
      },
      {
        "name": "info",
        "type": "any",
        "default": null,
        "description": "Data to pass to the callback."
      },
      {
        "name": "display",
        "type": "char[]",
        "default": null,
        "description": "Text to show on the menu."
      }
    ],
    "full_declaration": "native void SetCookieMenuItem(CookieMenuHandler handler, any info, const char[] display);"
  },
  {
    "name": "ShowCookieMenu",
    "type": "native",
    "source_file": "clientprefs.inc",
    "return_type": "void",
    "comment": "Displays the settings menu to a client.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      }
    ],
    "full_declaration": "native void ShowCookieMenu(int client);"
  },
  {
    "name": "GetCookieIterator",
    "type": "native",
    "source_file": "clientprefs.inc",
    "return_type": "Handle",
    "comment": "Gets a cookie iterator.  Must be freed with CloseHandle().",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "A new cookie iterator."
    },
    "params": [],
    "full_declaration": "native Handle GetCookieIterator();"
  },
  {
    "name": "ReadCookieIterator",
    "type": "native",
    "source_file": "clientprefs.inc",
    "return_type": "bool",
    "comment": "Reads a cookie iterator, then advances to the next cookie if any.",
    "tags": {
      "param": [
        {
          "name": "iter",
          "description": "Cookie iterator Handle."
        },
        {
          "name": "name",
          "description": "Name buffer."
        },
        {
          "name": "nameLen",
          "description": "Name buffer size."
        },
        {
          "name": "access",
          "description": "Access level of the cookie."
        },
        {
          "name": "desc",
          "description": "Cookie description buffer."
        },
        {
          "name": "descLen",
          "description": "Cookie description buffer size."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false if there are no more commands."
    },
    "params": [
      {
        "name": "iter",
        "type": "Handle",
        "default": null,
        "description": "Cookie iterator Handle."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Name buffer."
      },
      {
        "name": "nameLen",
        "type": "int",
        "default": null,
        "description": "Name buffer size."
      },
      {
        "name": "access",
        "type": "CookieAccess",
        "default": null,
        "description": "Access level of the cookie."
      },
      {
        "name": "desc",
        "type": "char[]",
        "default": "",
        "description": "Cookie description buffer."
      },
      {
        "name": "descLen",
        "type": "int",
        "default": "",
        "description": "Cookie description buffer size."
      }
    ],
    "full_declaration": "native bool ReadCookieIterator(Handle iter,  \t\t\t\t\t\t\t\tchar[] name,  \t\t\t\t\t\t\t\tint nameLen, \t\t\t\t\t\t\t\tCookieAccess &access,  \t\t\t\t\t\t\t\tchar[] desc=\"\",  \t\t\t\t\t\t\t\tint descLen=0);"
  },
  {
    "name": "GetCookieAccess",
    "type": "native",
    "source_file": "clientprefs.inc",
    "return_type": "CookieAccess",
    "comment": "Returns the access level of a cookie",
    "tags": {
      "param": [
        {
          "name": "cookie",
          "description": "Client preference cookie handle."
        }
      ],
      "error": [
        "Invalid cookie handle."
      ],
      "note": [],
      "return": "CookieAccess access level."
    },
    "params": [
      {
        "name": "cookie",
        "type": "Handle",
        "default": null,
        "description": "Client preference cookie handle."
      }
    ],
    "full_declaration": "native CookieAccess GetCookieAccess(Handle cookie);"
  },
  {
    "name": "GetClientCookieTime",
    "type": "native",
    "source_file": "clientprefs.inc",
    "return_type": "int",
    "comment": "Returns the last updated timestamp for a client cookie",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "cookie",
          "description": "Cookie handle."
        }
      ],
      "error": [],
      "note": [],
      "return": "Last updated timestamp."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "cookie",
        "type": "Handle",
        "default": null,
        "description": "Cookie handle."
      }
    ],
    "full_declaration": "native int GetClientCookieTime(int client, Handle cookie);"
  },
  {
    "name": "__ext_cprefs_SetNTVOptional",
    "type": "public",
    "source_file": "clientprefs.inc",
    "return_type": "void",
    "comment": "Do not edit below this line!",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [],
    "full_declaration": "public void __ext_cprefs_SetNTVOptional() { \tMarkNativeAsOptional(\"RegClientCookie\");"
  },
  {
    "name": "OnClientConnect",
    "type": "forward",
    "source_file": "clients.inc",
    "return_type": "bool",
    "comment": "Called on client connection.  If you return true, the client will be allowed in the server.\nIf you return false (or return nothing), the client will be rejected.  If the client is\nrejected by this forward or any other, OnClientDisconnect will not be called.\n\nNote: Do not write to rejectmsg if you plan on returning true.  If multiple plugins write\nto the string buffer, it is not defined which plugin's string will be shown to the client,\nbut it is guaranteed one of them will.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "rejectmsg",
          "description": "Buffer to store the rejection message when the connection is refused."
        },
        {
          "name": "maxlen",
          "description": "Maximum number of characters for rejection buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "True to validate client's connection, false to refuse it."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "rejectmsg",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the rejection message when the connection is refused."
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "Maximum number of characters for rejection buffer."
      }
    ],
    "full_declaration": "forward bool OnClientConnect(int client, char[] rejectmsg, int maxlen);"
  },
  {
    "name": "OnClientConnected",
    "type": "forward",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Called once a client successfully connects.  This callback is paired with OnClientDisconnect.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      }
    ],
    "full_declaration": "forward void OnClientConnected(int client);"
  },
  {
    "name": "OnClientPutInServer",
    "type": "forward",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Called when a client is entering the game.\n\nWhether a client has a steamid is undefined until OnClientAuthorized\nis called, which may occur either before or after OnClientPutInServer.\nSimilarly, use OnClientPostAdminCheck() if you need to verify whether\nconnecting players are admins.\n\nGetClientCount() will include clients as they are passed through this\nfunction, as clients are already in game at this point.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      }
    ],
    "full_declaration": "forward void OnClientPutInServer(int client);"
  },
  {
    "name": "OnClientDisconnect",
    "type": "forward",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Called when a client is disconnecting from the server.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      }
    ],
    "full_declaration": "forward void OnClientDisconnect(int client);"
  },
  {
    "name": "OnClientDisconnect_Post",
    "type": "forward",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Called when a client is disconnected from the server.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      }
    ],
    "full_declaration": "forward void OnClientDisconnect_Post(int client);"
  },
  {
    "name": "OnClientCommand",
    "type": "forward",
    "source_file": "clients.inc",
    "return_type": "Action",
    "comment": "Called when a client is sending a command.\n\nAs of SourceMod 1.3, the client is guaranteed to be in-game.\nUse command listeners (console.inc) for more advanced hooks.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "args",
          "description": "Number of arguments."
        }
      ],
      "error": [],
      "note": [],
      "return": "Plugin_Handled blocks the command from being sent, and Plugin_Continue resumes normal functionality."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "args",
        "type": "int",
        "default": null,
        "description": "Number of arguments."
      }
    ],
    "full_declaration": "forward Action OnClientCommand(int client, int args);"
  },
  {
    "name": "OnClientCommandKeyValues",
    "type": "forward",
    "source_file": "clients.inc",
    "return_type": "Action",
    "comment": "Called when a client is sending a KeyValues command.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "kv",
          "description": "Editable KeyValues data to be sent as the command. (This handle should not be stored and will be closed after this forward completes.)"
        }
      ],
      "error": [],
      "note": [],
      "return": "Plugin_Handled blocks the command from being sent, and Plugin_Continue resumes normal functionality."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "kv",
        "type": "KeyValues",
        "default": null,
        "description": "Editable KeyValues data to be sent as the command. (This handle should not be stored and will be closed after this forward completes.)"
      }
    ],
    "full_declaration": "forward Action OnClientCommandKeyValues(int client, KeyValues kv);"
  },
  {
    "name": "OnClientCommandKeyValues_Post",
    "type": "forward",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Called after a client has sent a KeyValues command.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "kv",
          "description": "KeyValues data sent as the command. (This handle should not be stored and will be closed after this forward completes.)"
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "kv",
        "type": "KeyValues",
        "default": null,
        "description": "KeyValues data sent as the command. (This handle should not be stored and will be closed after this forward completes.)"
      }
    ],
    "full_declaration": "forward void OnClientCommandKeyValues_Post(int client, KeyValues kv);"
  },
  {
    "name": "OnClientSettingsChanged",
    "type": "forward",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Called whenever the client's settings are changed.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      }
    ],
    "full_declaration": "forward void OnClientSettingsChanged(int client);"
  },
  {
    "name": "OnClientAuthorized",
    "type": "forward",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Called when a client receives an auth ID.  The state of a client's\nauthorization as an admin is not guaranteed here.  Use\nOnClientPostAdminCheck() if you need a client's admin status.\n\nThis is called by bots, but the ID will be \"BOT\".",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "auth",
          "description": "Client Steam2 id, if available, else engine auth id."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "auth",
        "type": "char[]",
        "default": null,
        "description": "Client Steam2 id, if available, else engine auth id."
      }
    ],
    "full_declaration": "forward void OnClientAuthorized(int client, const char[] auth);"
  },
  {
    "name": "OnClientPreAdminCheck",
    "type": "forward",
    "source_file": "clients.inc",
    "return_type": "Action",
    "comment": "Called once a client is authorized and fully in-game, but\nbefore admin checks are done.  This can be used to override\nthe default admin checks for a client.  You should only use\nthis for overriding; use OnClientPostAdminCheck() instead\nif you want notification.\n\nNote: If handled/blocked, PostAdminCheck must be signalled\nmanually via NotifyPostAdminCheck().\n\nThis callback is guaranteed to occur on all clients, and always\nafter each OnClientPutInServer() call.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        }
      ],
      "error": [],
      "note": [],
      "return": "Plugin_Handled to block admin checks."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      }
    ],
    "full_declaration": "forward Action OnClientPreAdminCheck(int client);"
  },
  {
    "name": "OnClientPostAdminFilter",
    "type": "forward",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Called directly before OnClientPostAdminCheck() as a method to\nalter administrative permissions before plugins perform final\npost-connect operations.\n\nIn general, do not use this function unless you are specifically\nattempting to change access permissions.  Use OnClientPostAdminCheck()\ninstead if you simply want to perform post-connect authorization\nroutines.\n\nSee OnClientPostAdminCheck() for more information.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      }
    ],
    "full_declaration": "forward void OnClientPostAdminFilter(int client);"
  },
  {
    "name": "OnServerEnterHibernation",
    "type": "forward",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Called directly before the server enters hibernation.\nThis is your last chance to do anything in the plugin before\nhibernation occurs, as SV_Frame will no longer be called.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [],
    "full_declaration": "forward void OnServerEnterHibernation();"
  },
  {
    "name": "OnServerExitHibernation",
    "type": "forward",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Called directly before the server leaves hibernation.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [],
    "full_declaration": "forward void OnServerExitHibernation();"
  },
  {
    "name": "OnClientPostAdminCheck",
    "type": "forward",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Called once a client is authorized and fully in-game, and\nafter all post-connection authorizations have been performed.\n\nThis callback is guaranteed to occur on all clients, and always\nafter each OnClientPutInServer() call.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      }
    ],
    "full_declaration": "forward void OnClientPostAdminCheck(int client);"
  },
  {
    "name": "OnClientLanguageChanged",
    "type": "forward",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Called when the language was received from the player.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "language",
          "description": "Language number."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "language",
        "type": "int",
        "default": null,
        "description": "Language number."
      }
    ],
    "full_declaration": "forward void OnClientLanguageChanged(int client, int language);"
  },
  {
    "name": "GetMaxClients",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "int",
    "comment": "This function is deprecated. Use the MaxClients variable instead.\n\nReturns the maximum number of clients allowed on the server.  This may\nreturn 0 if called before OnMapStart(), and thus should not be called\nin OnPluginStart().\n\nYou should not globally cache the value to GetMaxClients() because it can change from\nSourceTV or TF2's arena mode.  Use the \"MaxClients\" dynamic variable documented at the\ntop of this file.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "Maximum number of clients allowed.",
      "deprecated": [
        "Use MaxClients variable instead."
      ]
    },
    "params": [],
    "full_declaration": "native int GetMaxClients();"
  },
  {
    "name": "GetMaxHumanPlayers",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "int",
    "comment": "Returns the maximum number of human players allowed on the server.  This is\na game-specific function used on newer games to limit the number of humans\nthat can join a game and can be lower than MaxClients. It is the number often\nreflected in the server browser or when viewing the output of the status command.\nOn unsupported games or modes without overrides, it will return the same value\nas MaxClients.\n\nYou should not globally cache the value to GetMaxHumanPlayers() because it can change across\ngame modes. You may still cache it locally.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "Maximum number of humans allowed."
    },
    "params": [],
    "full_declaration": "native int GetMaxHumanPlayers();"
  },
  {
    "name": "GetClientCount",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "int",
    "comment": "Returns the client count put in the server.",
    "tags": {
      "param": [
        {
          "name": "inGameOnly",
          "description": "If false connecting players are also counted."
        }
      ],
      "error": [],
      "note": [],
      "return": "Client count in the server."
    },
    "params": [
      {
        "name": "inGameOnly",
        "type": "bool",
        "default": "",
        "description": "If false connecting players are also counted."
      }
    ],
    "full_declaration": "native int GetClientCount(bool inGameOnly=true);"
  },
  {
    "name": "GetClientName",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "bool",
    "comment": "Returns the client's name.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player index."
        },
        {
          "name": "name",
          "description": "Buffer to store the client's name."
        },
        {
          "name": "maxlen",
          "description": "Maximum length of string buffer (includes NULL terminator)."
        }
      ],
      "error": [
        "If the client is not connected an error will be thrown."
      ],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player index."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the client's name."
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "Maximum length of string buffer (includes NULL terminator)."
      }
    ],
    "full_declaration": "native bool GetClientName(int client, char[] name, int maxlen);"
  },
  {
    "name": "GetClientIP",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "bool",
    "comment": "Retrieves a client's IP address.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player index."
        },
        {
          "name": "ip",
          "description": "Buffer to store the client's ip address."
        },
        {
          "name": "maxlen",
          "description": "Maximum length of string buffer (includes NULL terminator)."
        },
        {
          "name": "remport",
          "description": "Remove client's port from the ip string (true by default)."
        }
      ],
      "error": [
        "If the client is not connected or the index is invalid."
      ],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player index."
      },
      {
        "name": "ip",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the client's ip address."
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "Maximum length of string buffer (includes NULL terminator)."
      },
      {
        "name": "remport",
        "type": "bool",
        "default": "",
        "description": "Remove client's port from the ip string (true by default)."
      }
    ],
    "full_declaration": "native bool GetClientIP(int client, char[] ip, int maxlen, bool remport=true);"
  },
  {
    "name": "GetClientAuthString",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "bool",
    "comment": "Retrieves a client's authentication string (SteamID).",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player index."
        },
        {
          "name": "auth",
          "description": "Buffer to store the client's auth string."
        },
        {
          "name": "maxlen",
          "description": "Maximum length of string buffer (includes NULL terminator)."
        },
        {
          "name": "validate",
          "description": "Check backend validation status. DO NOT PASS FALSE UNLESS YOU UNDERSTAND THE CONSEQUENCES, You WILL KNOW if you need to use this, MOST WILL NOT."
        }
      ],
      "error": [
        "If the client is not connected or the index is invalid."
      ],
      "note": [],
      "return": "True on success, false otherwise.",
      "deprecated": [
        "Use GetClientAuthId"
      ]
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player index."
      },
      {
        "name": "auth",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the client's auth string."
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "Maximum length of string buffer (includes NULL terminator)."
      },
      {
        "name": "validate",
        "type": "bool",
        "default": "",
        "description": "Check backend validation status. DO NOT PASS FALSE UNLESS YOU UNDERSTAND THE CONSEQUENCES, You WILL KNOW if you need to use this, MOST WILL NOT."
      }
    ],
    "full_declaration": "native bool GetClientAuthString(int client, char[] auth, int maxlen, bool validate=true);"
  },
  {
    "name": "GetClientAuthId",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "bool",
    "comment": "Retrieves a client's authentication string (SteamID).",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player index."
        },
        {
          "name": "authType",
          "description": "Auth id type and format to use."
        },
        {
          "name": "auth",
          "description": "Buffer to store the client's auth id."
        },
        {
          "name": "maxlen",
          "description": "Maximum length of string buffer (includes NULL terminator)."
        },
        {
          "name": "validate",
          "description": "Check backend validation status. DO NOT PASS FALSE UNLESS YOU UNDERSTAND THE CONSEQUENCES, You WILL KNOW if you need to use this, MOST WILL NOT."
        }
      ],
      "error": [
        "If the client is not connected or the index is invalid."
      ],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player index."
      },
      {
        "name": "authType",
        "type": "AuthIdType",
        "default": null,
        "description": "Auth id type and format to use."
      },
      {
        "name": "auth",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the client's auth id."
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "Maximum length of string buffer (includes NULL terminator)."
      },
      {
        "name": "validate",
        "type": "bool",
        "default": "",
        "description": "Check backend validation status. DO NOT PASS FALSE UNLESS YOU UNDERSTAND THE CONSEQUENCES, You WILL KNOW if you need to use this, MOST WILL NOT."
      }
    ],
    "full_declaration": "native bool GetClientAuthId(int client, AuthIdType authType, char[] auth, int maxlen, bool validate=true);"
  },
  {
    "name": "GetSteamAccountID",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "int",
    "comment": "Returns the client's Steam account ID, a number uniquely identifying a given Steam account.\nThis number is the basis for the various display SteamID forms, see the AuthIdType enum for examples.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client Index."
        },
        {
          "name": "validate",
          "description": "Check backend validation status. DO NOT PASS FALSE UNLESS YOU UNDERSTAND THE CONSEQUENCES, You WILL KNOW if you need to use this, MOST WILL NOT."
        }
      ],
      "error": [
        "If the client is not connected or the index is invalid."
      ],
      "note": [],
      "return": "Steam account ID or 0 if not available."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client Index."
      },
      {
        "name": "validate",
        "type": "bool",
        "default": "",
        "description": "Check backend validation status. DO NOT PASS FALSE UNLESS YOU UNDERSTAND THE CONSEQUENCES, You WILL KNOW if you need to use this, MOST WILL NOT."
      }
    ],
    "full_declaration": "native int GetSteamAccountID(int client, bool validate=true);"
  },
  {
    "name": "GetClientUserId",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "int",
    "comment": "Retrieves a client's user id, which is an index incremented for every client\nthat joins the server.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player index."
        }
      ],
      "error": [
        "If the client is not connected or the index is invalid."
      ],
      "note": [],
      "return": "User id of the client."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player index."
      }
    ],
    "full_declaration": "native int GetClientUserId(int client);"
  },
  {
    "name": "IsClientConnected",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "bool",
    "comment": "Returns if a certain player is connected.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player index."
        }
      ],
      "error": [
        "Invalid client index."
      ],
      "note": [],
      "return": "True if player is connected to the server, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player index."
      }
    ],
    "full_declaration": "native bool IsClientConnected(int client);"
  },
  {
    "name": "IsClientInGame",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "bool",
    "comment": "Returns if a certain player has entered the game.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player index (index does not have to be connected)."
        }
      ],
      "error": [
        "Invalid client index."
      ],
      "note": [],
      "return": "True if player has entered the game, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player index (index does not have to be connected)."
      }
    ],
    "full_declaration": "native bool IsClientInGame(int client);"
  },
  {
    "name": "IsClientInKickQueue",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "bool",
    "comment": "Returns if a client is in the \"kick queue\" (i.e. the client will be kicked\nshortly and thus they should not appear as valid).",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player index (must be connected)."
        }
      ],
      "error": [
        "Invalid client index."
      ],
      "note": [],
      "return": "True if in the kick queue, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player index (must be connected)."
      }
    ],
    "full_declaration": "native bool IsClientInKickQueue(int client);"
  },
  {
    "name": "IsPlayerInGame",
    "type": "stock",
    "source_file": "clients.inc",
    "return_type": "bool",
    "comment": "Backwards compatibility stock - use IsClientInGame",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "",
      "deprecated": [
        "Renamed to IsClientInGame"
      ]
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": ""
      }
    ],
    "full_declaration": "stock bool IsPlayerInGame(int client) { \treturn IsClientInGame(client);"
  },
  {
    "name": "IsClientAuthorized",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "bool",
    "comment": "Returns if a certain player has been authenticated.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player index."
        }
      ],
      "error": [
        "Invalid client index."
      ],
      "note": [],
      "return": "True if player has been authenticated, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player index."
      }
    ],
    "full_declaration": "native bool IsClientAuthorized(int client);"
  },
  {
    "name": "IsFakeClient",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "bool",
    "comment": "Returns if a certain player is a fake client.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player index."
        }
      ],
      "error": [
        "Invalid client index, or client not connected."
      ],
      "note": [],
      "return": "True if player is a fake client, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player index."
      }
    ],
    "full_declaration": "native bool IsFakeClient(int client);"
  },
  {
    "name": "IsClientSourceTV",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "bool",
    "comment": "Returns if a certain player is the SourceTV bot.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player index."
        }
      ],
      "error": [
        "Invalid client index, or client not connected."
      ],
      "note": [],
      "return": "True if player is the SourceTV bot, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player index."
      }
    ],
    "full_declaration": "native bool IsClientSourceTV(int client);"
  },
  {
    "name": "IsClientReplay",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "bool",
    "comment": "Returns if a certain player is the Replay bot.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player index."
        }
      ],
      "error": [
        "Invalid client index, or client not connected."
      ],
      "note": [],
      "return": "True if player is the Replay bot, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player index."
      }
    ],
    "full_declaration": "native bool IsClientReplay(int client);"
  },
  {
    "name": "IsClientObserver",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "bool",
    "comment": "Returns if a certain player is an observer/spectator.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player index."
        }
      ],
      "error": [
        "Invalid client index, client not in game, or no mod support."
      ],
      "note": [],
      "return": "True if player is an observer, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player index."
      }
    ],
    "full_declaration": "native bool IsClientObserver(int client);"
  },
  {
    "name": "IsPlayerAlive",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "bool",
    "comment": "Returns if the client is alive or dead.\n\nNote: This function was originally in SDKTools and was moved to core.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        }
      ],
      "error": [
        "Invalid client index, client not in game, or no mod support."
      ],
      "note": [],
      "return": "True if the client is alive, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      }
    ],
    "full_declaration": "native bool IsPlayerAlive(int client);"
  },
  {
    "name": "GetClientInfo",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "bool",
    "comment": "Retrieves values from client replicated keys.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        },
        {
          "name": "key",
          "description": "Key string."
        },
        {
          "name": "value",
          "description": "Buffer to store value."
        },
        {
          "name": "maxlen",
          "description": "Maximum length of valve (UTF-8 safe)."
        }
      ],
      "error": [
        "Invalid client index, or client not connected."
      ],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Key string."
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store value."
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "Maximum length of valve (UTF-8 safe)."
      }
    ],
    "full_declaration": "native bool GetClientInfo(int client, const char[] key, char[] value, int maxlen);"
  },
  {
    "name": "GetClientTeam",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "int",
    "comment": "Retrieves a client's team index.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        }
      ],
      "error": [
        "Invalid client index, client not in game, or no mod support."
      ],
      "note": [],
      "return": "Team index the client is on (mod specific)."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      }
    ],
    "full_declaration": "native int GetClientTeam(int client);"
  },
  {
    "name": "SetUserAdmin",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Sets a client's AdminId.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        },
        {
          "name": "id",
          "description": "AdminId to set.  INVALID_ADMIN_ID removes admin permissions."
        },
        {
          "name": "temp",
          "description": "True if the id should be freed on disconnect."
        }
      ],
      "error": [
        "Invalid client index, client not connected, or bogus AdminId."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      },
      {
        "name": "id",
        "type": "AdminId",
        "default": null,
        "description": "AdminId to set.  INVALID_ADMIN_ID removes admin permissions."
      },
      {
        "name": "temp",
        "type": "bool",
        "default": "",
        "description": "True if the id should be freed on disconnect."
      }
    ],
    "full_declaration": "native void SetUserAdmin(int client, AdminId id, bool temp=false);"
  },
  {
    "name": "GetUserAdmin",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "AdminId",
    "comment": "Retrieves a client's AdminId.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        }
      ],
      "error": [
        "Invalid client index, or client not connected."
      ],
      "note": [],
      "return": "AdminId of the client, or INVALID_ADMIN_ID if none."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      }
    ],
    "full_declaration": "native AdminId GetUserAdmin(int client);"
  },
  {
    "name": "AddUserFlags",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Sets access flags on a client.  If the client is not an admin,\na temporary, anonymous AdminId is given.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        }
      ],
      "error": [
        "Invalid client index, or client not connected."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      }
    ],
    "full_declaration": "native void AddUserFlags(int client, AdminFlag ...);"
  },
  {
    "name": "RemoveUserFlags",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Removes flags from a client.  If the client is not an admin,\nthis has no effect.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        }
      ],
      "error": [
        "Invalid client index, or client not connected."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      }
    ],
    "full_declaration": "native void RemoveUserFlags(int client, AdminFlag ...);"
  },
  {
    "name": "SetUserFlagBits",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Sets access flags on a client using bits instead of flags.  If the\nclient is not an admin, and flags not 0, a temporary, anonymous AdminId is given.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        },
        {
          "name": "flags",
          "description": "Bitstring of flags to set on client."
        }
      ],
      "error": [
        "Invalid client index, or client not connected."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "Bitstring of flags to set on client."
      }
    ],
    "full_declaration": "native void SetUserFlagBits(int client, int flags);"
  },
  {
    "name": "GetUserFlagBits",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "int",
    "comment": "Returns client access flags.  If the client is not an admin,\nthe result is always 0.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        }
      ],
      "error": [
        "Invalid client index, or client not connected."
      ],
      "note": [],
      "return": "Flags"
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      }
    ],
    "full_declaration": "native int GetUserFlagBits(int client);"
  },
  {
    "name": "CanUserTarget",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "bool",
    "comment": "Returns whether a user can target another user.\nThis is a helper function for CanAdminTarget.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        },
        {
          "name": "target",
          "description": "Target player's index."
        }
      ],
      "error": [
        "Invalid or unconnected player indexers."
      ],
      "note": [],
      "return": "True if target is targettable by the player, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      },
      {
        "name": "target",
        "type": "int",
        "default": null,
        "description": "Target player's index."
      }
    ],
    "full_declaration": "native bool CanUserTarget(int client, int target);"
  },
  {
    "name": "RunAdminCacheChecks",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "bool",
    "comment": "Runs through the Core-defined admin authorization checks on a player.\nHas no effect if the player is already an admin.\n\nNote: This function is based on the internal cache only.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        }
      ],
      "error": [
        "Invalid client index or client not in-game AND authorized."
      ],
      "note": [],
      "return": "True if access was changed, false if it did not."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      }
    ],
    "full_declaration": "native bool RunAdminCacheChecks(int client);"
  },
  {
    "name": "NotifyPostAdminCheck",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Signals that a player has completed post-connection admin checks.\nHas no effect if the player has already had this event signalled.\n\nNote: This must be sent even if no admin id was assigned.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        }
      ],
      "error": [
        "Invalid client index or client not in-game AND authorized."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      }
    ],
    "full_declaration": "native void NotifyPostAdminCheck(int client);"
  },
  {
    "name": "CreateFakeClient",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "int",
    "comment": "Creates a fake client.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Name to use."
        }
      ],
      "error": [
        "No map is active."
      ],
      "note": [],
      "return": "Client index on success, 0 otherwise."
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Name to use."
      }
    ],
    "full_declaration": "native int CreateFakeClient(const char[] name);"
  },
  {
    "name": "SetFakeClientConVar",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Sets a convar value on a fake client.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "cvar",
          "description": "ConVar name."
        },
        {
          "name": "value",
          "description": "ConVar value."
        }
      ],
      "error": [
        "Invalid client index, client not connected, or client not a fake client."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "cvar",
        "type": "char[]",
        "default": null,
        "description": "ConVar name."
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "ConVar value."
      }
    ],
    "full_declaration": "native void SetFakeClientConVar(int client, const char[] cvar, const char[] value);"
  },
  {
    "name": "GetClientHealth",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "int",
    "comment": "Returns the client's health.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        }
      ],
      "error": [
        "Invalid client index, client not in game, or no mod support."
      ],
      "note": [],
      "return": "Health value."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      }
    ],
    "full_declaration": "native int GetClientHealth(int client);"
  },
  {
    "name": "GetClientModel",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Returns the client's model name.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        },
        {
          "name": "model",
          "description": "Buffer to store the client's model name."
        },
        {
          "name": "maxlen",
          "description": "Maximum length of string buffer (includes NULL terminator)."
        }
      ],
      "error": [
        "Invalid client index, client not in game, or no mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      },
      {
        "name": "model",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the client's model name."
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "Maximum length of string buffer (includes NULL terminator)."
      }
    ],
    "full_declaration": "native void GetClientModel(int client, char[] model, int maxlen);"
  },
  {
    "name": "GetClientWeapon",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Returns the client's weapon name.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        },
        {
          "name": "weapon",
          "description": "Buffer to store the client's weapon name."
        },
        {
          "name": "maxlen",
          "description": "Maximum length of string buffer (includes NULL terminator)."
        }
      ],
      "error": [
        "Invalid client index, client not in game, or no mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      },
      {
        "name": "weapon",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the client's weapon name."
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "Maximum length of string buffer (includes NULL terminator)."
      }
    ],
    "full_declaration": "native void GetClientWeapon(int client, char[] weapon, int maxlen);"
  },
  {
    "name": "GetClientMaxs",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Returns the client's max size vector.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        },
        {
          "name": "vec",
          "description": "Destination vector to store the client's max size."
        }
      ],
      "error": [
        "Invalid client index, client not in game, or no mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Destination vector to store the client's max size."
      }
    ],
    "full_declaration": "native void GetClientMaxs(int client, float vec[3]);"
  },
  {
    "name": "GetClientMins",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Returns the client's min size vector.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        },
        {
          "name": "vec",
          "description": "Destination vector to store the client's min size."
        }
      ],
      "error": [
        "Invalid client index, client not in game, or no mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Destination vector to store the client's min size."
      }
    ],
    "full_declaration": "native void GetClientMins(int client, float vec[3]);"
  },
  {
    "name": "GetClientAbsAngles",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Returns the client's position angle.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        },
        {
          "name": "ang",
          "description": "Destination vector to store the client's position angle."
        }
      ],
      "error": [
        "Invalid client index, client not in game, or no mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      },
      {
        "name": "ang",
        "type": "float",
        "default": null,
        "description": "Destination vector to store the client's position angle."
      }
    ],
    "full_declaration": "native void GetClientAbsAngles(int client, float ang[3]);"
  },
  {
    "name": "GetClientAbsOrigin",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Returns the client's origin vector.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        },
        {
          "name": "vec",
          "description": "Destination vector to store the client's origin vector."
        }
      ],
      "error": [
        "Invalid client index, client not in game, or no mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Destination vector to store the client's origin vector."
      }
    ],
    "full_declaration": "native void GetClientAbsOrigin(int client, float vec[3]);"
  },
  {
    "name": "GetClientArmor",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "int",
    "comment": "Returns the client's armor.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        }
      ],
      "error": [
        "Invalid client index, client not in game, or no mod support."
      ],
      "note": [],
      "return": "Armor value."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      }
    ],
    "full_declaration": "native int GetClientArmor(int client);"
  },
  {
    "name": "GetClientDeaths",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "int",
    "comment": "Returns the client's death count.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        }
      ],
      "error": [
        "Invalid client index, client not in game, or no mod support."
      ],
      "note": [],
      "return": "Death count."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      }
    ],
    "full_declaration": "native int GetClientDeaths(int client);"
  },
  {
    "name": "GetClientFrags",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "int",
    "comment": "Returns the client's frag count.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        }
      ],
      "error": [
        "Invalid client index, client not in game, or no mod support."
      ],
      "note": [],
      "return": "Frag count."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      }
    ],
    "full_declaration": "native int GetClientFrags(int client);"
  },
  {
    "name": "GetClientDataRate",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "int",
    "comment": "Returns the client's send data rate in bytes/sec.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        }
      ],
      "error": [
        "Invalid client index, client not connected, or fake client."
      ],
      "note": [],
      "return": "Data rate."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      }
    ],
    "full_declaration": "native int GetClientDataRate(int client);"
  },
  {
    "name": "IsClientTimingOut",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "bool",
    "comment": "Returns if a client is timing out",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        }
      ],
      "error": [
        "Invalid client index, client not connected, or fake client."
      ],
      "note": [],
      "return": "True if client is timing out, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      }
    ],
    "full_declaration": "native bool IsClientTimingOut(int client);"
  },
  {
    "name": "GetClientTime",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "float",
    "comment": "Returns the client's connection time in seconds.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        }
      ],
      "error": [
        "Invalid client index, client not connected, or fake client."
      ],
      "note": [],
      "return": "Connection time."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      }
    ],
    "full_declaration": "native float GetClientTime(int client);"
  },
  {
    "name": "GetClientLatency",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "float",
    "comment": "Returns the client's current latency (RTT), more accurate than GetAvgLatency but jittering.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        },
        {
          "name": "flow",
          "description": "Traffic flowing direction."
        }
      ],
      "error": [
        "Invalid client index, client not connected, or fake client."
      ],
      "note": [],
      "return": "Latency, or -1 if network info is not available."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      },
      {
        "name": "flow",
        "type": "NetFlow",
        "default": null,
        "description": "Traffic flowing direction."
      }
    ],
    "full_declaration": "native float GetClientLatency(int client, NetFlow flow);"
  },
  {
    "name": "GetClientAvgLatency",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "float",
    "comment": "Returns the client's average packet latency in seconds.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        },
        {
          "name": "flow",
          "description": "Traffic flowing direction."
        }
      ],
      "error": [
        "Invalid client index, client not connected, or fake client."
      ],
      "note": [],
      "return": "Latency, or -1 if network info is not available."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      },
      {
        "name": "flow",
        "type": "NetFlow",
        "default": null,
        "description": "Traffic flowing direction."
      }
    ],
    "full_declaration": "native float GetClientAvgLatency(int client, NetFlow flow);"
  },
  {
    "name": "GetClientAvgLoss",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "float",
    "comment": "Returns the client's average packet loss, values go from 0 to 1 (for percentages).",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        },
        {
          "name": "flow",
          "description": "Traffic flowing direction."
        }
      ],
      "error": [
        "Invalid client index, client not connected, or fake client."
      ],
      "note": [],
      "return": "Average packet loss, or -1 if network info is not available."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      },
      {
        "name": "flow",
        "type": "NetFlow",
        "default": null,
        "description": "Traffic flowing direction."
      }
    ],
    "full_declaration": "native float GetClientAvgLoss(int client, NetFlow flow);"
  },
  {
    "name": "GetClientAvgChoke",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "float",
    "comment": "Returns the client's average packet choke, values go from 0 to 1 (for percentages).",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        },
        {
          "name": "flow",
          "description": "Traffic flowing direction."
        }
      ],
      "error": [
        "Invalid client index, client not connected, or fake client."
      ],
      "note": [],
      "return": "Average packet loss, or -1 if network info is not available."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      },
      {
        "name": "flow",
        "type": "NetFlow",
        "default": null,
        "description": "Traffic flowing direction."
      }
    ],
    "full_declaration": "native float GetClientAvgChoke(int client, NetFlow flow);"
  },
  {
    "name": "GetClientAvgData",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "float",
    "comment": "Returns the client's data flow in bytes/sec.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        },
        {
          "name": "flow",
          "description": "Traffic flowing direction."
        }
      ],
      "error": [
        "Invalid client index, client not connected, or fake client."
      ],
      "note": [],
      "return": "Data flow."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      },
      {
        "name": "flow",
        "type": "NetFlow",
        "default": null,
        "description": "Traffic flowing direction."
      }
    ],
    "full_declaration": "native float GetClientAvgData(int client, NetFlow flow);"
  },
  {
    "name": "GetClientAvgPackets",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "float",
    "comment": "Returns the client's average packet frequency in packets/sec.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        },
        {
          "name": "flow",
          "description": "Traffic flowing direction."
        }
      ],
      "error": [
        "Invalid client index, client not connected, or fake client."
      ],
      "note": [],
      "return": "Packet frequency."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      },
      {
        "name": "flow",
        "type": "NetFlow",
        "default": null,
        "description": "Traffic flowing direction."
      }
    ],
    "full_declaration": "native float GetClientAvgPackets(int client, NetFlow flow);"
  },
  {
    "name": "GetClientOfUserId",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "int",
    "comment": "Translates an userid index to the real player index.",
    "tags": {
      "param": [
        {
          "name": "userid",
          "description": "Userid value."
        }
      ],
      "error": [
        "Returns 0 if invalid userid."
      ],
      "note": [],
      "return": "Client value."
    },
    "params": [
      {
        "name": "userid",
        "type": "int",
        "default": null,
        "description": "Userid value."
      }
    ],
    "full_declaration": "native int GetClientOfUserId(int userid);"
  },
  {
    "name": "KickClient",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Disconnects a client from the server as soon as the next frame starts.\n\nNote: Originally, KickClient() was immediate.  The delay was introduced\nbecause despite warnings, plugins were using it in ways that would crash.\nThe new safe version can break cases that rely on immediate disconnects,\nbut ensures that plugins do not accidentally cause crashes.\n\nIf you need immediate disconnects, use KickClientEx().\n\nNote: IsClientInKickQueue() will return true before the kick occurs.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "format",
          "description": "Optional formatting rules for disconnect reason. Note that a period is automatically appended to the string by the engine."
        }
      ],
      "error": [
        "Invalid client index, or client not connected."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "format",
        "type": "char[]",
        "default": "",
        "description": "Optional formatting rules for disconnect reason. Note that a period is automatically appended to the string by the engine."
      }
    ],
    "full_declaration": "native void KickClient(int client, const char[] format=\"\", any ...);"
  },
  {
    "name": "KickClientEx",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Immediately disconnects a client from the server.\n\nKicking clients from certain events or callbacks may cause crashes.  If in\ndoubt, create a short (0.1 second) timer to kick the client in the next\navailable frame.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "format",
          "description": "Optional formatting rules for disconnect reason. Note that a period is automatically appended to the string by the engine."
        }
      ],
      "error": [
        "Invalid client index, or client not connected."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "format",
        "type": "char[]",
        "default": "",
        "description": "Optional formatting rules for disconnect reason. Note that a period is automatically appended to the string by the engine."
      }
    ],
    "full_declaration": "native void KickClientEx(int client, const char[] format=\"\", any ...);"
  },
  {
    "name": "ChangeClientTeam",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "void",
    "comment": "Changes a client's team through the mod's generic team changing function.\nOn CS:S, this will kill the player.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "team",
          "description": "Mod-specific team index."
        }
      ],
      "error": [
        "Invalid client index, client not in game, or lack of mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "team",
        "type": "int",
        "default": null,
        "description": "Mod-specific team index."
      }
    ],
    "full_declaration": "native void ChangeClientTeam(int client, int team);"
  },
  {
    "name": "GetClientSerial",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "int",
    "comment": "Returns the clients unique serial identifier.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        }
      ],
      "error": [
        "Invalid client index, or client not connected."
      ],
      "note": [],
      "return": "Serial number."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      }
    ],
    "full_declaration": "native int GetClientSerial(int client);"
  },
  {
    "name": "GetClientFromSerial",
    "type": "native",
    "source_file": "clients.inc",
    "return_type": "int",
    "comment": "Returns the client index by its serial number.",
    "tags": {
      "param": [
        {
          "name": "serial",
          "description": "Serial number."
        }
      ],
      "error": [],
      "note": [],
      "return": "Client index, or 0 for invalid serial."
    },
    "params": [
      {
        "name": "serial",
        "type": "int",
        "default": null,
        "description": "Serial number."
      }
    ],
    "full_declaration": "native int GetClientFromSerial(int serial);"
  },
  {
    "name": "ProcessTargetString",
    "type": "native",
    "source_file": "commandfilters.inc",
    "return_type": "int",
    "comment": "Processes a generic command target string, and resolves it to a list\nof clients or one client, based on filtering rules and a pattern.\n\nNote that you should use LoadTranslations(\"common.phrases\") in OnPluginStart(),\nas that file is guaranteed to contain all of the translatable phrases that\nProcessTargetString() will return.",
    "tags": {
      "param": [
        {
          "name": "pattern",
          "description": "Pattern to find clients against."
        },
        {
          "name": "admin",
          "description": "Admin performing the action, or 0 if the server."
        },
        {
          "name": "targets",
          "description": "Array to hold targets."
        },
        {
          "name": "max_targets",
          "description": "Maximum size of the targets array."
        },
        {
          "name": "filter_flags",
          "description": "Filter flags."
        },
        {
          "name": "target_name",
          "description": "Buffer to store the target name."
        },
        {
          "name": "tn_maxlength",
          "description": "Maximum length of the target name buffer."
        },
        {
          "name": "tn_is_ml",
          "description": "OUTPUT: Will be true if the target name buffer is an ML phrase, false if it is a normal string."
        }
      ],
      "error": [],
      "note": [],
      "return": "If a multi-target pattern was used, the number of clients found is returned.  If a single-target pattern was used, 1 is returned if one valid client is found.  Otherwise, a COMMAND_TARGET reason for failure is returned."
    },
    "params": [
      {
        "name": "pattern",
        "type": "char[]",
        "default": null,
        "description": "Pattern to find clients against."
      },
      {
        "name": "admin",
        "type": "int",
        "default": null,
        "description": "Admin performing the action, or 0 if the server."
      },
      {
        "name": "targets",
        "type": "int[]",
        "default": null,
        "description": "Array to hold targets."
      },
      {
        "name": "max_targets",
        "type": "int",
        "default": null,
        "description": "Maximum size of the targets array."
      },
      {
        "name": "filter_flags",
        "type": "int",
        "default": null,
        "description": "Filter flags."
      },
      {
        "name": "target_name",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the target name."
      },
      {
        "name": "tn_maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the target name buffer."
      },
      {
        "name": "tn_is_ml",
        "type": "bool",
        "default": null,
        "description": "OUTPUT: Will be true if the target name buffer is an ML phrase, false if it is a normal string."
      }
    ],
    "full_declaration": "native int ProcessTargetString(const char[] pattern, \t\t\t\t\t\t\t   int admin,  \t\t\t\t\t\t\t   int[] targets, \t\t\t\t\t\t\t   int max_targets, \t\t\t\t\t\t\t   int filter_flags, \t\t\t\t\t\t\t   char[] target_name, \t\t\t\t\t\t\t   int tn_maxlength, \t\t\t\t\t\t\t   bool &tn_is_ml);"
  },
  {
    "name": "ReplyToTargetError",
    "type": "stock",
    "source_file": "commandfilters.inc",
    "return_type": "void",
    "comment": "Replies to a client with a given message describing a targetting\nfailure reason.\n\nNote: The translation phrases are found in common.phrases.txt.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index, or 0 for server."
        },
        {
          "name": "reason",
          "description": "COMMAND_TARGET reason."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index, or 0 for server."
      },
      {
        "name": "reason",
        "type": "int",
        "default": null,
        "description": "COMMAND_TARGET reason."
      }
    ],
    "full_declaration": "stock void ReplyToTargetError(int client, int reason) { \tswitch (reason) \t{ \t\tcase COMMAND_TARGET_NONE: \t\t{ \t\t\tReplyToCommand(client, \"[SM] %t\", \"No matching client\");"
  },
  {
    "name": "AddMultiTargetFilter",
    "type": "native",
    "source_file": "commandfilters.inc",
    "return_type": "void",
    "comment": "Adds a multi-target filter function for ProcessTargetString().",
    "tags": {
      "param": [
        {
          "name": "pattern",
          "description": "Pattern to match (case sensitive)."
        },
        {
          "name": "filter",
          "description": "Filter function."
        },
        {
          "name": "phrase",
          "description": "Descriptive phrase to display on successful match."
        },
        {
          "name": "phraseIsML",
          "description": "True if phrase is multi-lingual, false otherwise."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pattern",
        "type": "char[]",
        "default": null,
        "description": "Pattern to match (case sensitive)."
      },
      {
        "name": "filter",
        "type": "MultiTargetFilter",
        "default": null,
        "description": "Filter function."
      },
      {
        "name": "phrase",
        "type": "char[]",
        "default": null,
        "description": "Descriptive phrase to display on successful match."
      },
      {
        "name": "phraseIsML",
        "type": "bool",
        "default": null,
        "description": "True if phrase is multi-lingual, false otherwise."
      }
    ],
    "full_declaration": "native void AddMultiTargetFilter(const char[] pattern, MultiTargetFilter filter,                                  const char[] phrase, bool phraseIsML);"
  },
  {
    "name": "RemoveMultiTargetFilter",
    "type": "native",
    "source_file": "commandfilters.inc",
    "return_type": "void",
    "comment": "Removes a multi-target filter function from ProcessTargetString().",
    "tags": {
      "param": [
        {
          "name": "pattern",
          "description": "Pattern to match (case sensitive)."
        },
        {
          "name": "filter",
          "description": "Filter function."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pattern",
        "type": "char[]",
        "default": null,
        "description": "Pattern to match (case sensitive)."
      },
      {
        "name": "filter",
        "type": "MultiTargetFilter",
        "default": null,
        "description": "Filter function."
      }
    ],
    "full_declaration": "native void RemoveMultiTargetFilter(const char[] pattern, MultiTargetFilter filter);"
  },
  {
    "name": "GetCommandLine",
    "type": "native",
    "source_file": "commandline.inc",
    "return_type": "bool",
    "comment": "Gets the full command line the server was launched with.",
    "tags": {
      "param": [
        {
          "name": "commandLine",
          "description": "Buffer to store the command line in."
        },
        {
          "name": "maxlen",
          "description": "Maximum length of the command line buffer."
        }
      ],
      "error": [
        "No command line available, or no mod support."
      ],
      "note": [],
      "return": "True if the command line is valid; otherwise, false."
    },
    "params": [
      {
        "name": "commandLine",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the command line in."
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "Maximum length of the command line buffer."
      }
    ],
    "full_declaration": "native bool GetCommandLine(char[] commandLine, int maxlen);"
  },
  {
    "name": "GetCommandLineParam",
    "type": "native",
    "source_file": "commandline.inc",
    "return_type": "void",
    "comment": "Gets the value of a command line parameter the server was launched with.",
    "tags": {
      "param": [
        {
          "name": "param",
          "description": "The command line parameter to get the value of."
        },
        {
          "name": "value",
          "description": "Buffer to store the parameter value in."
        },
        {
          "name": "maxlen",
          "description": "Maximum length of the value buffer."
        },
        {
          "name": "defValue",
          "description": "The default value to return if the parameter wasn't specified."
        }
      ],
      "error": [
        "No command line available, or no mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "param",
        "type": "char[]",
        "default": null,
        "description": "The command line parameter to get the value of."
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the parameter value in."
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "Maximum length of the value buffer."
      },
      {
        "name": "defValue",
        "type": "char[]",
        "default": "",
        "description": "The default value to return if the parameter wasn't specified."
      }
    ],
    "full_declaration": "native void GetCommandLineParam(const char[] param, char[] value, int maxlen, const char[] defValue=\"\");"
  },
  {
    "name": "GetCommandLineParamInt",
    "type": "native",
    "source_file": "commandline.inc",
    "return_type": "int",
    "comment": "Gets the value of a command line parameter the server was launched with.",
    "tags": {
      "param": [
        {
          "name": "param",
          "description": "The command line parameter to get the value of."
        },
        {
          "name": "defValue",
          "description": "The default value to return if the parameter wasn't specified."
        }
      ],
      "error": [
        "No command line available, or no mod support."
      ],
      "note": [],
      "return": "The integer value of the command line parameter value."
    },
    "params": [
      {
        "name": "param",
        "type": "char[]",
        "default": null,
        "description": "The command line parameter to get the value of."
      },
      {
        "name": "defValue",
        "type": "int",
        "default": "",
        "description": "The default value to return if the parameter wasn't specified."
      }
    ],
    "full_declaration": "native int GetCommandLineParamInt(const char[] param, int defValue=0);"
  },
  {
    "name": "GetCommandLineParamFloat",
    "type": "native",
    "source_file": "commandline.inc",
    "return_type": "float",
    "comment": "Gets the value of a command line parameter the server was launched with.",
    "tags": {
      "param": [
        {
          "name": "param",
          "description": "The command line parameter to get the value of."
        },
        {
          "name": "defValue",
          "description": "The default value to return if the parameter wasn't specified."
        }
      ],
      "error": [
        "No command line available, or no mod support."
      ],
      "note": [],
      "return": "The floating point value of the command line parameter value."
    },
    "params": [
      {
        "name": "param",
        "type": "char[]",
        "default": null,
        "description": "The command line parameter to get the value of."
      },
      {
        "name": "defValue",
        "type": "float",
        "default": "",
        "description": "The default value to return if the parameter wasn't specified."
      }
    ],
    "full_declaration": "native float GetCommandLineParamFloat(const char[] param, float defValue=0.0);"
  },
  {
    "name": "FindCommandLineParam",
    "type": "native",
    "source_file": "commandline.inc",
    "return_type": "bool",
    "comment": "Determines if a specific command line parameter is present.",
    "tags": {
      "param": [
        {
          "name": "param",
          "description": "The command line parameter to test."
        }
      ],
      "error": [
        "No command line available, or no mod support."
      ],
      "note": [],
      "return": "True if the command line parameter is specified; otherwise, false."
    },
    "params": [
      {
        "name": "param",
        "type": "char[]",
        "default": null,
        "description": "The command line parameter to test."
      }
    ],
    "full_declaration": "native bool FindCommandLineParam(const char[] param);"
  },
  {
    "name": "ServerCommand",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "void",
    "comment": "Executes a server command as if it were on the server console (or RCON)",
    "tags": {
      "param": [
        {
          "name": "format",
          "description": "Formatting rules."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "Formatting rules."
      }
    ],
    "full_declaration": "native void ServerCommand(const char[] format, any ...);"
  },
  {
    "name": "ServerCommandEx",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "void",
    "comment": "Executes a server command as if it were on the server console (or RCON)\nand stores the printed text into buffer.\n\nWarning: This calls ServerExecute internally and may have issues if\ncertain commands are in the buffer, only use when you really need\nthe response.\nAlso, on L4D2 this will not print the command output to the server console.",
    "tags": {
      "param": [
        {
          "name": "buffer",
          "description": "String to store command result into."
        },
        {
          "name": "maxlen",
          "description": "Length of buffer."
        },
        {
          "name": "format",
          "description": "Formatting rules."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "String to store command result into."
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "Length of buffer."
      },
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "Formatting rules."
      }
    ],
    "full_declaration": "native void ServerCommandEx(char[] buffer, int maxlen, const char[] format, any ...);"
  },
  {
    "name": "InsertServerCommand",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "void",
    "comment": "Inserts a server command at the beginning of the server command buffer.",
    "tags": {
      "param": [
        {
          "name": "format",
          "description": "Formatting rules."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "Formatting rules."
      }
    ],
    "full_declaration": "native void InsertServerCommand(const char[] format, any ...);"
  },
  {
    "name": "ServerExecute",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "void",
    "comment": "Executes every command in the server's command buffer, rather than once per frame.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [],
    "full_declaration": "native void ServerExecute();"
  },
  {
    "name": "ClientCommand",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "void",
    "comment": "Executes a client command.  Note that this will not work on clients unless\nthey have cl_restrict_server_commands set to 0.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Index of the client."
        },
        {
          "name": "fmt",
          "description": "Format of the client command."
        }
      ],
      "error": [
        "Invalid client index, or client not connected."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Index of the client."
      },
      {
        "name": "fmt",
        "type": "char[]",
        "default": null,
        "description": "Format of the client command."
      }
    ],
    "full_declaration": "native void ClientCommand(int client, const char[] fmt, any ...);"
  },
  {
    "name": "FakeClientCommand",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "void",
    "comment": "Executes a client command on the server without being networked.\n\nFakeClientCommand() overwrites the command tokenization buffer.  This can\ncause undesired effects because future calls to GetCmdArg* will return\ndata from the FakeClientCommand(), not the parent command.  If you are in\na hook where this matters (for example, a \"say\" hook), you should use\nFakeClientCommandEx() instead.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Index of the client."
        },
        {
          "name": "fmt",
          "description": "Format of the client command."
        }
      ],
      "error": [
        "Invalid client index, or client not connected."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Index of the client."
      },
      {
        "name": "fmt",
        "type": "char[]",
        "default": null,
        "description": "Format of the client command."
      }
    ],
    "full_declaration": "native void FakeClientCommand(int client, const char[] fmt, any ...);"
  },
  {
    "name": "FakeClientCommandEx",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "void",
    "comment": "Executes a client command on the server without being networked.  The\nexecution of the client command is delayed by one frame to prevent any\nre-entrancy issues that might surface with FakeClientCommand().",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Index of the client."
        },
        {
          "name": "fmt",
          "description": "Format of the client command."
        }
      ],
      "error": [
        "Invalid client index, or client not connected."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Index of the client."
      },
      {
        "name": "fmt",
        "type": "char[]",
        "default": null,
        "description": "Format of the client command."
      }
    ],
    "full_declaration": "native void FakeClientCommandEx(int client, const char[] fmt, any ...);"
  },
  {
    "name": "FakeClientCommandKeyValues",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "void",
    "comment": "Executes a KeyValues client command on the server without being networked.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Index of the client."
        },
        {
          "name": "kv",
          "description": "KeyValues data to be sent."
        }
      ],
      "error": [
        "Invalid client index, client not connected, or unsupported on current game."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Index of the client."
      },
      {
        "name": "kv",
        "type": "KeyValues",
        "default": null,
        "description": "KeyValues data to be sent."
      }
    ],
    "full_declaration": "native void FakeClientCommandKeyValues(int client, KeyValues kv);"
  },
  {
    "name": "PrintToServer",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "void",
    "comment": "Sends a message to the server console.",
    "tags": {
      "param": [
        {
          "name": "format",
          "description": "Formatting rules."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "Formatting rules."
      }
    ],
    "full_declaration": "native void PrintToServer(const char[] format, any ...);"
  },
  {
    "name": "PrintToConsole",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "void",
    "comment": "Sends a message to a client's console.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "format",
          "description": "Formatting rules."
        }
      ],
      "error": [
        "If the client is not connected an error will be thrown."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "Formatting rules."
      }
    ],
    "full_declaration": "native void PrintToConsole(int client, const char[] format, any ...);"
  },
  {
    "name": "PrintToConsoleAll",
    "type": "stock",
    "source_file": "console.inc",
    "return_type": "void",
    "comment": "Sends a message to every client's console.",
    "tags": {
      "param": [
        {
          "name": "format",
          "description": "Formatting rules."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "Formatting rules."
      }
    ],
    "full_declaration": "stock void PrintToConsoleAll(const char[] format, any ...) { \tchar buffer[254]; \t \tfor (int i = 1; i <= MaxClients; i++) \t{ \t\tif (IsClientInGame(i)) \t\t{ \t\t\tSetGlobalTransTarget(i);"
  },
  {
    "name": "ReplyToCommand",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "void",
    "comment": "Replies to a message in a command.\n\nA client index of 0 will use PrintToServer().\nIf the command was from the console, PrintToConsole() is used.\nIf the command was from chat, PrintToChat() is used.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index, or 0 for server."
        },
        {
          "name": "format",
          "description": "Formatting rules."
        }
      ],
      "error": [
        "If the client is not connected or invalid."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index, or 0 for server."
      },
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "Formatting rules."
      }
    ],
    "full_declaration": "native void ReplyToCommand(int client, const char[] format, any ...);"
  },
  {
    "name": "GetCmdReplySource",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "ReplySource",
    "comment": "Returns the current reply source of a command.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "ReplySource value."
    },
    "params": [],
    "full_declaration": "native ReplySource GetCmdReplySource();"
  },
  {
    "name": "SetCmdReplySource",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "ReplySource",
    "comment": "Sets the current reply source of a command.\n\nOnly use this if you know what you are doing.  You should save the old value\nand restore it once you are done.",
    "tags": {
      "param": [
        {
          "name": "source",
          "description": "New ReplySource value."
        }
      ],
      "error": [],
      "note": [],
      "return": "Old ReplySource value."
    },
    "params": [
      {
        "name": "source",
        "type": "ReplySource",
        "default": null,
        "description": "New ReplySource value."
      }
    ],
    "full_declaration": "native ReplySource SetCmdReplySource(ReplySource source);"
  },
  {
    "name": "IsChatTrigger",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "bool",
    "comment": "Returns whether the current say hook is a chat trigger.\n\nThis function is only meaningful inside say or say_team hooks.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "True if a chat trigger, false otherwise."
    },
    "params": [],
    "full_declaration": "native bool IsChatTrigger();"
  },
  {
    "name": "GetPublicChatTriggers",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "int",
    "comment": "Get the list of characters used for public chat triggers.",
    "tags": {
      "param": [
        {
          "name": "buffer",
          "description": "Buffer to use for storing the string."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of the buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "Length of string written to buffer."
    },
    "params": [
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Buffer to use for storing the string."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the buffer."
      }
    ],
    "full_declaration": "native int GetPublicChatTriggers(char[] buffer, int maxlength);"
  },
  {
    "name": "GetSilentChatTriggers",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "int",
    "comment": "Get the list of characters used for silent chat triggers.",
    "tags": {
      "param": [
        {
          "name": "buffer",
          "description": "Buffer to use for storing the string."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of the buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "Length of string written to buffer."
    },
    "params": [
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Buffer to use for storing the string."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the buffer."
      }
    ],
    "full_declaration": "native int GetSilentChatTriggers(char[] buffer, int maxlength);"
  },
  {
    "name": "ShowActivity2",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "void",
    "comment": "Displays usage of an admin command to users depending on the\nsetting of the sm_show_activity cvar.  All users receive a message\nin their chat text, except for the originating client, who receives\nthe message based on the current ReplySource.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index doing the action, or 0 for server."
        },
        {
          "name": "tag",
          "description": "Tag to prepend to the message."
        },
        {
          "name": "format",
          "description": "Formatting rules."
        }
      ],
      "error": [
        ""
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index doing the action, or 0 for server."
      },
      {
        "name": "tag",
        "type": "char[]",
        "default": null,
        "description": "Tag to prepend to the message."
      },
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "Formatting rules."
      }
    ],
    "full_declaration": "native void ShowActivity2(int client, const char[] tag, const char[] format, any ...);"
  },
  {
    "name": "ShowActivity",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "void",
    "comment": "Displays usage of an admin command to users depending on the\nsetting of the sm_show_activity cvar.\n\nThis version does not display a message to the originating client\nif used from chat triggers or menus.  If manual replies are used\nfor these cases, then this function will suffice.  Otherwise,\nShowActivity2() is slightly more useful.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index doing the action, or 0 for server."
        },
        {
          "name": "format",
          "description": "Formatting rules."
        }
      ],
      "error": [
        ""
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index doing the action, or 0 for server."
      },
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "Formatting rules."
      }
    ],
    "full_declaration": "native void ShowActivity(int client, const char[] format, any ...);"
  },
  {
    "name": "ShowActivityEx",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "void",
    "comment": "Same as ShowActivity(), except the tag parameter is used instead of\n\"[SM] \" (note that you must supply any spacing).",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index doing the action, or 0 for server."
        },
        {
          "name": "tag",
          "description": "Tag to display with."
        },
        {
          "name": "format",
          "description": "Formatting rules."
        }
      ],
      "error": [
        ""
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index doing the action, or 0 for server."
      },
      {
        "name": "tag",
        "type": "char[]",
        "default": null,
        "description": "Tag to display with."
      },
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "Formatting rules."
      }
    ],
    "full_declaration": "native void ShowActivityEx(int client, const char[] tag, const char[] format, any ...);"
  },
  {
    "name": "FormatActivitySource",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "bool",
    "comment": "Given an originating client and a target client, returns the string\nthat describes the originating client according to the sm_show_activity cvar.\n\nFor example, \"ADMIN\", \"PLAYER\", or a player's name could be placed in this buffer.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Originating client; may be 0 for server console."
        },
        {
          "name": "target",
          "description": "Targeted client."
        },
        {
          "name": "namebuf",
          "description": "Name buffer."
        },
        {
          "name": "maxlength",
          "description": "Maximum size of the name buffer."
        }
      ],
      "error": [
        "Invalid client index or client not connected."
      ],
      "note": [],
      "return": "True if activity should be shown.  False otherwise.  In either case, the name buffer is filled.  The return value can be used to broadcast a \"safe\" name to all players regardless of the sm_show_activity filters."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Originating client; may be 0 for server console."
      },
      {
        "name": "target",
        "type": "int",
        "default": null,
        "description": "Targeted client."
      },
      {
        "name": "namebuf",
        "type": "char[]",
        "default": null,
        "description": "Name buffer."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum size of the name buffer."
      }
    ],
    "full_declaration": "native bool FormatActivitySource(int client, int target, const char[] namebuf, int maxlength);"
  },
  {
    "name": "SrvCmd",
    "type": "typedef",
    "source_file": "console.inc",
    "return_type": "Action",
    "comment": "Called when a server-only command is invoked.",
    "tags": {
      "param": [
        {
          "name": "args",
          "description": "Number of arguments that were in the argument string."
        }
      ],
      "error": [],
      "note": [],
      "return": "An Action value.  Not handling the command means that Source will report it as \"not found.\""
    },
    "params": [
      {
        "name": "args",
        "type": "int",
        "default": null,
        "description": "Number of arguments that were in the argument string."
      }
    ],
    "full_declaration": "typedef SrvCmd = function Action (int args);"
  },
  {
    "name": "RegServerCmd",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "void",
    "comment": "Creates a server-only console command, or hooks an already existing one.\n\nServer commands are case sensitive.",
    "tags": {
      "param": [
        {
          "name": "cmd",
          "description": "Name of the command to hook or create."
        },
        {
          "name": "callback",
          "description": "A function to use as a callback for when the command is invoked."
        },
        {
          "name": "description",
          "description": "Optional description to use for command creation."
        },
        {
          "name": "flags",
          "description": "Optional flags to use for command creation."
        }
      ],
      "error": [
        "Command name is the same as an existing convar."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "cmd",
        "type": "char[]",
        "default": null,
        "description": "Name of the command to hook or create."
      },
      {
        "name": "callback",
        "type": "SrvCmd",
        "default": null,
        "description": "A function to use as a callback for when the command is invoked."
      },
      {
        "name": "description",
        "type": "char[]",
        "default": "",
        "description": "Optional description to use for command creation."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Optional flags to use for command creation."
      }
    ],
    "full_declaration": "native void RegServerCmd(const char[] cmd, SrvCmd callback, const char[] description=\"\", int flags=0);"
  },
  {
    "name": "ConCmd",
    "type": "typedef",
    "source_file": "console.inc",
    "return_type": "Action",
    "comment": "Called when a generic console command is invoked.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Index of the client, or 0 from the server."
        },
        {
          "name": "args",
          "description": "Number of arguments that were in the argument string."
        }
      ],
      "error": [],
      "note": [],
      "return": "An Action value.  Not handling the command means that Source will report it as \"not found.\""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Index of the client, or 0 from the server."
      },
      {
        "name": "args",
        "type": "int",
        "default": null,
        "description": "Number of arguments that were in the argument string."
      }
    ],
    "full_declaration": "typedef ConCmd = function Action (int client, int args);"
  },
  {
    "name": "RegConsoleCmd",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "void",
    "comment": "Creates a console command, or hooks an already existing one.\n\nConsole commands are case sensitive.  However, if the command already exists in the game,\na client may enter the command in any case.  SourceMod corrects for this automatically,\nand you should only hook the \"real\" version of the command.",
    "tags": {
      "param": [
        {
          "name": "cmd",
          "description": "Name of the command to hook or create."
        },
        {
          "name": "callback",
          "description": "A function to use as a callback for when the command is invoked."
        },
        {
          "name": "description",
          "description": "Optional description to use for command creation."
        },
        {
          "name": "flags",
          "description": "Optional flags to use for command creation."
        }
      ],
      "error": [
        "Command name is the same as an existing convar."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "cmd",
        "type": "char[]",
        "default": null,
        "description": "Name of the command to hook or create."
      },
      {
        "name": "callback",
        "type": "ConCmd",
        "default": null,
        "description": "A function to use as a callback for when the command is invoked."
      },
      {
        "name": "description",
        "type": "char[]",
        "default": "",
        "description": "Optional description to use for command creation."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Optional flags to use for command creation."
      }
    ],
    "full_declaration": "native void RegConsoleCmd(const char[] cmd, ConCmd callback, const char[] description=\"\", int flags=0);"
  },
  {
    "name": "RegAdminCmd",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "void",
    "comment": "Creates a console command as an administrative command.  If the command does not exist,\nit is created.  When this command is invoked, the access rights of the player are\nautomatically checked before allowing it to continue.\n\nAdmin commands are case sensitive from both the client and server.",
    "tags": {
      "param": [
        {
          "name": "cmd",
          "description": "String containing command to register."
        },
        {
          "name": "callback",
          "description": "A function to use as a callback for when the command is invoked."
        },
        {
          "name": "adminflags",
          "description": "Administrative flags (bitstring) to use for permissions."
        },
        {
          "name": "description",
          "description": "Optional description to use for help."
        },
        {
          "name": "group",
          "description": "String containing the command group to use.  If empty, the plugin's filename will be used instead."
        },
        {
          "name": "flags",
          "description": "Optional console flags."
        }
      ],
      "error": [
        "Command name is the same as an existing convar."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "cmd",
        "type": "char[]",
        "default": null,
        "description": "String containing command to register."
      },
      {
        "name": "callback",
        "type": "ConCmd",
        "default": null,
        "description": "A function to use as a callback for when the command is invoked."
      },
      {
        "name": "adminflags",
        "type": "int",
        "default": null,
        "description": "Administrative flags (bitstring) to use for permissions."
      },
      {
        "name": "description",
        "type": "char[]",
        "default": "",
        "description": "Optional description to use for help."
      },
      {
        "name": "group",
        "type": "char[]",
        "default": "",
        "description": "String containing the command group to use.  If empty, the plugin's filename will be used instead."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Optional console flags."
      }
    ],
    "full_declaration": "native void RegAdminCmd(const char[] cmd, \t\t\t\t\tConCmd callback, \t\t\t\t\tint adminflags, \t\t\t\t\tconst char[] description=\"\", \t\t\t\t\tconst char[] group=\"\", \t\t\t\t\tint flags=0);"
  },
  {
    "name": "GetCmdArgs",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "int",
    "comment": "Returns the number of arguments from the current console or server command.",
    "tags": {
      "param": [],
      "error": [],
      "note": [
        "Unlike the HL2 engine call, this does not include the command itself."
      ],
      "return": "Number of arguments to the current command."
    },
    "params": [],
    "full_declaration": "native int GetCmdArgs();"
  },
  {
    "name": "GetCmdArg",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "int",
    "comment": "Retrieves a command argument given its index, from the current console or\nserver command.",
    "tags": {
      "param": [
        {
          "name": "argnum",
          "description": "Argument number to retrieve."
        },
        {
          "name": "buffer",
          "description": "Buffer to use for storing the string."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of the buffer."
        }
      ],
      "error": [],
      "note": [
        "Argument indexes start at 1; 0 retrieves the command name."
      ],
      "return": "Length of string written to buffer."
    },
    "params": [
      {
        "name": "argnum",
        "type": "int",
        "default": null,
        "description": "Argument number to retrieve."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Buffer to use for storing the string."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the buffer."
      }
    ],
    "full_declaration": "native int GetCmdArg(int argnum, char[] buffer, int maxlength);"
  },
  {
    "name": "GetCmdArgInt",
    "type": "stock",
    "source_file": "console.inc",
    "return_type": "int",
    "comment": "Retrieves a numeric command argument given its index, from the current\nconsole or server command. Will return 0 if the argument can not be\nparsed as a number. Use GetCmdArgIntEx to handle that explicitly.",
    "tags": {
      "param": [
        {
          "name": "argnum",
          "description": "Argument number to retrieve."
        }
      ],
      "error": [],
      "note": [],
      "return": "Value of the command argument."
    },
    "params": [
      {
        "name": "argnum",
        "type": "int",
        "default": null,
        "description": "Argument number to retrieve."
      }
    ],
    "full_declaration": "stock int GetCmdArgInt(int argnum) {     char str[12];     GetCmdArg(argnum, str, sizeof(str));"
  },
  {
    "name": "GetCmdArgIntEx",
    "type": "stock",
    "source_file": "console.inc",
    "return_type": "bool",
    "comment": "Retrieves a numeric command argument given its index, from the current\nconsole or server command. Returns false if the argument can not be\ncompletely parsed as an integer.",
    "tags": {
      "param": [
        {
          "name": "argnum",
          "description": "Argument number to retrieve."
        },
        {
          "name": "value",
          "description": "Populated with the value of the command argument."
        }
      ],
      "error": [],
      "note": [],
      "return": "Whether the argument was entirely a numeric value."
    },
    "params": [
      {
        "name": "argnum",
        "type": "int",
        "default": null,
        "description": "Argument number to retrieve."
      },
      {
        "name": "value",
        "type": "int",
        "default": null,
        "description": "Populated with the value of the command argument."
      }
    ],
    "full_declaration": "stock bool GetCmdArgIntEx(int argnum, int &value) {     char str[12];     int len = GetCmdArg(argnum, str, sizeof(str));"
  },
  {
    "name": "GetCmdArgFloat",
    "type": "stock",
    "source_file": "console.inc",
    "return_type": "float",
    "comment": "Retrieves a float command argument given its index, from the current\nconsole or server command. Will return 0.0 if the argument can not be\nparsed as a number. Use GetCmdArgFloatEx to handle that explicitly.",
    "tags": {
      "param": [
        {
          "name": "argnum",
          "description": "Argument number to retrieve."
        }
      ],
      "error": [],
      "note": [],
      "return": "Value of the command argument."
    },
    "params": [
      {
        "name": "argnum",
        "type": "int",
        "default": null,
        "description": "Argument number to retrieve."
      }
    ],
    "full_declaration": "stock float GetCmdArgFloat(int argnum) {     char str[18];     GetCmdArg(argnum, str, sizeof(str));"
  },
  {
    "name": "GetCmdArgFloatEx",
    "type": "stock",
    "source_file": "console.inc",
    "return_type": "bool",
    "comment": "Retrieves a float command argument given its index, from the current\nconsole or server command. Returns false if the argument can not be\ncompletely parsed as a floating point.",
    "tags": {
      "param": [
        {
          "name": "argnum",
          "description": "Argument number to retrieve."
        },
        {
          "name": "value",
          "description": "Populated with the value of the command argument."
        }
      ],
      "error": [],
      "note": [],
      "return": "Whether the argument was entirely a floating point value."
    },
    "params": [
      {
        "name": "argnum",
        "type": "int",
        "default": null,
        "description": "Argument number to retrieve."
      },
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Populated with the value of the command argument."
      }
    ],
    "full_declaration": "stock bool GetCmdArgFloatEx(int argnum, float &value) {     char str[18];     int len = GetCmdArg(argnum, str, sizeof(str));"
  },
  {
    "name": "GetCmdArgString",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "int",
    "comment": "Retrieves the entire command argument string in one lump from the current\nconsole or server command.",
    "tags": {
      "param": [
        {
          "name": "buffer",
          "description": "Buffer to use for storing the string."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of the buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "Length of string written to buffer."
    },
    "params": [
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Buffer to use for storing the string."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the buffer."
      }
    ],
    "full_declaration": "native int GetCmdArgString(char[] buffer, int maxlength);"
  },
  {
    "name": "GetCommandIterator",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "Handle",
    "comment": "Gets a command iterator.  Must be freed with CloseHandle().",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "A new command iterator."
    },
    "params": [],
    "full_declaration": "native Handle GetCommandIterator();"
  },
  {
    "name": "ReadCommandIterator",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "bool",
    "comment": "Reads a command iterator, then advances to the next command if any.\nOnly SourceMod specific commands are returned.",
    "tags": {
      "param": [
        {
          "name": "iter",
          "description": "Command iterator Handle."
        },
        {
          "name": "name",
          "description": "Name buffer."
        },
        {
          "name": "nameLen",
          "description": "Name buffer size."
        },
        {
          "name": "eflags",
          "description": "Effective default flags of a command."
        },
        {
          "name": "desc",
          "description": "Command description buffer."
        },
        {
          "name": "descLen",
          "description": "Command description buffer size."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false if there are no more commands."
    },
    "params": [
      {
        "name": "iter",
        "type": "Handle",
        "default": null,
        "description": "Command iterator Handle."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Name buffer."
      },
      {
        "name": "nameLen",
        "type": "int",
        "default": null,
        "description": "Name buffer size."
      },
      {
        "name": "eflags",
        "type": "int",
        "default": "",
        "description": "Effective default flags of a command."
      },
      {
        "name": "desc",
        "type": "char[]",
        "default": "",
        "description": "Command description buffer."
      },
      {
        "name": "descLen",
        "type": "int",
        "default": "",
        "description": "Command description buffer size."
      }
    ],
    "full_declaration": "native bool ReadCommandIterator(Handle iter,  \t\t\t\t\t\t\t\tchar[] name,  \t\t\t\t\t\t\t\tint nameLen,  \t\t\t\t\t\t\t\tint &eflags=0,  \t\t\t\t\t\t\t\tchar[] desc=\"\",  \t\t\t\t\t\t\t\tint descLen=0);"
  },
  {
    "name": "CheckCommandAccess",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "bool",
    "comment": "Returns whether a client has access to a given command string.  The string\ncan be any override string, as overrides can be independent of\ncommands.  This feature essentially allows you to create custom\nflags using the override system.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "command",
          "description": "Command name.  If the command is not found, the default flags are used."
        },
        {
          "name": "flags",
          "description": "Flag string to use as a default, if the command or override is not found."
        },
        {
          "name": "override_only",
          "description": "If true, SourceMod will not attempt to find a matching command, and it will only use the default flags specified. Otherwise, SourceMod will ignore the default flags if there is a matching admin command."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if the client has access, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "command",
        "type": "char[]",
        "default": null,
        "description": "Command name.  If the command is not found, the default flags are used."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "Flag string to use as a default, if the command or override is not found."
      },
      {
        "name": "override_only",
        "type": "bool",
        "default": "",
        "description": "If true, SourceMod will not attempt to find a matching command, and it will only use the default flags specified. Otherwise, SourceMod will ignore the default flags if there is a matching admin command."
      }
    ],
    "full_declaration": "native bool CheckCommandAccess(int client,  \t\t\t\t\t\t\t   const char[] command, \t\t\t\t\t\t\t   int flags, \t\t\t\t\t\t\t   bool override_only=false);"
  },
  {
    "name": "CheckAccess",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "bool",
    "comment": "Returns whether an admin has access to a given command string.  The string\ncan be any override string, as overrides can be independent of\ncommands.  This feature essentially allows you to create custom flags\nusing the override system.",
    "tags": {
      "param": [
        {
          "name": "id",
          "description": "AdminId of the admin."
        },
        {
          "name": "command",
          "description": "Command name.  If the command is not found, the default flags are used."
        },
        {
          "name": "flags",
          "description": "Flag string to use as a default, if the command or override is not found."
        },
        {
          "name": "override_only",
          "description": "If true, SourceMod will not attempt to find a matching command, and it will only use the default flags specified. Otherwise, SourceMod will ignore the default flags if there is a matching admin command."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if the admin has access, false otherwise."
    },
    "params": [
      {
        "name": "id",
        "type": "AdminId",
        "default": null,
        "description": "AdminId of the admin."
      },
      {
        "name": "command",
        "type": "char[]",
        "default": null,
        "description": "Command name.  If the command is not found, the default flags are used."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "Flag string to use as a default, if the command or override is not found."
      },
      {
        "name": "override_only",
        "type": "bool",
        "default": "",
        "description": "If true, SourceMod will not attempt to find a matching command, and it will only use the default flags specified. Otherwise, SourceMod will ignore the default flags if there is a matching admin command."
      }
    ],
    "full_declaration": "native bool CheckAccess(AdminId id,  \t\t\t\t\t\t\t   const char[] command, \t\t\t\t\t\t\t   int flags, \t\t\t\t\t\t\t   bool override_only=false);"
  },
  {
    "name": "GetCommandFlags",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "int",
    "comment": "Returns the bitstring of flags of a command.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Name of the command."
        }
      ],
      "error": [],
      "note": [],
      "return": "A bitstring containing the FCVAR_* flags that are enabled or INVALID_FCVAR_FLAGS if command not found."
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Name of the command."
      }
    ],
    "full_declaration": "native int GetCommandFlags(const char[] name);"
  },
  {
    "name": "SetCommandFlags",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "bool",
    "comment": "Sets the bitstring of flags of a command.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Name of the command."
        },
        {
          "name": "flags",
          "description": "A bitstring containing the FCVAR_* flags to enable."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, otherwise false."
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Name of the command."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "A bitstring containing the FCVAR_* flags to enable."
      }
    ],
    "full_declaration": "native bool SetCommandFlags(const char[] name, int flags);"
  },
  {
    "name": "FindFirstConCommand",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "Handle",
    "comment": "Starts a ConCommandBase search, traversing the list of ConVars and\nConCommands.  If a Handle is returned, the next entry must be read\nvia FindNextConCommand().  The order of the list is undefined.",
    "tags": {
      "param": [
        {
          "name": "buffer",
          "description": "Buffer to store entry name."
        },
        {
          "name": "max_size",
          "description": "Maximum size of the buffer."
        },
        {
          "name": "isCommand",
          "description": "Variable to store whether the entry is a command. If it is not a command, it is a ConVar."
        },
        {
          "name": "flags",
          "description": "Variable to store entry flags."
        },
        {
          "name": "description",
          "description": "Buffer to store the description, empty if no description present."
        },
        {
          "name": "descrmax_size",
          "description": "Maximum size of the description buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "On success, a ConCmdIter Handle is returned, which can be read via FindNextConCommand(), and must be closed via CloseHandle().  Additionally, the output parameters will be filled with information of the first ConCommandBase entry. On failure, INVALID_HANDLE is returned, and the contents of outputs is undefined."
    },
    "params": [
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store entry name."
      },
      {
        "name": "max_size",
        "type": "int",
        "default": null,
        "description": "Maximum size of the buffer."
      },
      {
        "name": "isCommand",
        "type": "bool",
        "default": null,
        "description": "Variable to store whether the entry is a command. If it is not a command, it is a ConVar."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Variable to store entry flags."
      },
      {
        "name": "description",
        "type": "char[]",
        "default": "",
        "description": "Buffer to store the description, empty if no description present."
      },
      {
        "name": "descrmax_size",
        "type": "int",
        "default": "",
        "description": "Maximum size of the description buffer."
      }
    ],
    "full_declaration": "native Handle FindFirstConCommand(char[] buffer, int max_size, bool &isCommand, int &flags=0, char[] description=\"\", int descrmax_size=0);"
  },
  {
    "name": "FindNextConCommand",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "bool",
    "comment": "Reads the next entry in a ConCommandBase iterator.",
    "tags": {
      "param": [
        {
          "name": "search",
          "description": "ConCmdIter Handle to search."
        },
        {
          "name": "buffer",
          "description": "Buffer to store entry name."
        },
        {
          "name": "max_size",
          "description": "Maximum size of the buffer."
        },
        {
          "name": "isCommand",
          "description": "Variable to store whether the entry is a command. If it is not a command, it is a ConVar."
        },
        {
          "name": "flags",
          "description": "Variable to store entry flags."
        },
        {
          "name": "description",
          "description": "Buffer to store the description, empty if no description present."
        },
        {
          "name": "descrmax_size",
          "description": "Maximum size of the description buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "On success, the outputs are filled, the iterator is advanced to the next entry, and true is returned. If no more entries exist, false is returned, and the contents of outputs is undefined."
    },
    "params": [
      {
        "name": "search",
        "type": "Handle",
        "default": null,
        "description": "ConCmdIter Handle to search."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store entry name."
      },
      {
        "name": "max_size",
        "type": "int",
        "default": null,
        "description": "Maximum size of the buffer."
      },
      {
        "name": "isCommand",
        "type": "bool",
        "default": null,
        "description": "Variable to store whether the entry is a command. If it is not a command, it is a ConVar."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Variable to store entry flags."
      },
      {
        "name": "description",
        "type": "char[]",
        "default": "",
        "description": "Buffer to store the description, empty if no description present."
      },
      {
        "name": "descrmax_size",
        "type": "int",
        "default": "",
        "description": "Maximum size of the description buffer."
      }
    ],
    "full_declaration": "native bool FindNextConCommand(Handle search, char[] buffer, int max_size, bool &isCommand, int &flags=0, char[] description=\"\", int descrmax_size=0);"
  },
  {
    "name": "AddServerTag",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "void",
    "comment": "Adds an informational string to the server's public \"tags\".\nThis string should be a short, unique identifier.\n\nNote: Tags are automatically removed when a plugin unloads.\nNote: Currently, this function does nothing because of bugs in the Valve master.",
    "tags": {
      "param": [
        {
          "name": "tag",
          "description": "Tag string to append."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "tag",
        "type": "char[]",
        "default": null,
        "description": "Tag string to append."
      }
    ],
    "full_declaration": "native void AddServerTag(const char[] tag);"
  },
  {
    "name": "RemoveServerTag",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "void",
    "comment": "Removes a tag previously added by the calling plugin.",
    "tags": {
      "param": [
        {
          "name": "tag",
          "description": "Tag string to remove."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "tag",
        "type": "char[]",
        "default": null,
        "description": "Tag string to remove."
      }
    ],
    "full_declaration": "native void RemoveServerTag(const char[] tag);"
  },
  {
    "name": "CommandListener",
    "type": "typedef",
    "source_file": "console.inc",
    "return_type": "Action",
    "comment": "Callback for command listeners. This is invoked whenever any command\nreaches the server, from the server console itself or a player.\n\nClients may be in the process of connecting when they are executing commands\nIsClientConnected(client) is not guaranteed to return true.  Other functions\nsuch as GetClientIP() may not work at this point either.\n\nReturning Plugin_Handled or Plugin_Stop will prevent the original,\nbaseline code from running.\n\n-- TEXT BELOW IS IMPLEMENTATION, AND NOT GUARANTEED --\nEven if returning Plugin_Handled or Plugin_Stop, some callbacks will still\ntrigger. These are:\n* C++ command dispatch hooks from Metamod:Source plugins\n* Reg*Cmd() hooks that did not create new commands.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client, or 0 for server. Client may not be connected or in game."
        },
        {
          "name": "command",
          "description": "Command name, lower case. To get name as typed, use GetCmdArg() and specify argument 0."
        },
        {
          "name": "argc",
          "description": "Argument count."
        }
      ],
      "error": [],
      "note": [],
      "return": "Action to take (see extended notes above)."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client, or 0 for server. Client may not be connected or in game."
      },
      {
        "name": "command",
        "type": "char[]",
        "default": null,
        "description": "Command name, lower case. To get name as typed, use GetCmdArg() and specify argument 0."
      },
      {
        "name": "argc",
        "type": "int",
        "default": null,
        "description": "Argument count."
      }
    ],
    "full_declaration": "typedef CommandListener = function Action (int client, const char[] command, int argc);"
  },
  {
    "name": "AddCommandListener",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "bool",
    "comment": "Adds a callback that will fire when a command is sent to the server.\n\nRegistering commands is designed to create a new command as part of the UI,\nwhereas this is a lightweight hook on a command string, existing or not.\nUsing Reg*Cmd to intercept is in poor practice, as it physically creates a\nnew command and can slow down dispatch in general.\n\nTo see if this feature is available, use FeatureType_Capability and\nFEATURECAP_COMMANDLISTENER.",
    "tags": {
      "param": [
        {
          "name": "callback",
          "description": "Callback."
        },
        {
          "name": "command",
          "description": "Command, or if not specified, a global listener. The command is case insensitive."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if this feature is available on the current game, false otherwise."
    },
    "params": [
      {
        "name": "callback",
        "type": "CommandListener",
        "default": null,
        "description": "Callback."
      },
      {
        "name": "command",
        "type": "char[]",
        "default": "",
        "description": "Command, or if not specified, a global listener. The command is case insensitive."
      }
    ],
    "full_declaration": "native bool AddCommandListener(CommandListener callback, const char[] command=\"\");"
  },
  {
    "name": "RemoveCommandListener",
    "type": "native",
    "source_file": "console.inc",
    "return_type": "void",
    "comment": "Removes a previously added command listener, in reverse order of being added.",
    "tags": {
      "param": [
        {
          "name": "callback",
          "description": "Callback."
        },
        {
          "name": "command",
          "description": "Command, or if not specified, a global listener. The command is case insensitive."
        }
      ],
      "error": [
        "Callback has no active listeners."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "callback",
        "type": "CommandListener",
        "default": null,
        "description": "Callback."
      },
      {
        "name": "command",
        "type": "char[]",
        "default": "",
        "description": "Command, or if not specified, a global listener. The command is case insensitive."
      }
    ],
    "full_declaration": "native void RemoveCommandListener(CommandListener callback, const char[] command=\"\");"
  },
  {
    "name": "CommandExists",
    "type": "stock",
    "source_file": "console.inc",
    "return_type": "bool",
    "comment": "Returns true if the supplied command exists.",
    "tags": {
      "param": [
        {
          "name": "command",
          "description": "Command to find."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if command is found, false otherwise."
    },
    "params": [
      {
        "name": "command",
        "type": "char[]",
        "default": null,
        "description": "Command to find."
      }
    ],
    "full_declaration": "stock bool CommandExists(const char[] command) { \treturn (GetCommandFlags(command) != INVALID_FCVAR_FLAGS);"
  },
  {
    "name": "OnClientSayCommand",
    "type": "forward",
    "source_file": "console.inc",
    "return_type": "Action",
    "comment": "Global listener for the chat commands.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "command",
          "description": "Command name."
        },
        {
          "name": "sArgs",
          "description": "Chat argument string."
        }
      ],
      "error": [],
      "note": [],
      "return": "An Action value. Returning Plugin_Handled bypasses the game function call. Returning Plugin_Stop bypasses the post hook as well as the game function."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "command",
        "type": "char[]",
        "default": null,
        "description": "Command name."
      },
      {
        "name": "sArgs",
        "type": "char[]",
        "default": null,
        "description": "Chat argument string."
      }
    ],
    "full_declaration": "forward Action OnClientSayCommand(int client, const char[] command, const char[] sArgs);"
  },
  {
    "name": "OnClientSayCommand_Post",
    "type": "forward",
    "source_file": "console.inc",
    "return_type": "void",
    "comment": "Global post listener for the chat commands.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "command",
          "description": "Command name."
        },
        {
          "name": "sArgs",
          "description": "Chat argument string."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "command",
        "type": "char[]",
        "default": null,
        "description": "Command name."
      },
      {
        "name": "sArgs",
        "type": "char[]",
        "default": null,
        "description": "Chat argument string."
      }
    ],
    "full_declaration": "forward void OnClientSayCommand_Post(int client, const char[] command, const char[] sArgs);"
  },
  {
    "name": "ConVarChanged",
    "type": "typedef",
    "source_file": "convars.inc",
    "return_type": "void",
    "comment": "Called when a console variable's value is changed.",
    "tags": {
      "param": [
        {
          "name": "convar",
          "description": "Handle to the convar that was changed."
        },
        {
          "name": "oldValue",
          "description": "String containing the value of the convar before it was changed."
        },
        {
          "name": "newValue",
          "description": "String containing the new value of the convar."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "convar",
        "type": "ConVar",
        "default": null,
        "description": "Handle to the convar that was changed."
      },
      {
        "name": "oldValue",
        "type": "char[]",
        "default": null,
        "description": "String containing the value of the convar before it was changed."
      },
      {
        "name": "newValue",
        "type": "char[]",
        "default": null,
        "description": "String containing the new value of the convar."
      }
    ],
    "full_declaration": "typedef ConVarChanged = function void (ConVar convar, const char[] oldValue, const char[] newValue);"
  },
  {
    "name": "CreateConVar",
    "type": "native",
    "source_file": "convars.inc",
    "return_type": "ConVar",
    "comment": "Creates a new console variable.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Name of new convar."
        },
        {
          "name": "defaultValue",
          "description": "String containing the default value of new convar."
        },
        {
          "name": "description",
          "description": "Optional description of the convar."
        },
        {
          "name": "flags",
          "description": "Optional bitstring of flags determining how the convar should be handled. See FCVAR_* constants for more details."
        },
        {
          "name": "hasMin",
          "description": "Optional boolean that determines if the convar has a minimum value."
        },
        {
          "name": "min",
          "description": "Minimum floating point value that the convar can have if hasMin is true."
        },
        {
          "name": "hasMax",
          "description": "Optional boolean that determines if the convar has a maximum value."
        },
        {
          "name": "max",
          "description": "Maximum floating point value that the convar can have if hasMax is true."
        }
      ],
      "error": [
        "Convar name is blank or is the same as an existing console command."
      ],
      "note": [],
      "return": "A handle to the newly created convar. If the convar already exists, a handle to it will still be returned."
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Name of new convar."
      },
      {
        "name": "defaultValue",
        "type": "char[]",
        "default": null,
        "description": "String containing the default value of new convar."
      },
      {
        "name": "description",
        "type": "char[]",
        "default": "",
        "description": "Optional description of the convar."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Optional bitstring of flags determining how the convar should be handled. See FCVAR_* constants for more details."
      },
      {
        "name": "hasMin",
        "type": "bool",
        "default": "",
        "description": "Optional boolean that determines if the convar has a minimum value."
      },
      {
        "name": "min",
        "type": "float",
        "default": "",
        "description": "Minimum floating point value that the convar can have if hasMin is true."
      },
      {
        "name": "hasMax",
        "type": "bool",
        "default": "",
        "description": "Optional boolean that determines if the convar has a maximum value."
      },
      {
        "name": "max",
        "type": "float",
        "default": "",
        "description": "Maximum floating point value that the convar can have if hasMax is true."
      }
    ],
    "full_declaration": "native ConVar CreateConVar( \tconst char[] name, \tconst char[] defaultValue, \tconst char[] description=\"\", \tint flags=0, \tbool hasMin=false, float min=0.0, \tbool hasMax=false, float max=0.0);"
  },
  {
    "name": "FindConVar",
    "type": "native",
    "source_file": "convars.inc",
    "return_type": "ConVar",
    "comment": "Searches for a console variable.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Name of convar to find."
        }
      ],
      "error": [],
      "note": [],
      "return": "A ConVar object if found; null otherwise."
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Name of convar to find."
      }
    ],
    "full_declaration": "native ConVar FindConVar(const char[] name);"
  },
  {
    "name": "HookConVarChange",
    "type": "native",
    "source_file": "convars.inc",
    "return_type": "void",
    "comment": "Creates a hook for when a console variable's value is changed.",
    "tags": {
      "param": [
        {
          "name": "convar",
          "description": "Handle to the convar."
        },
        {
          "name": "callback",
          "description": "An OnConVarChanged function pointer."
        }
      ],
      "error": [
        "Invalid or corrupt Handle or invalid callback function."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "convar",
        "type": "Handle",
        "default": null,
        "description": "Handle to the convar."
      },
      {
        "name": "callback",
        "type": "ConVarChanged",
        "default": null,
        "description": "An OnConVarChanged function pointer."
      }
    ],
    "full_declaration": "native void HookConVarChange(Handle convar, ConVarChanged callback);"
  },
  {
    "name": "UnhookConVarChange",
    "type": "native",
    "source_file": "convars.inc",
    "return_type": "void",
    "comment": "Removes a hook for when a console variable's value is changed.",
    "tags": {
      "param": [
        {
          "name": "convar",
          "description": "Handle to the convar."
        },
        {
          "name": "callback",
          "description": "An OnConVarChanged function pointer."
        }
      ],
      "error": [
        "Invalid or corrupt Handle, invalid callback function, or no active hook on convar."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "convar",
        "type": "Handle",
        "default": null,
        "description": "Handle to the convar."
      },
      {
        "name": "callback",
        "type": "ConVarChanged",
        "default": null,
        "description": "An OnConVarChanged function pointer."
      }
    ],
    "full_declaration": "native void UnhookConVarChange(Handle convar, ConVarChanged callback);"
  },
  {
    "name": "GetConVarBool",
    "type": "native",
    "source_file": "convars.inc",
    "return_type": "bool",
    "comment": "Returns the boolean value of a console variable.",
    "tags": {
      "param": [
        {
          "name": "convar",
          "description": "Handle to the convar."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": "The boolean value of the convar."
    },
    "params": [
      {
        "name": "convar",
        "type": "Handle",
        "default": null,
        "description": "Handle to the convar."
      }
    ],
    "full_declaration": "native bool GetConVarBool(Handle convar);"
  },
  {
    "name": "SetConVarBool",
    "type": "native",
    "source_file": "convars.inc",
    "return_type": "void",
    "comment": "Sets the boolean value of a console variable.\n\nNote: The replicate and notify params are only relevant for the original, Dark Messiah, and\nEpisode 1 engines. Newer engines automatically do these things when the convar value is changed.",
    "tags": {
      "param": [
        {
          "name": "convar",
          "description": "Handle to the convar."
        },
        {
          "name": "value",
          "description": "New boolean value."
        },
        {
          "name": "replicate",
          "description": "If set to true, the new convar value will be set on all clients. This will only work if the convar has the FCVAR_REPLICATED flag and actually exists on clients."
        },
        {
          "name": "notify",
          "description": "If set to true, clients will be notified that the convar has changed. This will only work if the convar has the FCVAR_NOTIFY flag."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "convar",
        "type": "Handle",
        "default": null,
        "description": "Handle to the convar."
      },
      {
        "name": "value",
        "type": "bool",
        "default": null,
        "description": "New boolean value."
      },
      {
        "name": "replicate",
        "type": "bool",
        "default": "",
        "description": "If set to true, the new convar value will be set on all clients. This will only work if the convar has the FCVAR_REPLICATED flag and actually exists on clients."
      },
      {
        "name": "notify",
        "type": "bool",
        "default": "",
        "description": "If set to true, clients will be notified that the convar has changed. This will only work if the convar has the FCVAR_NOTIFY flag."
      }
    ],
    "full_declaration": "native void SetConVarBool(Handle convar, bool value, bool replicate=false, bool notify=false);"
  },
  {
    "name": "GetConVarInt",
    "type": "native",
    "source_file": "convars.inc",
    "return_type": "int",
    "comment": "Returns the integer value of a console variable.",
    "tags": {
      "param": [
        {
          "name": "convar",
          "description": "Handle to the convar."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": "The integer value of the convar."
    },
    "params": [
      {
        "name": "convar",
        "type": "Handle",
        "default": null,
        "description": "Handle to the convar."
      }
    ],
    "full_declaration": "native int GetConVarInt(Handle convar);"
  },
  {
    "name": "SetConVarInt",
    "type": "native",
    "source_file": "convars.inc",
    "return_type": "void",
    "comment": "Sets the integer value of a console variable.\n\nNote: The replicate and notify params are only relevant for the original, Dark Messiah, and\nEpisode 1 engines. Newer engines automatically do these things when the convar value is changed.",
    "tags": {
      "param": [
        {
          "name": "convar",
          "description": "Handle to the convar."
        },
        {
          "name": "value",
          "description": "New integer value."
        },
        {
          "name": "replicate",
          "description": "If set to true, the new convar value will be set on all clients. This will only work if the convar has the FCVAR_REPLICATED flag and actually exists on clients."
        },
        {
          "name": "notify",
          "description": "If set to true, clients will be notified that the convar has changed. This will only work if the convar has the FCVAR_NOTIFY flag."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "convar",
        "type": "Handle",
        "default": null,
        "description": "Handle to the convar."
      },
      {
        "name": "value",
        "type": "int",
        "default": null,
        "description": "New integer value."
      },
      {
        "name": "replicate",
        "type": "bool",
        "default": "",
        "description": "If set to true, the new convar value will be set on all clients. This will only work if the convar has the FCVAR_REPLICATED flag and actually exists on clients."
      },
      {
        "name": "notify",
        "type": "bool",
        "default": "",
        "description": "If set to true, clients will be notified that the convar has changed. This will only work if the convar has the FCVAR_NOTIFY flag."
      }
    ],
    "full_declaration": "native void SetConVarInt(Handle convar, int value, bool replicate=false, bool notify=false);"
  },
  {
    "name": "GetConVarFloat",
    "type": "native",
    "source_file": "convars.inc",
    "return_type": "float",
    "comment": "Returns the floating point value of a console variable.",
    "tags": {
      "param": [
        {
          "name": "convar",
          "description": "Handle to the convar."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": "The floating point value of the convar."
    },
    "params": [
      {
        "name": "convar",
        "type": "Handle",
        "default": null,
        "description": "Handle to the convar."
      }
    ],
    "full_declaration": "native float GetConVarFloat(Handle convar);"
  },
  {
    "name": "SetConVarFloat",
    "type": "native",
    "source_file": "convars.inc",
    "return_type": "void",
    "comment": "Sets the floating point value of a console variable.\n\nNote: The replicate and notify params are only relevant for the original, Dark Messiah, and\nEpisode 1 engines. Newer engines automatically do these things when the convar value is changed.",
    "tags": {
      "param": [
        {
          "name": "convar",
          "description": "Handle to the convar."
        },
        {
          "name": "value",
          "description": "New floating point value."
        },
        {
          "name": "replicate",
          "description": "If set to true, the new convar value will be set on all clients. This will only work if the convar has the FCVAR_REPLICATED flag and actually exists on clients."
        },
        {
          "name": "notify",
          "description": "If set to true, clients will be notified that the convar has changed. This will only work if the convar has the FCVAR_NOTIFY flag."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "convar",
        "type": "Handle",
        "default": null,
        "description": "Handle to the convar."
      },
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "New floating point value."
      },
      {
        "name": "replicate",
        "type": "bool",
        "default": "",
        "description": "If set to true, the new convar value will be set on all clients. This will only work if the convar has the FCVAR_REPLICATED flag and actually exists on clients."
      },
      {
        "name": "notify",
        "type": "bool",
        "default": "",
        "description": "If set to true, clients will be notified that the convar has changed. This will only work if the convar has the FCVAR_NOTIFY flag."
      }
    ],
    "full_declaration": "native void SetConVarFloat(Handle convar, float value, bool replicate=false, bool notify=false);"
  },
  {
    "name": "GetConVarString",
    "type": "native",
    "source_file": "convars.inc",
    "return_type": "void",
    "comment": "Retrieves the string value of a console variable.",
    "tags": {
      "param": [
        {
          "name": "convar",
          "description": "Handle to the convar."
        },
        {
          "name": "value",
          "description": "Buffer to store the value of the convar."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of string buffer."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "convar",
        "type": "Handle",
        "default": null,
        "description": "Handle to the convar."
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the value of the convar."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of string buffer."
      }
    ],
    "full_declaration": "native void GetConVarString(Handle convar, char[] value, int maxlength);"
  },
  {
    "name": "SetConVarString",
    "type": "native",
    "source_file": "convars.inc",
    "return_type": "void",
    "comment": "Sets the string value of a console variable.\n\nNote: The replicate and notify params are only relevant for the original, Dark Messiah, and\nEpisode 1 engines. Newer engines automatically do these things when the convar value is changed.",
    "tags": {
      "param": [
        {
          "name": "convar",
          "description": "Handle to the convar."
        },
        {
          "name": "value",
          "description": "New string value."
        },
        {
          "name": "replicate",
          "description": "If set to true, the new convar value will be set on all clients. This will only work if the convar has the FCVAR_REPLICATED flag and actually exists on clients."
        },
        {
          "name": "notify",
          "description": "If set to true, clients will be notified that the convar has changed. This will only work if the convar has the FCVAR_NOTIFY flag."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "convar",
        "type": "Handle",
        "default": null,
        "description": "Handle to the convar."
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "New string value."
      },
      {
        "name": "replicate",
        "type": "bool",
        "default": "",
        "description": "If set to true, the new convar value will be set on all clients. This will only work if the convar has the FCVAR_REPLICATED flag and actually exists on clients."
      },
      {
        "name": "notify",
        "type": "bool",
        "default": "",
        "description": "If set to true, clients will be notified that the convar has changed. This will only work if the convar has the FCVAR_NOTIFY flag."
      }
    ],
    "full_declaration": "native void SetConVarString(Handle convar, const char[] value, bool replicate=false, bool notify=false);"
  },
  {
    "name": "ResetConVar",
    "type": "native",
    "source_file": "convars.inc",
    "return_type": "void",
    "comment": "Resets the console variable to its default value.\n\nNote: The replicate and notify params are only relevant for the original, Dark Messiah, and\nEpisode 1 engines. Newer engines automatically do these things when the convar value is changed.",
    "tags": {
      "param": [
        {
          "name": "convar",
          "description": "Handle to the convar."
        },
        {
          "name": "replicate",
          "description": "If set to true, the new convar value will be set on all clients. This will only work if the convar has the FCVAR_REPLICATED flag and actually exists on clients."
        },
        {
          "name": "notify",
          "description": "If set to true, clients will be notified that the convar has changed. This will only work if the convar has the FCVAR_NOTIFY flag."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "convar",
        "type": "Handle",
        "default": null,
        "description": "Handle to the convar."
      },
      {
        "name": "replicate",
        "type": "bool",
        "default": "",
        "description": "If set to true, the new convar value will be set on all clients. This will only work if the convar has the FCVAR_REPLICATED flag and actually exists on clients."
      },
      {
        "name": "notify",
        "type": "bool",
        "default": "",
        "description": "If set to true, clients will be notified that the convar has changed. This will only work if the convar has the FCVAR_NOTIFY flag."
      }
    ],
    "full_declaration": "native void ResetConVar(Handle convar, bool replicate=false, bool notify=false);"
  },
  {
    "name": "GetConVarDefault",
    "type": "native",
    "source_file": "convars.inc",
    "return_type": "int",
    "comment": "Retrieves the default string value of a console variable.",
    "tags": {
      "param": [
        {
          "name": "convar",
          "description": "Handle to the convar."
        },
        {
          "name": "value",
          "description": "Buffer to store the default value of the convar."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of string buffer."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": "Number of bytes written to the buffer (UTF-8 safe)."
    },
    "params": [
      {
        "name": "convar",
        "type": "Handle",
        "default": null,
        "description": "Handle to the convar."
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the default value of the convar."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of string buffer."
      }
    ],
    "full_declaration": "native int GetConVarDefault(Handle convar, char[] value, int maxlength);"
  },
  {
    "name": "GetConVarFlags",
    "type": "native",
    "source_file": "convars.inc",
    "return_type": "int",
    "comment": "Returns the bitstring of flags on a console variable.",
    "tags": {
      "param": [
        {
          "name": "convar",
          "description": "Handle to the convar."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": "A bitstring containing the FCVAR_* flags that are enabled."
    },
    "params": [
      {
        "name": "convar",
        "type": "Handle",
        "default": null,
        "description": "Handle to the convar."
      }
    ],
    "full_declaration": "native int GetConVarFlags(Handle convar);"
  },
  {
    "name": "SetConVarFlags",
    "type": "native",
    "source_file": "convars.inc",
    "return_type": "void",
    "comment": "Sets the bitstring of flags on a console variable.",
    "tags": {
      "param": [
        {
          "name": "convar",
          "description": "Handle to the convar."
        },
        {
          "name": "flags",
          "description": "A bitstring containing the FCVAR_* flags to enable."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "convar",
        "type": "Handle",
        "default": null,
        "description": "Handle to the convar."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "A bitstring containing the FCVAR_* flags to enable."
      }
    ],
    "full_declaration": "native void SetConVarFlags(Handle convar, int flags);"
  },
  {
    "name": "GetConVarBounds",
    "type": "native",
    "source_file": "convars.inc",
    "return_type": "bool",
    "comment": "Retrieves the specified bound of a console variable.",
    "tags": {
      "param": [
        {
          "name": "convar",
          "description": "Handle to the convar."
        },
        {
          "name": "type",
          "description": "Type of bound to retrieve, ConVarBound_Lower or ConVarBound_Upper."
        },
        {
          "name": "value",
          "description": "By-reference cell to store the specified floating point bound value."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": "True if the convar has the specified bound set, false otherwise."
    },
    "params": [
      {
        "name": "convar",
        "type": "Handle",
        "default": null,
        "description": "Handle to the convar."
      },
      {
        "name": "type",
        "type": "ConVarBounds",
        "default": null,
        "description": "Type of bound to retrieve, ConVarBound_Lower or ConVarBound_Upper."
      },
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "By-reference cell to store the specified floating point bound value."
      }
    ],
    "full_declaration": "native bool GetConVarBounds(Handle convar, ConVarBounds type, float &value);"
  },
  {
    "name": "SetConVarBounds",
    "type": "native",
    "source_file": "convars.inc",
    "return_type": "void",
    "comment": "Sets the specified bound of a console variable.",
    "tags": {
      "param": [
        {
          "name": "convar",
          "description": "Handle to the convar."
        },
        {
          "name": "type",
          "description": "Type of bound to set, ConVarBound_Lower or ConVarBound_Upper"
        },
        {
          "name": "set",
          "description": "If set to true, convar will use specified bound. If false, bound will be removed."
        },
        {
          "name": "value",
          "description": "Floating point value to use as the specified bound."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "convar",
        "type": "Handle",
        "default": null,
        "description": "Handle to the convar."
      },
      {
        "name": "type",
        "type": "ConVarBounds",
        "default": null,
        "description": "Type of bound to set, ConVarBound_Lower or ConVarBound_Upper"
      },
      {
        "name": "set",
        "type": "bool",
        "default": null,
        "description": "If set to true, convar will use specified bound. If false, bound will be removed."
      },
      {
        "name": "value",
        "type": "float",
        "default": "",
        "description": "Floating point value to use as the specified bound."
      }
    ],
    "full_declaration": "native void SetConVarBounds(Handle convar, ConVarBounds type, bool set, float value=0.0);"
  },
  {
    "name": "GetConVarName",
    "type": "native",
    "source_file": "convars.inc",
    "return_type": "void",
    "comment": "Retrieves the name of a console variable.",
    "tags": {
      "param": [
        {
          "name": "convar",
          "description": "Handle to the convar."
        },
        {
          "name": "name",
          "description": "Buffer to store the name of the convar."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of string buffer."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "convar",
        "type": "Handle",
        "default": null,
        "description": "Handle to the convar."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the name of the convar."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of string buffer."
      }
    ],
    "full_declaration": "native void GetConVarName(Handle convar, char[] name, int maxlength);"
  },
  {
    "name": "SendConVarValue",
    "type": "native",
    "source_file": "convars.inc",
    "return_type": "bool",
    "comment": "Replicates a convar value to a specific client. This does not change the actual convar value.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index"
        },
        {
          "name": "convar",
          "description": "ConVar handle"
        },
        {
          "name": "value",
          "description": "String value to send"
        }
      ],
      "error": [
        "Invalid client index, client not in game, or client is fake"
      ],
      "note": [],
      "return": "True on success, false on failure"
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index"
      },
      {
        "name": "convar",
        "type": "Handle",
        "default": null,
        "description": "ConVar handle"
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "String value to send"
      }
    ],
    "full_declaration": "native bool SendConVarValue(int client, Handle convar, const char[] value);"
  },
  {
    "name": "QueryClientConVar",
    "type": "native",
    "source_file": "convars.inc",
    "return_type": "QueryCookie",
    "comment": "Starts a query to retrieve the value of a client's console variable.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player index."
        },
        {
          "name": "cvarName",
          "description": "Name of client convar to query."
        },
        {
          "name": "callback",
          "description": "A function to use as a callback when the query has finished."
        },
        {
          "name": "value",
          "description": "Optional value to pass to the callback function."
        }
      ],
      "error": [],
      "note": [],
      "return": "A cookie that uniquely identifies the query. Returns QUERYCOOKIE_FAILED on failure, such as when used on a bot."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player index."
      },
      {
        "name": "cvarName",
        "type": "char[]",
        "default": null,
        "description": "Name of client convar to query."
      },
      {
        "name": "callback",
        "type": "ConVarQueryFinished",
        "default": null,
        "description": "A function to use as a callback when the query has finished."
      },
      {
        "name": "value",
        "type": "any",
        "default": "",
        "description": "Optional value to pass to the callback function."
      }
    ],
    "full_declaration": "native QueryCookie QueryClientConVar(int client, const char[] cvarName, ConVarQueryFinished callback, any value=0);"
  },
  {
    "name": "IsValidConVarChar",
    "type": "stock",
    "source_file": "convars.inc",
    "return_type": "bool",
    "comment": "Returns true if the supplied character is valid in a ConVar name.",
    "tags": {
      "param": [
        {
          "name": "c",
          "description": "Character to validate."
        }
      ],
      "error": [],
      "note": [],
      "return": "True is valid for ConVars, false otherwise"
    },
    "params": [
      {
        "name": "c",
        "type": "int",
        "default": null,
        "description": "Character to validate."
      }
    ],
    "full_declaration": "stock bool IsValidConVarChar(int c) { \treturn (c == '_' || IsCharAlpha(c) || IsCharNumeric(c));"
  },
  {
    "name": "IsNullVector",
    "type": "native",
    "source_file": "core.inc",
    "return_type": "bool",
    "comment": "Check if the given vector is the NULL_VECTOR.",
    "tags": {
      "param": [
        {
          "name": "vec",
          "description": "The vector to test."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if NULL_VECTOR, false otherwise."
    },
    "params": [
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "The vector to test."
      }
    ],
    "full_declaration": "native bool IsNullVector(const float vec[3]);"
  },
  {
    "name": "IsNullString",
    "type": "native",
    "source_file": "core.inc",
    "return_type": "bool",
    "comment": "Check if the given string is the NULL_STRING.",
    "tags": {
      "param": [
        {
          "name": "str",
          "description": "The string to test."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if NULL_STRING, false otherwise."
    },
    "params": [
      {
        "name": "str",
        "type": "char[]",
        "default": null,
        "description": "The string to test."
      }
    ],
    "full_declaration": "native bool IsNullString(const char[] str);"
  },
  {
    "name": "VerifyCoreVersion",
    "type": "native",
    "source_file": "core.inc",
    "return_type": "int",
    "comment": "Horrible compatibility shim.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [],
    "full_declaration": "native int VerifyCoreVersion();"
  },
  {
    "name": "MarkNativeAsOptional",
    "type": "native",
    "source_file": "core.inc",
    "return_type": "void",
    "comment": "Sets a native as optional, such that if it is unloaded, removed,\nor otherwise non-existent, the plugin will still work.  Calling\nremoved natives results in a run-time error.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Native name."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Native name."
      }
    ],
    "full_declaration": "native void MarkNativeAsOptional(const char[] name);"
  },
  {
    "name": "CS_OnBuyCommand",
    "type": "forward",
    "source_file": "cstrike.inc",
    "return_type": "Action",
    "comment": "Called when a player attempts to purchase an item.\nReturn Plugin_Continue to allow the purchase or return a\nhigher action to deny.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index"
        },
        {
          "name": "weapon",
          "description": "User input for weapon name"
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index"
      },
      {
        "name": "weapon",
        "type": "char[]",
        "default": null,
        "description": "User input for weapon name"
      }
    ],
    "full_declaration": "forward Action CS_OnBuyCommand(int client, const char[] weapon);"
  },
  {
    "name": "CS_OnCSWeaponDrop",
    "type": "forward",
    "source_file": "cstrike.inc",
    "return_type": "Action",
    "comment": "Called when CSWeaponDrop is called\nReturn Plugin_Continue to allow the call or return a\nhigher action to block.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index"
        },
        {
          "name": "weaponIndex",
          "description": "Weapon index"
        },
        {
          "name": "donated",
          "description": "Was weapon donated (Bought from a buy menu while ctrl was pressed) (Note: This param is for CS:GO only, will be false on other games)"
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index"
      },
      {
        "name": "weaponIndex",
        "type": "int",
        "default": null,
        "description": "Weapon index"
      },
      {
        "name": "donated",
        "type": "bool",
        "default": null,
        "description": "Was weapon donated (Bought from a buy menu while ctrl was pressed) (Note: This param is for CS:GO only, will be false on other games)"
      }
    ],
    "full_declaration": "forward Action CS_OnCSWeaponDrop(int client, int weaponIndex, bool donated);"
  },
  {
    "name": "CS_OnGetWeaponPrice",
    "type": "forward",
    "source_file": "cstrike.inc",
    "return_type": "Action",
    "comment": "Called when game retrieves a weapon's price for a player.\nReturn Plugin_Continue to use default value or return a higher\naction to use a newly-set price.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index"
        },
        {
          "name": "weapon",
          "description": "Weapon classname"
        },
        {
          "name": "price",
          "description": "Buffer param for the price of the weapon"
        }
      ],
      "error": [],
      "note": [
        "This can be called multiple times per weapon purchase",
        "Not all \"weapons\" call GetWeaponPrice. Example: c4, knife, vest, vest helmet, night vision."
      ],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index"
      },
      {
        "name": "weapon",
        "type": "char[]",
        "default": null,
        "description": "Weapon classname"
      },
      {
        "name": "price",
        "type": "int",
        "default": null,
        "description": "Buffer param for the price of the weapon"
      }
    ],
    "full_declaration": "forward Action CS_OnGetWeaponPrice(int client, const char[] weapon, int &price);"
  },
  {
    "name": "CS_OnTerminateRound",
    "type": "forward",
    "source_file": "cstrike.inc",
    "return_type": "Action",
    "comment": "Called when TerminateRound is called.\nReturn Plugin_Continue to ignore, return Plugin_Changed to continue,\nusing the given delay and reason, or return Plugin_Handled or a higher\naction to block TerminateRound from firing.",
    "tags": {
      "param": [
        {
          "name": "delay",
          "description": "Time (in seconds) until new round starts"
        },
        {
          "name": "reason",
          "description": "Reason for round end"
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "delay",
        "type": "float",
        "default": null,
        "description": "Time (in seconds) until new round starts"
      },
      {
        "name": "reason",
        "type": "CSRoundEndReason",
        "default": null,
        "description": "Reason for round end"
      }
    ],
    "full_declaration": "forward Action CS_OnTerminateRound(float &delay, CSRoundEndReason &reason);"
  },
  {
    "name": "CS_RespawnPlayer",
    "type": "native",
    "source_file": "cstrike.inc",
    "return_type": "void",
    "comment": "Respawns a player.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        }
      ],
      "error": [
        "Invalid client index, client not in game."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      }
    ],
    "full_declaration": "native void CS_RespawnPlayer(int client);"
  },
  {
    "name": "CS_SwitchTeam",
    "type": "native",
    "source_file": "cstrike.inc",
    "return_type": "void",
    "comment": "Switches the player's team.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        },
        {
          "name": "team",
          "description": "Team index."
        }
      ],
      "error": [
        "Invalid client index, client not in game."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      },
      {
        "name": "team",
        "type": "int",
        "default": null,
        "description": "Team index."
      }
    ],
    "full_declaration": "native void CS_SwitchTeam(int client, int team);"
  },
  {
    "name": "CS_DropWeapon",
    "type": "native",
    "source_file": "cstrike.inc",
    "return_type": "void",
    "comment": "Forces a player to drop or toss their weapon",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        },
        {
          "name": "weaponIndex",
          "description": "Index of weapon to drop."
        },
        {
          "name": "toss",
          "description": "True to toss weapon (with velocity) or false to just drop weapon"
        },
        {
          "name": "blockhook",
          "description": "Set to true to stop the corresponding CS_OnCSWeaponDrop"
        }
      ],
      "error": [
        "Invalid client index, client not in game, or invalid weapon index."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      },
      {
        "name": "weaponIndex",
        "type": "int",
        "default": null,
        "description": "Index of weapon to drop."
      },
      {
        "name": "toss",
        "type": "bool",
        "default": null,
        "description": "True to toss weapon (with velocity) or false to just drop weapon"
      },
      {
        "name": "blockhook",
        "type": "bool",
        "default": "",
        "description": "Set to true to stop the corresponding CS_OnCSWeaponDrop"
      }
    ],
    "full_declaration": "native void CS_DropWeapon(int client, int weaponIndex, bool toss, bool blockhook = false);"
  },
  {
    "name": "CS_TerminateRound",
    "type": "native",
    "source_file": "cstrike.inc",
    "return_type": "void",
    "comment": "Forces round to end with a reason",
    "tags": {
      "param": [
        {
          "name": "delay",
          "description": "Time (in seconds) to delay before new round starts"
        },
        {
          "name": "reason",
          "description": "Reason for the round ending"
        },
        {
          "name": "blockhook",
          "description": "Set to true to stop the corresponding CS_OnTerminateRound forward from being called."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "delay",
        "type": "float",
        "default": null,
        "description": "Time (in seconds) to delay before new round starts"
      },
      {
        "name": "reason",
        "type": "CSRoundEndReason",
        "default": null,
        "description": "Reason for the round ending"
      },
      {
        "name": "blockhook",
        "type": "bool",
        "default": "",
        "description": "Set to true to stop the corresponding CS_OnTerminateRound forward from being called."
      }
    ],
    "full_declaration": "native void CS_TerminateRound(float delay, CSRoundEndReason reason, bool blockhook = false);"
  },
  {
    "name": "CS_GetTranslatedWeaponAlias",
    "type": "native",
    "source_file": "cstrike.inc",
    "return_type": "void",
    "comment": "Gets a weapon name from a weapon alias",
    "tags": {
      "param": [
        {
          "name": "alias",
          "description": "Weapons alias to get weapon name for."
        },
        {
          "name": "weapon",
          "description": "Buffer to store weapons name"
        },
        {
          "name": "size",
          "description": "Size of buffer to store the weapons name."
        }
      ],
      "error": [],
      "note": [
        "Will set the buffer to the original alias if it is not an alias to a weapon."
      ],
      "return": ""
    },
    "params": [
      {
        "name": "alias",
        "type": "char[]",
        "default": null,
        "description": "Weapons alias to get weapon name for."
      },
      {
        "name": "weapon",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store weapons name"
      },
      {
        "name": "size",
        "type": "int",
        "default": null,
        "description": "Size of buffer to store the weapons name."
      }
    ],
    "full_declaration": "native void CS_GetTranslatedWeaponAlias(const char[] alias, char[] weapon, int size);"
  },
  {
    "name": "CS_GetWeaponPrice",
    "type": "native",
    "source_file": "cstrike.inc",
    "return_type": "int",
    "comment": "Gets a weapon's price",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client to check weapon price for."
        },
        {
          "name": "id",
          "description": "Weapon id for the weapon to check"
        },
        {
          "name": "defaultprice",
          "description": "Set to true to get defaultprice."
        }
      ],
      "error": [
        "Invalid client, failing to get weapon info, or failing to get price offset."
      ],
      "note": [
        "c4, knife and shield will always return 0. vest, vest helmet and night vision will always return default price."
      ],
      "return": "Returns price of the weapon (even if modified)"
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client to check weapon price for."
      },
      {
        "name": "id",
        "type": "CSWeaponID",
        "default": null,
        "description": "Weapon id for the weapon to check"
      },
      {
        "name": "defaultprice",
        "type": "bool",
        "default": "",
        "description": "Set to true to get defaultprice."
      }
    ],
    "full_declaration": "native int CS_GetWeaponPrice(int client, CSWeaponID id, bool defaultprice = false);"
  },
  {
    "name": "CS_GetClientClanTag",
    "type": "native",
    "source_file": "cstrike.inc",
    "return_type": "int",
    "comment": "Gets a clients clan tag",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index to get clan tag for."
        },
        {
          "name": "buffer",
          "description": "Buffer to store clients clan tag in."
        },
        {
          "name": "size",
          "description": "Size of the buffer."
        }
      ],
      "error": [
        "Invalid client."
      ],
      "note": [],
      "return": "Number of non-null bytes written."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index to get clan tag for."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store clients clan tag in."
      },
      {
        "name": "size",
        "type": "int",
        "default": null,
        "description": "Size of the buffer."
      }
    ],
    "full_declaration": "native int CS_GetClientClanTag(int client, char[] buffer, int size);"
  },
  {
    "name": "CS_SetClientClanTag",
    "type": "native",
    "source_file": "cstrike.inc",
    "return_type": "void",
    "comment": "Sets a clients clan tag",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index to set clan tag for."
        },
        {
          "name": "tag",
          "description": "Tag to set clients clan tag as."
        }
      ],
      "error": [
        "Invalid client."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index to set clan tag for."
      },
      {
        "name": "tag",
        "type": "char[]",
        "default": null,
        "description": "Tag to set clients clan tag as."
      }
    ],
    "full_declaration": "native void CS_SetClientClanTag(int client, const char[] tag);"
  },
  {
    "name": "CS_GetTeamScore",
    "type": "native",
    "source_file": "cstrike.inc",
    "return_type": "int",
    "comment": "Gets a team's score",
    "tags": {
      "param": [
        {
          "name": "team",
          "description": "Team index to get score for."
        }
      ],
      "error": [
        "Invalid team index."
      ],
      "note": [],
      "return": "Returns the internal team score."
    },
    "params": [
      {
        "name": "team",
        "type": "int",
        "default": null,
        "description": "Team index to get score for."
      }
    ],
    "full_declaration": "native int CS_GetTeamScore(int team);"
  },
  {
    "name": "CS_SetTeamScore",
    "type": "native",
    "source_file": "cstrike.inc",
    "return_type": "void",
    "comment": "Sets a team's score",
    "tags": {
      "param": [
        {
          "name": "team",
          "description": "Team index to set score for."
        },
        {
          "name": "value",
          "description": "Value to set teams score as."
        }
      ],
      "error": [
        "Invalid team index."
      ],
      "note": [
        "This will update the scoreboard only after the scoreboard update function is called. Use SetTeamScore plus this to update the scoreboard instantly and save values correctly."
      ],
      "return": ""
    },
    "params": [
      {
        "name": "team",
        "type": "int",
        "default": null,
        "description": "Team index to set score for."
      },
      {
        "name": "value",
        "type": "int",
        "default": null,
        "description": "Value to set teams score as."
      }
    ],
    "full_declaration": "native void CS_SetTeamScore(int team, int value);"
  },
  {
    "name": "CS_GetMVPCount",
    "type": "native",
    "source_file": "cstrike.inc",
    "return_type": "int",
    "comment": "Gets a client's mvp count",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index to get mvp count of."
        }
      ],
      "error": [
        "Invalid client."
      ],
      "note": [],
      "return": "Returns the client's internal MVP count."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index to get mvp count of."
      }
    ],
    "full_declaration": "native int CS_GetMVPCount(int client);"
  },
  {
    "name": "CS_SetMVPCount",
    "type": "native",
    "source_file": "cstrike.inc",
    "return_type": "void",
    "comment": "Sets a client's mvp count",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index to set mvp count for."
        },
        {
          "name": "value",
          "description": "Value to set client's mvp count as."
        }
      ],
      "error": [
        "Invalid client."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index to set mvp count for."
      },
      {
        "name": "value",
        "type": "int",
        "default": null,
        "description": "Value to set client's mvp count as."
      }
    ],
    "full_declaration": "native void CS_SetMVPCount(int client, int value);"
  },
  {
    "name": "CS_GetClientContributionScore",
    "type": "native",
    "source_file": "cstrike.inc",
    "return_type": "int",
    "comment": "Gets a client's contribution score (CS:GO only)",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index to get score of."
        }
      ],
      "error": [
        "Invalid client."
      ],
      "note": [],
      "return": "Returns the client's score."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index to get score of."
      }
    ],
    "full_declaration": "native int CS_GetClientContributionScore(int client);"
  },
  {
    "name": "CS_SetClientContributionScore",
    "type": "native",
    "source_file": "cstrike.inc",
    "return_type": "void",
    "comment": "Sets a client's contribution score (CS:GO only)",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index to set score for."
        },
        {
          "name": "value",
          "description": "Value to set client's score as."
        }
      ],
      "error": [
        "Invalid client."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index to set score for."
      },
      {
        "name": "value",
        "type": "int",
        "default": null,
        "description": "Value to set client's score as."
      }
    ],
    "full_declaration": "native void CS_SetClientContributionScore(int client, int value);"
  },
  {
    "name": "CS_GetClientAssists",
    "type": "native",
    "source_file": "cstrike.inc",
    "return_type": "int",
    "comment": "Gets a client's assists (CS:GO only)",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index to get assists of."
        }
      ],
      "error": [
        "Invalid client."
      ],
      "note": [],
      "return": "Returns the client's assists."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index to get assists of."
      }
    ],
    "full_declaration": "native int CS_GetClientAssists(int client);"
  },
  {
    "name": "CS_SetClientAssists",
    "type": "native",
    "source_file": "cstrike.inc",
    "return_type": "void",
    "comment": "Sets a client's assists (CS:GO only)",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index to set assists for."
        },
        {
          "name": "value",
          "description": "Value to set client's assists as."
        }
      ],
      "error": [
        "Invalid client."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index to set assists for."
      },
      {
        "name": "value",
        "type": "int",
        "default": null,
        "description": "Value to set client's assists as."
      }
    ],
    "full_declaration": "native void CS_SetClientAssists(int client, int value);"
  },
  {
    "name": "CS_AliasToWeaponID",
    "type": "native",
    "source_file": "cstrike.inc",
    "return_type": "CSWeaponID",
    "comment": "Gets a weaponID from a alias",
    "tags": {
      "param": [
        {
          "name": "alias",
          "description": "Weapon alias to attempt to get an id for."
        }
      ],
      "error": [],
      "note": [
        "For best results use CS_GetTranslatedWeaponAlias on the weapon name before passing it."
      ],
      "return": "Returns a weapon id or 0 if failed to find a match."
    },
    "params": [
      {
        "name": "alias",
        "type": "char[]",
        "default": null,
        "description": "Weapon alias to attempt to get an id for."
      }
    ],
    "full_declaration": "native CSWeaponID CS_AliasToWeaponID(const char[] alias);"
  },
  {
    "name": "CS_WeaponIDToAlias",
    "type": "native",
    "source_file": "cstrike.inc",
    "return_type": "int",
    "comment": "Gets a alias from a weaponID",
    "tags": {
      "param": [
        {
          "name": "weaponID",
          "description": "WeaponID to get alias for."
        },
        {
          "name": "destination",
          "description": "Destination string to hold the weapon alias."
        },
        {
          "name": "len",
          "description": "Length of the destination array."
        }
      ],
      "error": [],
      "note": [],
      "return": "Returns number of cells written."
    },
    "params": [
      {
        "name": "weaponID",
        "type": "CSWeaponID",
        "default": null,
        "description": "WeaponID to get alias for."
      },
      {
        "name": "destination",
        "type": "char[]",
        "default": null,
        "description": "Destination string to hold the weapon alias."
      },
      {
        "name": "len",
        "type": "int",
        "default": null,
        "description": "Length of the destination array."
      }
    ],
    "full_declaration": "native int CS_WeaponIDToAlias(CSWeaponID weaponID, char[] destination, int len);"
  },
  {
    "name": "CS_IsValidWeaponID",
    "type": "native",
    "source_file": "cstrike.inc",
    "return_type": "bool",
    "comment": "Returns weather a WeaponID is valid on the current mod (css or csgo)",
    "tags": {
      "param": [
        {
          "name": "weaponID",
          "description": "WeaponID to check"
        }
      ],
      "error": [],
      "note": [
        "This will return false always for CSWeapon_NONE. Should only be called after OnMapStart since weapon info isnt intialized before."
      ],
      "return": "Returns true if its a valid WeaponID false otherwise."
    },
    "params": [
      {
        "name": "id",
        "type": "CSWeaponID",
        "default": null,
        "description": ""
      }
    ],
    "full_declaration": "native bool CS_IsValidWeaponID(CSWeaponID id);"
  },
  {
    "name": "CS_UpdateClientModel",
    "type": "native",
    "source_file": "cstrike.inc",
    "return_type": "void",
    "comment": "Sets a player's model based on their current class",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        }
      ],
      "error": [
        "Invalid client index, client not in game."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      }
    ],
    "full_declaration": "native void CS_UpdateClientModel(int client);"
  },
  {
    "name": "CS_ItemDefIndexToID",
    "type": "native",
    "source_file": "cstrike.inc",
    "return_type": "CSWeaponID",
    "comment": "Returns a CSWeaponID equivalent based on the item definition index.",
    "tags": {
      "param": [
        {
          "name": "iDefIndex",
          "description": "Definition index to get the CSWeaponID value for."
        }
      ],
      "error": [
        "Invalid definition index."
      ],
      "note": [
        "In most cases the id will be the item definition index. Works for CS:GO ONLY."
      ],
      "return": "Returns CSWeaponID value for the definition index."
    },
    "params": [
      {
        "name": "iDefIndex",
        "type": "int",
        "default": null,
        "description": "Definition index to get the CSWeaponID value for."
      }
    ],
    "full_declaration": "native CSWeaponID CS_ItemDefIndexToID(int iDefIndex);"
  },
  {
    "name": "CS_WeaponIDToItemDefIndex",
    "type": "native",
    "source_file": "cstrike.inc",
    "return_type": "int",
    "comment": "Returns a item definition index equivalent based on the CSWeaponID.",
    "tags": {
      "param": [
        {
          "name": "id",
          "description": "CSWeaponID to get the item definition for."
        }
      ],
      "error": [
        "Invalid weapon id."
      ],
      "note": [
        "In most cases the item definition index will be the id. Works for CS:GO ONLY."
      ],
      "return": "Returns item definition index value for the weapon id."
    },
    "params": [
      {
        "name": "id",
        "type": "CSWeaponID",
        "default": null,
        "description": "CSWeaponID to get the item definition for."
      }
    ],
    "full_declaration": "native int CS_WeaponIDToItemDefIndex(CSWeaponID id);"
  },
  {
    "name": "CS_WeaponIDToLoadoutSlot",
    "type": "native",
    "source_file": "cstrike.inc",
    "return_type": "int",
    "comment": "Returns the loadout slot based on the CSWeaponID. (CS:GO only)",
    "tags": {
      "param": [
        {
          "name": "id",
          "description": "CSWeaponID to get the loadout slot for."
        }
      ],
      "error": [
        "Invalid weapon id."
      ],
      "note": [],
      "return": "Returns loadout slot value for the weapon id."
    },
    "params": [
      {
        "name": "id",
        "type": "CSWeaponID",
        "default": null,
        "description": "CSWeaponID to get the loadout slot for."
      }
    ],
    "full_declaration": "native int CS_WeaponIDToLoadoutSlot(CSWeaponID id);"
  },
  {
    "name": "__ext_cstrike_SetNTVOptional",
    "type": "public",
    "source_file": "cstrike.inc",
    "return_type": "void",
    "comment": "Do not edit below this line!",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [],
    "full_declaration": "public void __ext_cstrike_SetNTVOptional() { \tMarkNativeAsOptional(\"CS_RespawnPlayer\");"
  },
  {
    "name": "CreateDataPack",
    "type": "native",
    "source_file": "datapack.inc",
    "return_type": "DataPack",
    "comment": "Creates a new data pack.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "A Handle to the data pack.  Must be closed with CloseHandle()."
    },
    "params": [],
    "full_declaration": "native DataPack CreateDataPack();"
  },
  {
    "name": "WritePackCell",
    "type": "native",
    "source_file": "datapack.inc",
    "return_type": "void",
    "comment": "Packs a normal cell into a data pack.",
    "tags": {
      "param": [
        {
          "name": "pack",
          "description": "Handle to the data pack."
        },
        {
          "name": "cell",
          "description": "Cell to add."
        }
      ],
      "error": [
        "Invalid handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pack",
        "type": "Handle",
        "default": null,
        "description": "Handle to the data pack."
      },
      {
        "name": "cell",
        "type": "any",
        "default": null,
        "description": "Cell to add."
      }
    ],
    "full_declaration": "native void WritePackCell(Handle pack, any cell);"
  },
  {
    "name": "WritePackFloat",
    "type": "native",
    "source_file": "datapack.inc",
    "return_type": "void",
    "comment": "Packs a float into a data pack.",
    "tags": {
      "param": [
        {
          "name": "pack",
          "description": "Handle to the data pack."
        },
        {
          "name": "val",
          "description": "Float to add."
        }
      ],
      "error": [
        "Invalid handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pack",
        "type": "Handle",
        "default": null,
        "description": "Handle to the data pack."
      },
      {
        "name": "val",
        "type": "float",
        "default": null,
        "description": "Float to add."
      }
    ],
    "full_declaration": "native void WritePackFloat(Handle pack, float val);"
  },
  {
    "name": "WritePackString",
    "type": "native",
    "source_file": "datapack.inc",
    "return_type": "void",
    "comment": "Packs a string into a data pack.",
    "tags": {
      "param": [
        {
          "name": "pack",
          "description": "Handle to the data pack."
        },
        {
          "name": "str",
          "description": "String to add."
        }
      ],
      "error": [
        "Invalid handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pack",
        "type": "Handle",
        "default": null,
        "description": "Handle to the data pack."
      },
      {
        "name": "str",
        "type": "char[]",
        "default": null,
        "description": "String to add."
      }
    ],
    "full_declaration": "native void WritePackString(Handle pack, const char[] str);"
  },
  {
    "name": "WritePackFunction",
    "type": "native",
    "source_file": "datapack.inc",
    "return_type": "void",
    "comment": "Packs a function pointer into a data pack.",
    "tags": {
      "param": [
        {
          "name": "pack",
          "description": "Handle to the data pack."
        },
        {
          "name": "fktptr",
          "description": "Function pointer to add."
        }
      ],
      "error": [
        "Invalid handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pack",
        "type": "Handle",
        "default": null,
        "description": "Handle to the data pack."
      },
      {
        "name": "fktptr",
        "type": "Function",
        "default": null,
        "description": "Function pointer to add."
      }
    ],
    "full_declaration": "native void WritePackFunction(Handle pack, Function fktptr);"
  },
  {
    "name": "ReadPackCell",
    "type": "native",
    "source_file": "datapack.inc",
    "return_type": "any",
    "comment": "Reads a cell from a data pack.",
    "tags": {
      "param": [
        {
          "name": "pack",
          "description": "Handle to the data pack."
        }
      ],
      "error": [
        "Invalid handle, or bounds error."
      ],
      "note": [],
      "return": "Cell value."
    },
    "params": [
      {
        "name": "pack",
        "type": "Handle",
        "default": null,
        "description": "Handle to the data pack."
      }
    ],
    "full_declaration": "native any ReadPackCell(Handle pack);"
  },
  {
    "name": "ReadPackFloat",
    "type": "native",
    "source_file": "datapack.inc",
    "return_type": "float",
    "comment": "Reads a float from a data pack.",
    "tags": {
      "param": [
        {
          "name": "pack",
          "description": "Handle to the data pack."
        }
      ],
      "error": [
        "Invalid handle, or bounds error."
      ],
      "note": [],
      "return": "Float value."
    },
    "params": [
      {
        "name": "pack",
        "type": "Handle",
        "default": null,
        "description": "Handle to the data pack."
      }
    ],
    "full_declaration": "native float ReadPackFloat(Handle pack);"
  },
  {
    "name": "ReadPackString",
    "type": "native",
    "source_file": "datapack.inc",
    "return_type": "void",
    "comment": "Reads a string from a data pack.",
    "tags": {
      "param": [
        {
          "name": "pack",
          "description": "Handle to the data pack."
        },
        {
          "name": "buffer",
          "description": "Destination string buffer."
        },
        {
          "name": "maxlen",
          "description": "Maximum length of output string buffer."
        }
      ],
      "error": [
        "Invalid handle, or bounds error."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pack",
        "type": "Handle",
        "default": null,
        "description": "Handle to the data pack."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Destination string buffer."
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "Maximum length of output string buffer."
      }
    ],
    "full_declaration": "native void ReadPackString(Handle pack, char[] buffer, int maxlen);"
  },
  {
    "name": "ReadPackFunction",
    "type": "native",
    "source_file": "datapack.inc",
    "return_type": "Function",
    "comment": "Reads a function pointer from a data pack.",
    "tags": {
      "param": [
        {
          "name": "pack",
          "description": "Handle to the data pack."
        }
      ],
      "error": [
        "Invalid handle, or bounds error."
      ],
      "note": [],
      "return": "Function pointer."
    },
    "params": [
      {
        "name": "pack",
        "type": "Handle",
        "default": null,
        "description": "Handle to the data pack."
      }
    ],
    "full_declaration": "native Function ReadPackFunction(Handle pack);"
  },
  {
    "name": "ResetPack",
    "type": "native",
    "source_file": "datapack.inc",
    "return_type": "void",
    "comment": "Resets the position in a data pack.",
    "tags": {
      "param": [
        {
          "name": "pack",
          "description": "Handle to the data pack."
        },
        {
          "name": "clear",
          "description": "If true, clears the contained data."
        }
      ],
      "error": [
        "Invalid handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pack",
        "type": "Handle",
        "default": null,
        "description": "Handle to the data pack."
      },
      {
        "name": "clear",
        "type": "bool",
        "default": "",
        "description": "If true, clears the contained data."
      }
    ],
    "full_declaration": "native void ResetPack(Handle pack, bool clear=false);"
  },
  {
    "name": "GetPackPosition",
    "type": "native",
    "source_file": "datapack.inc",
    "return_type": "DataPackPos",
    "comment": "Returns the read or write position in a data pack.",
    "tags": {
      "param": [
        {
          "name": "pack",
          "description": "Handle to the data pack."
        }
      ],
      "error": [
        "Invalid handle."
      ],
      "note": [],
      "return": "Position in the data pack, only usable with calls to SetPackPosition."
    },
    "params": [
      {
        "name": "pack",
        "type": "Handle",
        "default": null,
        "description": "Handle to the data pack."
      }
    ],
    "full_declaration": "native DataPackPos GetPackPosition(Handle pack);"
  },
  {
    "name": "SetPackPosition",
    "type": "native",
    "source_file": "datapack.inc",
    "return_type": "void",
    "comment": "Sets the read/write position in a data pack.",
    "tags": {
      "param": [
        {
          "name": "pack",
          "description": "Handle to the data pack."
        },
        {
          "name": "position",
          "description": "New position to set. Must have been previously retrieved from a call to GetPackPosition."
        }
      ],
      "error": [
        "Invalid handle, or position is beyond the pack bounds."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pack",
        "type": "Handle",
        "default": null,
        "description": "Handle to the data pack."
      },
      {
        "name": "position",
        "type": "DataPackPos",
        "default": null,
        "description": "New position to set. Must have been previously retrieved from a call to GetPackPosition."
      }
    ],
    "full_declaration": "native void SetPackPosition(Handle pack, DataPackPos position);"
  },
  {
    "name": "IsPackReadable",
    "type": "native",
    "source_file": "datapack.inc",
    "return_type": "bool",
    "comment": "Returns whether or not a specified number of bytes from the data pack\nposition to the end can be read.",
    "tags": {
      "param": [
        {
          "name": "pack",
          "description": "Handle to the data pack."
        },
        {
          "name": "bytes",
          "description": "Number of bytes to simulate reading."
        }
      ],
      "error": [
        "Invalid handle."
      ],
      "note": [],
      "return": "True if can be read, false otherwise."
    },
    "params": [
      {
        "name": "pack",
        "type": "Handle",
        "default": null,
        "description": "Handle to the data pack."
      },
      {
        "name": "bytes",
        "type": "int",
        "default": null,
        "description": "Number of bytes to simulate reading."
      }
    ],
    "full_declaration": "native bool IsPackReadable(Handle pack, int bytes);"
  },
  {
    "name": "SQLTxnFailure",
    "type": "typedef",
    "source_file": "dbi.inc",
    "return_type": "void",
    "comment": "Callback for a failed transaction.",
    "tags": {
      "param": [
        {
          "name": "db",
          "description": "Database handle."
        },
        {
          "name": "data",
          "description": "Data value passed to SQL_ExecuteTransaction()."
        },
        {
          "name": "numQueries",
          "description": "Number of queries executed in the transaction."
        },
        {
          "name": "error",
          "description": "Error message."
        },
        {
          "name": "failIndex",
          "description": "Index of the query that failed, or -1 if something else."
        },
        {
          "name": "queryData",
          "description": "An array of each data value passed to SQL_AddQuery()."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "db",
        "type": "Database",
        "default": null,
        "description": "Database handle."
      },
      {
        "name": "data",
        "type": "any",
        "default": null,
        "description": "Data value passed to SQL_ExecuteTransaction()."
      },
      {
        "name": "numQueries",
        "type": "int",
        "default": null,
        "description": "Number of queries executed in the transaction."
      },
      {
        "name": "error",
        "type": "char[]",
        "default": null,
        "description": "Error message."
      },
      {
        "name": "failIndex",
        "type": "int",
        "default": null,
        "description": "Index of the query that failed, or -1 if something else."
      },
      {
        "name": "queryData",
        "type": "any[]",
        "default": null,
        "description": "An array of each data value passed to SQL_AddQuery()."
      }
    ],
    "full_declaration": "typedef SQLTxnFailure = function void (Database db, any data, int numQueries, const char[] error, int failIndex, any[] queryData);"
  },
  {
    "name": "SQLConnectCallback",
    "type": "typedef",
    "source_file": "dbi.inc",
    "return_type": "void",
    "comment": "Callback for receiving asynchronous database connections.",
    "tags": {
      "param": [
        {
          "name": "db",
          "description": "Handle to the database connection."
        },
        {
          "name": "error",
          "description": "Error string if there was an error.  The error could be empty even if an error condition exists, so it is important to check the actual Handle value instead."
        },
        {
          "name": "data",
          "description": "Data passed in via the original threaded invocation."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "db",
        "type": "Database",
        "default": null,
        "description": "Handle to the database connection."
      },
      {
        "name": "error",
        "type": "char[]",
        "default": null,
        "description": "Error string if there was an error.  The error could be empty even if an error condition exists, so it is important to check the actual Handle value instead."
      },
      {
        "name": "data",
        "type": "any",
        "default": null,
        "description": "Data passed in via the original threaded invocation."
      }
    ],
    "full_declaration": "typedef SQLConnectCallback = function void (Database db, const char[] error, any data);"
  },
  {
    "name": "SQLQueryCallback",
    "type": "typedef",
    "source_file": "dbi.inc",
    "return_type": "void",
    "comment": "Callback for receiving asynchronous database query results.",
    "tags": {
      "param": [
        {
          "name": "db",
          "description": "Cloned handle to the database connection."
        },
        {
          "name": "results",
          "description": "Result object, or null on failure."
        },
        {
          "name": "error",
          "description": "Error string if there was an error.  The error could be empty even if an error condition exists, so it is important to check the actual results value instead."
        },
        {
          "name": "data",
          "description": "Data passed in via the original threaded invocation."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "db",
        "type": "Database",
        "default": null,
        "description": "Cloned handle to the database connection."
      },
      {
        "name": "results",
        "type": "DBResultSet",
        "default": null,
        "description": "Result object, or null on failure."
      },
      {
        "name": "error",
        "type": "char[]",
        "default": null,
        "description": "Error string if there was an error.  The error could be empty even if an error condition exists, so it is important to check the actual results value instead."
      },
      {
        "name": "data",
        "type": "any",
        "default": null,
        "description": "Data passed in via the original threaded invocation."
      }
    ],
    "full_declaration": "typedef SQLQueryCallback = function void (Database db, DBResultSet results, const char[] error, any data);"
  },
  {
    "name": "SQL_Connect",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "Database",
    "comment": "Creates an SQL connection from a named configuration.",
    "tags": {
      "param": [
        {
          "name": "confname",
          "description": "Named configuration."
        },
        {
          "name": "persistent",
          "description": "True to re-use a previous persistent connection if possible, false otherwise."
        },
        {
          "name": "error",
          "description": "Error buffer."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of the error buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "A database connection Handle, or INVALID_HANDLE on failure."
    },
    "params": [
      {
        "name": "confname",
        "type": "char[]",
        "default": null,
        "description": "Named configuration."
      },
      {
        "name": "persistent",
        "type": "bool",
        "default": null,
        "description": "True to re-use a previous persistent connection if possible, false otherwise."
      },
      {
        "name": "error",
        "type": "char[]",
        "default": null,
        "description": "Error buffer."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the error buffer."
      }
    ],
    "full_declaration": "native Database SQL_Connect(const char[] confname, bool persistent, char[] error, int maxlength);"
  },
  {
    "name": "SQL_DefConnect",
    "type": "stock",
    "source_file": "dbi.inc",
    "return_type": "Database",
    "comment": "Creates a default SQL connection.",
    "tags": {
      "param": [
        {
          "name": "error",
          "description": "Error buffer."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of the error buffer."
        },
        {
          "name": "persistent",
          "description": "True to re-use a previous persistent connection if possible, false otherwise."
        }
      ],
      "error": [],
      "note": [],
      "return": "A database connection Handle, or INVALID_HANDLE on failure. On failure the error buffer will be filled with a message."
    },
    "params": [
      {
        "name": "error",
        "type": "char[]",
        "default": null,
        "description": "Error buffer."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the error buffer."
      },
      {
        "name": "persistent",
        "type": "bool",
        "default": "",
        "description": "True to re-use a previous persistent connection if possible, false otherwise."
      }
    ],
    "full_declaration": "stock Database SQL_DefConnect(char[] error, int maxlength, bool persistent=true) { \treturn SQL_Connect(\"default\", persistent, error, maxlength);"
  },
  {
    "name": "SQL_ConnectCustom",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "Database",
    "comment": "Connects to a database using key value pairs containing the database info.\nThe key/value pairs should match what would be in databases.cfg.\n\nI.e. \"driver\" should be \"default\" or a driver name (or omitted for\nthe default).  For SQLite, only the \"database\" parameter is needed in addition.\nFor drivers which require external connections, more of the parameters may be\nneeded.\n\nIn general it is discouraged to use this function.  Connections should go through\ndatabases.cfg for greatest flexibility on behalf of users.",
    "tags": {
      "param": [
        {
          "name": "keyvalues",
          "description": "Key/value pairs from a KeyValues handle, describing the connection."
        },
        {
          "name": "error",
          "description": "Error buffer."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of the error buffer."
        },
        {
          "name": "persistent",
          "description": "True to re-use a previous persistent connection if possible, false otherwise."
        }
      ],
      "error": [
        "Invalid KeyValues handle."
      ],
      "note": [],
      "return": "A database connection Handle, or INVALID_HANDLE on failure. On failure the error buffer will be filled with a message."
    },
    "params": [
      {
        "name": "keyvalues",
        "type": "Handle",
        "default": null,
        "description": "Key/value pairs from a KeyValues handle, describing the connection."
      },
      {
        "name": "error",
        "type": "char[]",
        "default": null,
        "description": "Error buffer."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the error buffer."
      },
      {
        "name": "persistent",
        "type": "bool",
        "default": null,
        "description": "True to re-use a previous persistent connection if possible, false otherwise."
      }
    ],
    "full_declaration": "native Database SQL_ConnectCustom(Handle keyvalues, \t\t\t\t\t\t\t\t  char[] error, \t\t\t\t\t\t\t\t  int maxlength, \t\t\t\t\t\t\t\t  bool persistent);"
  },
  {
    "name": "SQLite_UseDatabase",
    "type": "stock",
    "source_file": "dbi.inc",
    "return_type": "Database",
    "comment": "Grabs a handle to an SQLite database, creating one if it does not exist.\n\nUnless there are extenuating circumstances, you should consider using \"sourcemod-local\" as the\ndatabase name.  This provides some unification between plugins on behalf of users.\n\nAs a precaution, you should always create some sort of unique prefix to your table names so\nthere are no conflicts, and you should never drop or modify tables that you do not own.",
    "tags": {
      "param": [
        {
          "name": "database",
          "description": "Database name."
        },
        {
          "name": "error",
          "description": "Error buffer."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of the error buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "A database connection Handle, or INVALID_HANDLE on failure. On failure the error buffer will be filled with a message."
    },
    "params": [
      {
        "name": "database",
        "type": "char[]",
        "default": null,
        "description": "Database name."
      },
      {
        "name": "error",
        "type": "char[]",
        "default": null,
        "description": "Error buffer."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the error buffer."
      }
    ],
    "full_declaration": "stock Database SQLite_UseDatabase(const char[] database, char[] error, int maxlength) { \tKeyValues kv = new KeyValues(\"\");"
  },
  {
    "name": "SQL_ConnectEx",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "Handle",
    "comment": "This function is deprecated.  Use SQL_ConnectCustom or SQLite_UseDatabase instead.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "",
      "deprecated": [
        ""
      ]
    },
    "params": [
      {
        "name": "driver",
        "type": "Handle",
        "default": null,
        "description": ""
      },
      {
        "name": "host",
        "type": "char[]",
        "default": null,
        "description": ""
      },
      {
        "name": "user",
        "type": "char[]",
        "default": null,
        "description": ""
      },
      {
        "name": "pass",
        "type": "char[]",
        "default": null,
        "description": ""
      },
      {
        "name": "database",
        "type": "char[]",
        "default": null,
        "description": ""
      },
      {
        "name": "error",
        "type": "char[]",
        "default": null,
        "description": ""
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "persistent",
        "type": "bool",
        "default": "",
        "description": ""
      },
      {
        "name": "port",
        "type": "int",
        "default": "",
        "description": ""
      },
      {
        "name": "maxTimeout",
        "type": "int",
        "default": "",
        "description": ""
      }
    ],
    "full_declaration": "native Handle SQL_ConnectEx(Handle driver,  \t\t\t\t\t\t\tconst char[] host, \t\t\t\t\t\t\tconst char[] user,  \t\t\t\t\t\t\tconst char[] pass, \t\t\t\t\t\t\tconst char[] database, \t\t\t\t\t\t\tchar[] error, \t\t\t\t\t\t\tint maxlength, \t\t\t\t\t\t\tbool persistent=true, \t\t\t\t\t\t\tint port=0, \t\t\t\t\t\t\tint maxTimeout=0);"
  },
  {
    "name": "SQL_CheckConfig",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "bool",
    "comment": "Returns if a named configuration is present in databases.cfg.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Configuration name."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if it exists, false otherwise."
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Configuration name."
      }
    ],
    "full_declaration": "native bool SQL_CheckConfig(const char[] name);"
  },
  {
    "name": "SQL_GetDriver",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "DBDriver",
    "comment": "Returns a driver Handle from a name string.\n\nIf the driver is not found, SourceMod will attempt\nto load an extension named dbi.<name>.ext.[dll|so].",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Driver identification string, or an empty string to return the default driver."
        }
      ],
      "error": [],
      "note": [],
      "return": "Driver Handle, or INVALID_HANDLE on failure."
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": "",
        "description": "Driver identification string, or an empty string to return the default driver."
      }
    ],
    "full_declaration": "native DBDriver SQL_GetDriver(const char[] name=\"\");"
  },
  {
    "name": "SQL_ReadDriver",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "DBDriver",
    "comment": "Reads the driver of an opened database.",
    "tags": {
      "param": [
        {
          "name": "database",
          "description": "Database Handle."
        },
        {
          "name": "ident",
          "description": "Option buffer to store the identification string."
        },
        {
          "name": "ident_length",
          "description": "Maximum length of the buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "Driver Handle."
    },
    "params": [
      {
        "name": "database",
        "type": "Handle",
        "default": null,
        "description": "Database Handle."
      },
      {
        "name": "ident",
        "type": "char[]",
        "default": "",
        "description": "Option buffer to store the identification string."
      },
      {
        "name": "ident_length",
        "type": "int",
        "default": "",
        "description": "Maximum length of the buffer."
      }
    ],
    "full_declaration": "native DBDriver SQL_ReadDriver(Handle database, char[] ident=\"\", int ident_length=0);"
  },
  {
    "name": "SQL_GetDriverIdent",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "void",
    "comment": "Retrieves a driver's identification string.\n\nExample: \"mysql\", \"sqlite\"",
    "tags": {
      "param": [
        {
          "name": "driver",
          "description": "Driver Handle, or INVALID_HANDLE for the default driver."
        },
        {
          "name": "ident",
          "description": "Identification string buffer."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of the buffer."
        }
      ],
      "error": [
        "Invalid Handle other than INVALID_HANDLE."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "driver",
        "type": "Handle",
        "default": null,
        "description": "Driver Handle, or INVALID_HANDLE for the default driver."
      },
      {
        "name": "ident",
        "type": "char[]",
        "default": null,
        "description": "Identification string buffer."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the buffer."
      }
    ],
    "full_declaration": "native void SQL_GetDriverIdent(Handle driver, char[] ident, int maxlength);"
  },
  {
    "name": "SQL_GetDriverProduct",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "void",
    "comment": "Retrieves a driver's product string.\n\nExample: \"MySQL\", \"SQLite\"",
    "tags": {
      "param": [
        {
          "name": "driver",
          "description": "Driver Handle, or INVALID_HANDLE for the default driver."
        },
        {
          "name": "product",
          "description": "Product string buffer."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of the buffer."
        }
      ],
      "error": [
        "Invalid Handle other than INVALID_HANDLE."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "driver",
        "type": "Handle",
        "default": null,
        "description": "Driver Handle, or INVALID_HANDLE for the default driver."
      },
      {
        "name": "product",
        "type": "char[]",
        "default": null,
        "description": "Product string buffer."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the buffer."
      }
    ],
    "full_declaration": "native void SQL_GetDriverProduct(Handle driver, char[] product, int maxlength);"
  },
  {
    "name": "SQL_SetCharset",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "bool",
    "comment": "Sets the character set of the current connection.\nLike SET NAMES .. in mysql, but stays after connection problems.\n\nExample: \"utf8\", \"latin1\"",
    "tags": {
      "param": [
        {
          "name": "database",
          "description": "Database Handle."
        },
        {
          "name": "charset",
          "description": "The character set string to change to."
        }
      ],
      "error": [],
      "note": [],
      "return": "True, if character set was changed, false otherwise."
    },
    "params": [
      {
        "name": "database",
        "type": "Handle",
        "default": null,
        "description": "Database Handle."
      },
      {
        "name": "charset",
        "type": "char[]",
        "default": null,
        "description": "The character set string to change to."
      }
    ],
    "full_declaration": "native bool SQL_SetCharset(Handle database, const char[] charset);"
  },
  {
    "name": "SQL_GetAffectedRows",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "int",
    "comment": "Returns the number of affected rows from the last query.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "A database OR statement Handle."
        }
      ],
      "error": [
        "Invalid database or statement Handle."
      ],
      "note": [],
      "return": "Number of rows affected by the last query."
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": null,
        "description": "A database OR statement Handle."
      }
    ],
    "full_declaration": "native int SQL_GetAffectedRows(Handle hndl);"
  },
  {
    "name": "SQL_GetInsertId",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "int",
    "comment": "Returns the last query's insertion id.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "A database, query, OR statement Handle."
        }
      ],
      "error": [
        "Invalid database, query, or statement Handle."
      ],
      "note": [],
      "return": "Last query's insertion id."
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": null,
        "description": "A database, query, OR statement Handle."
      }
    ],
    "full_declaration": "native int SQL_GetInsertId(Handle hndl);"
  },
  {
    "name": "SQL_GetError",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "bool",
    "comment": "Returns the error reported by the last query.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "A database, query, OR statement Handle."
        },
        {
          "name": "error",
          "description": "Error buffer."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of the buffer."
        }
      ],
      "error": [
        "Invalid database, query, or statement Handle."
      ],
      "note": [],
      "return": "True if there was an error, false otherwise."
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": null,
        "description": "A database, query, OR statement Handle."
      },
      {
        "name": "error",
        "type": "char[]",
        "default": null,
        "description": "Error buffer."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the buffer."
      }
    ],
    "full_declaration": "native bool SQL_GetError(Handle hndl, char[] error, int maxlength);"
  },
  {
    "name": "SQL_EscapeString",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "bool",
    "comment": "Escapes a database string for literal insertion.  This is not needed\nfor binding strings in prepared statements.\n\nGenerally, database strings are inserted into queries enclosed in\nsingle quotes (').  If user input has a single quote in it, the\nquote needs to be escaped.  This function ensures that any unsafe\ncharacters are safely escaped according to the database engine and\nthe database's character set.\n\nNOTE: SourceMod only guarantees properly escaped strings when the query\nencloses the string in single quotes. While drivers tend to allow double\nquotes (\") instead, the string may be not be escaped (for example, on SQLite)!",
    "tags": {
      "param": [
        {
          "name": "database",
          "description": "A database Handle."
        },
        {
          "name": "string",
          "description": "String to quote."
        },
        {
          "name": "buffer",
          "description": "Buffer to store quoted string in."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of the buffer."
        },
        {
          "name": "written",
          "description": "Optionally returns the number of bytes written."
        }
      ],
      "error": [
        "Invalid database or statement Handle."
      ],
      "note": [],
      "return": "True on success, false if buffer is not big enough. The buffer must be at least 2*strlen(string)+1."
    },
    "params": [
      {
        "name": "database",
        "type": "Handle",
        "default": null,
        "description": "A database Handle."
      },
      {
        "name": "string",
        "type": "char[]",
        "default": null,
        "description": "String to quote."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store quoted string in."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the buffer."
      },
      {
        "name": "written",
        "type": "int",
        "default": "",
        "description": "Optionally returns the number of bytes written."
      }
    ],
    "full_declaration": "native bool SQL_EscapeString(Handle database,  \t\t\t\t\t\t\t const char[] string,  \t\t\t\t\t\t\t char[] buffer,  \t\t\t\t\t\t\t int maxlength,  \t\t\t\t\t\t\t int &written=0);"
  },
  {
    "name": "SQL_FormatQuery",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "int",
    "comment": "Formats a string according to the SourceMod format rules (see documentation).\nAll format specifiers are escaped (see SQL_EscapeString) unless the '!' flag is used.",
    "tags": {
      "param": [
        {
          "name": "database",
          "description": "A database Handle."
        },
        {
          "name": "buffer",
          "description": "Destination string buffer."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of output string buffer."
        },
        {
          "name": "format",
          "description": "Formatting rules."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of cells written."
    },
    "params": [
      {
        "name": "database",
        "type": "Handle",
        "default": null,
        "description": "A database Handle."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Destination string buffer."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of output string buffer."
      },
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "Formatting rules."
      }
    ],
    "full_declaration": "native int SQL_FormatQuery(Handle database, char[] buffer, int maxlength, const char[] format, any ...);"
  },
  {
    "name": "SQL_QuoteString",
    "type": "stock",
    "source_file": "dbi.inc",
    "return_type": "bool",
    "comment": "This function is deprecated.  Use SQL_EscapeString instead.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "",
      "deprecated": [
        ""
      ]
    },
    "params": [
      {
        "name": "database",
        "type": "Handle",
        "default": null,
        "description": ""
      },
      {
        "name": "string",
        "type": "char[]",
        "default": null,
        "description": ""
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": ""
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "written",
        "type": "int",
        "default": "",
        "description": ""
      }
    ],
    "full_declaration": "stock bool SQL_QuoteString(Handle database, \t\t\t\t\t\t   const char[] string, \t\t\t\t\t\t   char[] buffer, \t\t\t\t\t\t   int maxlength, \t\t\t\t\t\t   int &written=0) { \treturn SQL_EscapeString(database, string, buffer, maxlength, written);"
  },
  {
    "name": "SQL_FastQuery",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "bool",
    "comment": "Executes a query and ignores the result set.",
    "tags": {
      "param": [
        {
          "name": "database",
          "description": "A database Handle."
        },
        {
          "name": "query",
          "description": "Query string."
        },
        {
          "name": "len",
          "description": "Optional parameter to specify the query length, in bytes.  This can be used to send binary queries that have a premature terminator."
        }
      ],
      "error": [
        "Invalid database Handle."
      ],
      "note": [],
      "return": "True if query succeeded, false otherwise.  Use SQL_GetError to find the last error."
    },
    "params": [
      {
        "name": "database",
        "type": "Handle",
        "default": null,
        "description": "A database Handle."
      },
      {
        "name": "query",
        "type": "char[]",
        "default": null,
        "description": "Query string."
      },
      {
        "name": "len",
        "type": "int",
        "default": "",
        "description": "Optional parameter to specify the query length, in bytes.  This can be used to send binary queries that have a premature terminator."
      }
    ],
    "full_declaration": "native bool SQL_FastQuery(Handle database, const char[] query, int len=-1);"
  },
  {
    "name": "SQL_Query",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "DBResultSet",
    "comment": "Executes a simple query and returns a new query Handle for\nreceiving the results.",
    "tags": {
      "param": [
        {
          "name": "database",
          "description": "A database Handle."
        },
        {
          "name": "query",
          "description": "Query string."
        },
        {
          "name": "len",
          "description": "Optional parameter to specify the query length, in bytes.  This can be used to send binary queries that have a premature terminator."
        }
      ],
      "error": [
        "Invalid database Handle."
      ],
      "note": [],
      "return": "A new Query Handle on success, INVALID_HANDLE otherwise.  The Handle must be freed with CloseHandle()."
    },
    "params": [
      {
        "name": "database",
        "type": "Handle",
        "default": null,
        "description": "A database Handle."
      },
      {
        "name": "query",
        "type": "char[]",
        "default": null,
        "description": "Query string."
      },
      {
        "name": "len",
        "type": "int",
        "default": "",
        "description": "Optional parameter to specify the query length, in bytes.  This can be used to send binary queries that have a premature terminator."
      }
    ],
    "full_declaration": "native DBResultSet SQL_Query(Handle database, const char[] query, int len=-1);"
  },
  {
    "name": "SQL_PrepareQuery",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "DBStatement",
    "comment": "Creates a new prepared statement query.  Prepared statements can\nbe executed any number of times.  They can also have placeholder\nparameters, similar to variables, which can be bound safely and\nsecurely (for example, you do not need to quote bound strings).\n\nStatement handles will work in any function that accepts a Query handle.",
    "tags": {
      "param": [
        {
          "name": "database",
          "description": "A database Handle."
        },
        {
          "name": "query",
          "description": "Query string."
        },
        {
          "name": "error",
          "description": "Error buffer."
        },
        {
          "name": "maxlength",
          "description": "Maximum size of the error buffer."
        }
      ],
      "error": [
        "Invalid database Handle."
      ],
      "note": [],
      "return": "A new statement Handle on success, INVALID_HANDLE otherwise.  The Handle must be freed with CloseHandle()."
    },
    "params": [
      {
        "name": "database",
        "type": "Handle",
        "default": null,
        "description": "A database Handle."
      },
      {
        "name": "query",
        "type": "char[]",
        "default": null,
        "description": "Query string."
      },
      {
        "name": "error",
        "type": "char[]",
        "default": null,
        "description": "Error buffer."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum size of the error buffer."
      }
    ],
    "full_declaration": "native DBStatement SQL_PrepareQuery(Handle database, const char[] query, char[] error, int maxlength);"
  },
  {
    "name": "SQL_FetchMoreResults",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "bool",
    "comment": "Advances to the next set of results.\n\nIn some SQL implementations, multiple result sets can exist on one query.\nThis is possible in MySQL with simple queries when executing a CALL\nquery.  If this is the case, all result sets must be processed before\nanother query is made.",
    "tags": {
      "param": [
        {
          "name": "query",
          "description": "A query Handle."
        }
      ],
      "error": [
        "Invalid query Handle."
      ],
      "note": [],
      "return": "True if there was another result set, false otherwise."
    },
    "params": [
      {
        "name": "query",
        "type": "Handle",
        "default": null,
        "description": "A query Handle."
      }
    ],
    "full_declaration": "native bool SQL_FetchMoreResults(Handle query);"
  },
  {
    "name": "SQL_HasResultSet",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "bool",
    "comment": "Returns whether or not a result set exists.  This will\nreturn true even if 0 results were returned, but false\non queries like UPDATE, INSERT, or DELETE.",
    "tags": {
      "param": [
        {
          "name": "query",
          "description": "A query (or statement) Handle."
        }
      ],
      "error": [
        "Invalid query Handle."
      ],
      "note": [],
      "return": "True if there is a result set, false otherwise."
    },
    "params": [
      {
        "name": "query",
        "type": "Handle",
        "default": null,
        "description": "A query (or statement) Handle."
      }
    ],
    "full_declaration": "native bool SQL_HasResultSet(Handle query);"
  },
  {
    "name": "SQL_GetRowCount",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "int",
    "comment": "Retrieves the number of rows in the last result set.",
    "tags": {
      "param": [
        {
          "name": "query",
          "description": "A query (or statement) Handle."
        }
      ],
      "error": [
        "Invalid query Handle."
      ],
      "note": [],
      "return": "Number of rows in the current result set."
    },
    "params": [
      {
        "name": "query",
        "type": "Handle",
        "default": null,
        "description": "A query (or statement) Handle."
      }
    ],
    "full_declaration": "native int SQL_GetRowCount(Handle query);"
  },
  {
    "name": "SQL_GetFieldCount",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "int",
    "comment": "Retrieves the number of fields in the last result set.",
    "tags": {
      "param": [
        {
          "name": "query",
          "description": "A query (or statement) Handle."
        }
      ],
      "error": [
        "Invalid query Handle."
      ],
      "note": [],
      "return": "Number of fields in the current result set."
    },
    "params": [
      {
        "name": "query",
        "type": "Handle",
        "default": null,
        "description": "A query (or statement) Handle."
      }
    ],
    "full_declaration": "native int SQL_GetFieldCount(Handle query);"
  },
  {
    "name": "SQL_FieldNumToName",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "void",
    "comment": "Retrieves the name of a field by index.",
    "tags": {
      "param": [
        {
          "name": "query",
          "description": "A query (or statement) Handle."
        },
        {
          "name": "field",
          "description": "Field number (starting from 0)."
        },
        {
          "name": "name",
          "description": "Name buffer."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of the name buffer."
        }
      ],
      "error": [
        "Invalid query Handle, invalid field index, or no current result set."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "query",
        "type": "Handle",
        "default": null,
        "description": "A query (or statement) Handle."
      },
      {
        "name": "field",
        "type": "int",
        "default": null,
        "description": "Field number (starting from 0)."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Name buffer."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the name buffer."
      }
    ],
    "full_declaration": "native void SQL_FieldNumToName(Handle query, int field, char[] name, int maxlength);"
  },
  {
    "name": "SQL_FieldNameToNum",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "bool",
    "comment": "Retrieves a field index by name.",
    "tags": {
      "param": [
        {
          "name": "query",
          "description": "A query (or statement) Handle."
        },
        {
          "name": "name",
          "description": "Name of the field (case sensitive)."
        },
        {
          "name": "field",
          "description": "Variable to store field index in."
        }
      ],
      "error": [
        "Invalid query Handle or no current result set."
      ],
      "note": [],
      "return": "True if found, false if not found."
    },
    "params": [
      {
        "name": "query",
        "type": "Handle",
        "default": null,
        "description": "A query (or statement) Handle."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Name of the field (case sensitive)."
      },
      {
        "name": "field",
        "type": "int",
        "default": null,
        "description": "Variable to store field index in."
      }
    ],
    "full_declaration": "native bool SQL_FieldNameToNum(Handle query, const char[] name, int &field);"
  },
  {
    "name": "SQL_FetchRow",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "bool",
    "comment": "Fetches a row from the current result set.  This must be\nsuccessfully called before any results are fetched.\n\nIf this function fails, SQL_MoreRows() can be used to\ntell if there was an error or the result set is finished.",
    "tags": {
      "param": [
        {
          "name": "query",
          "description": "A query (or statement) Handle."
        }
      ],
      "error": [
        "Invalid query Handle."
      ],
      "note": [],
      "return": "True if a row was fetched, false otherwise."
    },
    "params": [
      {
        "name": "query",
        "type": "Handle",
        "default": null,
        "description": "A query (or statement) Handle."
      }
    ],
    "full_declaration": "native bool SQL_FetchRow(Handle query);"
  },
  {
    "name": "SQL_MoreRows",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "bool",
    "comment": "Returns if there are more rows.",
    "tags": {
      "param": [
        {
          "name": "query",
          "description": "A query (or statement) Handle."
        }
      ],
      "error": [
        "Invalid query Handle."
      ],
      "note": [],
      "return": "True if there are more rows, false otherwise."
    },
    "params": [
      {
        "name": "query",
        "type": "Handle",
        "default": null,
        "description": "A query (or statement) Handle."
      }
    ],
    "full_declaration": "native bool SQL_MoreRows(Handle query);"
  },
  {
    "name": "SQL_Rewind",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "bool",
    "comment": "Rewinds a result set back to the first result.",
    "tags": {
      "param": [
        {
          "name": "query",
          "description": "A query (or statement) Handle."
        }
      ],
      "error": [
        "Invalid query Handle or no current result set."
      ],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "query",
        "type": "Handle",
        "default": null,
        "description": "A query (or statement) Handle."
      }
    ],
    "full_declaration": "native bool SQL_Rewind(Handle query);"
  },
  {
    "name": "SQL_FetchString",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "int",
    "comment": "Fetches a string from a field in the current row of a result set.\nIf the result is NULL, an empty string will be returned.  A NULL\ncheck can be done with the result parameter, or SQL_IsFieldNull().",
    "tags": {
      "param": [
        {
          "name": "query",
          "description": "A query (or statement) Handle."
        },
        {
          "name": "field",
          "description": "The field index (starting from 0)."
        },
        {
          "name": "buffer",
          "description": "String buffer."
        },
        {
          "name": "maxlength",
          "description": "Maximum size of the string buffer."
        },
        {
          "name": "result",
          "description": "Optional variable to store the status of the return value."
        }
      ],
      "error": [
        "Invalid query Handle or field index, invalid type conversion requested from the database, or no current result set."
      ],
      "note": [],
      "return": "Number of bytes written."
    },
    "params": [
      {
        "name": "query",
        "type": "Handle",
        "default": null,
        "description": "A query (or statement) Handle."
      },
      {
        "name": "field",
        "type": "int",
        "default": null,
        "description": "The field index (starting from 0)."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "String buffer."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum size of the string buffer."
      },
      {
        "name": "result",
        "type": "DBResult",
        "default": "",
        "description": "Optional variable to store the status of the return value."
      }
    ],
    "full_declaration": "native int SQL_FetchString(Handle query, int field, char[] buffer, int maxlength, DBResult &result=DBVal_Error);"
  },
  {
    "name": "SQL_FetchFloat",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "float",
    "comment": "Fetches a float from a field in the current row of a result set.\nIf the result is NULL, a value of 0.0 will be returned.  A NULL\ncheck can be done with the result parameter, or SQL_IsFieldNull().",
    "tags": {
      "param": [
        {
          "name": "query",
          "description": "A query (or statement) Handle."
        },
        {
          "name": "field",
          "description": "The field index (starting from 0)."
        },
        {
          "name": "result",
          "description": "Optional variable to store the status of the return value."
        }
      ],
      "error": [
        "Invalid query Handle or field index, invalid type conversion requested from the database, or no current result set."
      ],
      "note": [],
      "return": "A float value."
    },
    "params": [
      {
        "name": "query",
        "type": "Handle",
        "default": null,
        "description": "A query (or statement) Handle."
      },
      {
        "name": "field",
        "type": "int",
        "default": null,
        "description": "The field index (starting from 0)."
      },
      {
        "name": "result",
        "type": "DBResult",
        "default": "",
        "description": "Optional variable to store the status of the return value."
      }
    ],
    "full_declaration": "native float SQL_FetchFloat(Handle query, int field, DBResult &result=DBVal_Error);"
  },
  {
    "name": "SQL_FetchInt",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "int",
    "comment": "Fetches an integer from a field in the current row of a result set.\nIf the result is NULL, a value of 0 will be returned.  A NULL\ncheck can be done with the result parameter, or SQL_IsFieldNull().",
    "tags": {
      "param": [
        {
          "name": "query",
          "description": "A query (or statement) Handle."
        },
        {
          "name": "field",
          "description": "The field index (starting from 0)."
        },
        {
          "name": "result",
          "description": "Optional variable to store the status of the return value."
        }
      ],
      "error": [
        "Invalid query Handle or field index, invalid type conversion requested from the database, or no current result set."
      ],
      "note": [],
      "return": "An integer value."
    },
    "params": [
      {
        "name": "query",
        "type": "Handle",
        "default": null,
        "description": "A query (or statement) Handle."
      },
      {
        "name": "field",
        "type": "int",
        "default": null,
        "description": "The field index (starting from 0)."
      },
      {
        "name": "result",
        "type": "DBResult",
        "default": "",
        "description": "Optional variable to store the status of the return value."
      }
    ],
    "full_declaration": "native int SQL_FetchInt(Handle query, int field, DBResult &result=DBVal_Error);"
  },
  {
    "name": "SQL_IsFieldNull",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "bool",
    "comment": "Returns whether a field's data in the current row of a result set is\nNULL or not.  NULL is an SQL type which means \"no data.\"",
    "tags": {
      "param": [
        {
          "name": "query",
          "description": "A query (or statement) Handle."
        },
        {
          "name": "field",
          "description": "The field index (starting from 0)."
        }
      ],
      "error": [
        "Invalid query Handle or field index, or no current result set."
      ],
      "note": [],
      "return": "True if data is NULL, false otherwise."
    },
    "params": [
      {
        "name": "query",
        "type": "Handle",
        "default": null,
        "description": "A query (or statement) Handle."
      },
      {
        "name": "field",
        "type": "int",
        "default": null,
        "description": "The field index (starting from 0)."
      }
    ],
    "full_declaration": "native bool SQL_IsFieldNull(Handle query, int field);"
  },
  {
    "name": "SQL_FetchSize",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "int",
    "comment": "Returns the length of a field's data in the current row of a result\nset.  This only needs to be called for strings to determine how many\nbytes to use.  Note that the return value does not include the null\nterminator.",
    "tags": {
      "param": [
        {
          "name": "query",
          "description": "A query (or statement) Handle."
        },
        {
          "name": "field",
          "description": "The field index (starting from 0)."
        }
      ],
      "error": [
        "Invalid query Handle or field index or no current result set."
      ],
      "note": [],
      "return": "Number of bytes for the field's data size."
    },
    "params": [
      {
        "name": "query",
        "type": "Handle",
        "default": null,
        "description": "A query (or statement) Handle."
      },
      {
        "name": "field",
        "type": "int",
        "default": null,
        "description": "The field index (starting from 0)."
      }
    ],
    "full_declaration": "native int SQL_FetchSize(Handle query, int field);"
  },
  {
    "name": "SQL_BindParamInt",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "void",
    "comment": "Binds a parameter in a prepared statement to a given integer value.",
    "tags": {
      "param": [
        {
          "name": "statement",
          "description": "A statement (prepared query) Handle."
        },
        {
          "name": "param",
          "description": "The parameter index (starting from 0)."
        },
        {
          "name": "number",
          "description": "The number to bind."
        },
        {
          "name": "signed",
          "description": "True to bind the number as signed, false to bind it as unsigned."
        }
      ],
      "error": [
        "Invalid statement Handle or parameter index, or SQL error."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "statement",
        "type": "Handle",
        "default": null,
        "description": "A statement (prepared query) Handle."
      },
      {
        "name": "param",
        "type": "int",
        "default": null,
        "description": "The parameter index (starting from 0)."
      },
      {
        "name": "number",
        "type": "int",
        "default": null,
        "description": "The number to bind."
      },
      {
        "name": "signed",
        "type": "bool",
        "default": "",
        "description": "True to bind the number as signed, false to bind it as unsigned."
      }
    ],
    "full_declaration": "native void SQL_BindParamInt(Handle statement, int param, int number, bool signed=true);"
  },
  {
    "name": "SQL_BindParamFloat",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "void",
    "comment": "Binds a parameter in a prepared statement to a given float value.",
    "tags": {
      "param": [
        {
          "name": "statement",
          "description": "A statement (prepared query) Handle."
        },
        {
          "name": "param",
          "description": "The parameter index (starting from 0)."
        },
        {
          "name": "value",
          "description": "The float number to bind."
        }
      ],
      "error": [
        "Invalid statement Handle or parameter index, or SQL error."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "statement",
        "type": "Handle",
        "default": null,
        "description": "A statement (prepared query) Handle."
      },
      {
        "name": "param",
        "type": "int",
        "default": null,
        "description": "The parameter index (starting from 0)."
      },
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "The float number to bind."
      }
    ],
    "full_declaration": "native void SQL_BindParamFloat(Handle statement, int param, float value);"
  },
  {
    "name": "SQL_BindParamString",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "void",
    "comment": "Binds a parameter in a prepared statement to a given string value.",
    "tags": {
      "param": [
        {
          "name": "statement",
          "description": "A statement (prepared query) Handle."
        },
        {
          "name": "param",
          "description": "The parameter index (starting from 0)."
        },
        {
          "name": "value",
          "description": "The string to bind."
        },
        {
          "name": "copy",
          "description": "Whether or not SourceMod should copy the value locally if necessary.  If the string contents won't change before calling SQL_Execute(), this can be set to false for optimization."
        }
      ],
      "error": [
        "Invalid statement Handle or parameter index, or SQL error."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "statement",
        "type": "Handle",
        "default": null,
        "description": "A statement (prepared query) Handle."
      },
      {
        "name": "param",
        "type": "int",
        "default": null,
        "description": "The parameter index (starting from 0)."
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "The string to bind."
      },
      {
        "name": "copy",
        "type": "bool",
        "default": null,
        "description": "Whether or not SourceMod should copy the value locally if necessary.  If the string contents won't change before calling SQL_Execute(), this can be set to false for optimization."
      }
    ],
    "full_declaration": "native void SQL_BindParamString(Handle statement, int param, const char[] value, bool copy);"
  },
  {
    "name": "SQL_Execute",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "bool",
    "comment": "Executes a prepared statement.  All parameters must be bound beforehand.",
    "tags": {
      "param": [
        {
          "name": "statement",
          "description": "A statement (prepared query) Handle."
        }
      ],
      "error": [
        "Invalid statement Handle."
      ],
      "note": [],
      "return": "True on success, false on failure."
    },
    "params": [
      {
        "name": "statement",
        "type": "Handle",
        "default": null,
        "description": "A statement (prepared query) Handle."
      }
    ],
    "full_declaration": "native bool SQL_Execute(Handle statement);"
  },
  {
    "name": "SQL_LockDatabase",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "void",
    "comment": "Locks a database so threading operations will not interrupt.\n\nIf you are using a database Handle for both threading and non-threading,\nthis MUST be called before doing any set of non-threading DB operations.\nOtherwise you risk corrupting the database driver's memory or network\nconnection.\n\nLeaving a lock on a database and then executing a threaded query results\nin a dead lock! Make sure to call SQL_UnlockDatabase()!\n\nIf the lock cannot be acquired, the main thread will pause until the\nthreaded operation has concluded.\n\nCare should be taken to not lock an already-locked database. Internally,\nlock calls are nested recursively and must be paired with an equal amount\nof unlocks to be undone. This behaviour should not be relied on.",
    "tags": {
      "param": [
        {
          "name": "database",
          "description": "A database Handle."
        }
      ],
      "error": [
        "Invalid database Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "database",
        "type": "Handle",
        "default": null,
        "description": "A database Handle."
      }
    ],
    "full_declaration": "native void SQL_LockDatabase(Handle database);"
  },
  {
    "name": "SQL_UnlockDatabase",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "void",
    "comment": "Unlocks a database so threading operations may continue.",
    "tags": {
      "param": [
        {
          "name": "database",
          "description": "A database Handle."
        }
      ],
      "error": [
        "Invalid database Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "database",
        "type": "Handle",
        "default": null,
        "description": "A database Handle."
      }
    ],
    "full_declaration": "native void SQL_UnlockDatabase(Handle database);"
  },
  {
    "name": "SQLTCallback",
    "type": "typedef",
    "source_file": "dbi.inc",
    "return_type": "void",
    "comment": "General callback for threaded SQL stuff.",
    "tags": {
      "param": [
        {
          "name": "owner",
          "description": "Parent object of the Handle (or INVALID_HANDLE if none)."
        },
        {
          "name": "hndl",
          "description": "Handle to the child object (or INVALID_HANDLE if none)."
        },
        {
          "name": "error",
          "description": "Error string if there was an error.  The error could be empty even if an error condition exists, so it is important to check the actual Handle value instead."
        },
        {
          "name": "data",
          "description": "Data passed in via the original threaded invocation."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "owner",
        "type": "Handle",
        "default": null,
        "description": "Parent object of the Handle (or INVALID_HANDLE if none)."
      },
      {
        "name": "hndl",
        "type": "Handle",
        "default": null,
        "description": "Handle to the child object (or INVALID_HANDLE if none)."
      },
      {
        "name": "error",
        "type": "char[]",
        "default": null,
        "description": "Error string if there was an error.  The error could be empty even if an error condition exists, so it is important to check the actual Handle value instead."
      },
      {
        "name": "data",
        "type": "any",
        "default": null,
        "description": "Data passed in via the original threaded invocation."
      }
    ],
    "full_declaration": "typedef SQLTCallback = function void (Handle owner, Handle hndl, const char[] error, any data);"
  },
  {
    "name": "SQL_IsSameConnection",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "bool",
    "comment": "Tells whether two database handles both point to the same database\nconnection.",
    "tags": {
      "param": [
        {
          "name": "hndl1",
          "description": "First database Handle."
        },
        {
          "name": "hndl2",
          "description": "Second database Handle."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True if the Handles point to the same connection, false otherwise."
    },
    "params": [
      {
        "name": "hndl1",
        "type": "Handle",
        "default": null,
        "description": "First database Handle."
      },
      {
        "name": "hndl2",
        "type": "Handle",
        "default": null,
        "description": "Second database Handle."
      }
    ],
    "full_declaration": "native bool SQL_IsSameConnection(Handle hndl1, Handle hndl2);"
  },
  {
    "name": "SQL_TConnect",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "void",
    "comment": "Connects to a database via a thread.  This can be used instead of\nSQL_Connect() if you wish for non-blocking functionality.\n\nIt is not necessary to use this to use threaded queries.  However, if you\ndon't (or you mix threaded/non-threaded queries), you should see\nSQL_LockDatabase().",
    "tags": {
      "param": [
        {
          "name": "callback",
          "description": "Callback; new Handle will be in hndl, owner is the driver. If no driver was found, the owner is INVALID_HANDLE."
        },
        {
          "name": "name",
          "description": "Database name."
        },
        {
          "name": "data",
          "description": "Extra data value to pass to the callback."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "callback",
        "type": "SQLTCallback",
        "default": null,
        "description": "Callback; new Handle will be in hndl, owner is the driver. If no driver was found, the owner is INVALID_HANDLE."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": "",
        "description": "Database name."
      },
      {
        "name": "data",
        "type": "any",
        "default": "",
        "description": "Extra data value to pass to the callback."
      }
    ],
    "full_declaration": "native void SQL_TConnect(SQLTCallback callback, const char[] name=\"default\", any data=0);"
  },
  {
    "name": "SQL_TQuery",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "void",
    "comment": "Executes a simple query via a thread.  The query Handle is passed through\nthe callback.\n\nThe database Handle returned through the callback is always a new Handle,\nand if necessary, SQL_IsSameConnection() should be used to test against\nother connections.\n\nThe query Handle returned through the callback is temporary and destroyed\nat the end of the callback.  If you need to hold onto it, use CloneHandle().",
    "tags": {
      "param": [
        {
          "name": "database",
          "description": "A database Handle."
        },
        {
          "name": "callback",
          "description": "Callback; database is in \"owner\" and the query Handle is passed in \"hndl\"."
        },
        {
          "name": "query",
          "description": "Query string."
        },
        {
          "name": "data",
          "description": "Extra data value to pass to the callback."
        },
        {
          "name": "prio",
          "description": "Priority queue to use."
        }
      ],
      "error": [
        "Invalid database Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "database",
        "type": "Handle",
        "default": null,
        "description": "A database Handle."
      },
      {
        "name": "callback",
        "type": "SQLTCallback",
        "default": null,
        "description": "Callback; database is in \"owner\" and the query Handle is passed in \"hndl\"."
      },
      {
        "name": "query",
        "type": "char[]",
        "default": null,
        "description": "Query string."
      },
      {
        "name": "data",
        "type": "any",
        "default": "",
        "description": "Extra data value to pass to the callback."
      },
      {
        "name": "prio",
        "type": "DBPriority",
        "default": "",
        "description": "Priority queue to use."
      }
    ],
    "full_declaration": "native void SQL_TQuery(Handle database, SQLTCallback callback, const char[] query, any data=0, DBPriority prio=DBPrio_Normal);"
  },
  {
    "name": "SQL_CreateTransaction",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "Transaction",
    "comment": "Creates a new transaction object. A transaction object is a list of queries\nthat can be sent to the database thread and executed as a single transaction.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "A transaction handle."
    },
    "params": [],
    "full_declaration": "native Transaction SQL_CreateTransaction();"
  },
  {
    "name": "SQL_AddQuery",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "int",
    "comment": "Adds a query to a transaction object.",
    "tags": {
      "param": [
        {
          "name": "txn",
          "description": "A transaction handle."
        },
        {
          "name": "query",
          "description": "Query string."
        },
        {
          "name": "data",
          "description": "Extra data value to pass to the final callback."
        }
      ],
      "error": [
        "Invalid transaction handle."
      ],
      "note": [],
      "return": "The index of the query in the transaction's query list."
    },
    "params": [
      {
        "name": "txn",
        "type": "Transaction",
        "default": null,
        "description": "A transaction handle."
      },
      {
        "name": "query",
        "type": "char[]",
        "default": null,
        "description": "Query string."
      },
      {
        "name": "data",
        "type": "any",
        "default": "",
        "description": "Extra data value to pass to the final callback."
      }
    ],
    "full_declaration": "native int SQL_AddQuery(Transaction txn, const char[] query, any data=0);"
  },
  {
    "name": "SQL_ExecuteTransaction",
    "type": "native",
    "source_file": "dbi.inc",
    "return_type": "void",
    "comment": "Sends a transaction to the database thread. The transaction handle is\nautomatically closed. When the transaction completes, the optional\ncallback is invoked.",
    "tags": {
      "param": [
        {
          "name": "db",
          "description": "A database handle."
        },
        {
          "name": "txn",
          "description": "A transaction handle."
        },
        {
          "name": "onSuccess",
          "description": "An optional callback to receive a successful transaction."
        },
        {
          "name": "onError",
          "description": "An optional callback to receive an error message."
        },
        {
          "name": "data",
          "description": "An optional value to pass to callbacks."
        },
        {
          "name": "prio",
          "description": "Priority queue to use."
        }
      ],
      "error": [
        "An invalid handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "db",
        "type": "Handle",
        "default": null,
        "description": "A database handle."
      },
      {
        "name": "txn",
        "type": "Transaction",
        "default": null,
        "description": "A transaction handle."
      },
      {
        "name": "onSuccess",
        "type": "SQLTxnSuccess",
        "default": "",
        "description": "An optional callback to receive a successful transaction."
      },
      {
        "name": "onError",
        "type": "SQLTxnFailure",
        "default": "",
        "description": "An optional callback to receive an error message."
      },
      {
        "name": "data",
        "type": "any",
        "default": "",
        "description": "An optional value to pass to callbacks."
      },
      {
        "name": "priority",
        "type": "DBPriority",
        "default": "",
        "description": ""
      }
    ],
    "full_declaration": "native void SQL_ExecuteTransaction( \t\tHandle db, \t\tTransaction txn, \t\tSQLTxnSuccess onSuccess = INVALID_FUNCTION, \t\tSQLTxnFailure onError = INVALID_FUNCTION, \t\tany data=0, \t\tDBPriority priority=DBPrio_Normal);"
  },
  {
    "name": "DHookAddEntityListener",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "void",
    "comment": "Adds an entity listener hook",
    "tags": {
      "param": [
        {
          "name": "type",
          "description": "Type of listener to add"
        },
        {
          "name": "callback",
          "description": "Callback to use"
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "type",
        "type": "ListenType",
        "default": null,
        "description": "Type of listener to add"
      },
      {
        "name": "callback",
        "type": "ListenCB",
        "default": null,
        "description": "Callback to use"
      }
    ],
    "full_declaration": "native void DHookAddEntityListener(ListenType type, ListenCB callback);"
  },
  {
    "name": "DHookRemoveEntityListener",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "bool",
    "comment": "Removes an entity listener hook",
    "tags": {
      "param": [
        {
          "name": "type",
          "description": "Type of listener to remove"
        },
        {
          "name": "callback",
          "description": "Callback this listener was using"
        }
      ],
      "error": [],
      "note": [],
      "return": "true if one was removed, false otherwise"
    },
    "params": [
      {
        "name": "type",
        "type": "ListenType",
        "default": null,
        "description": "Type of listener to remove"
      },
      {
        "name": "callback",
        "type": "ListenCB",
        "default": null,
        "description": "Callback this listener was using"
      }
    ],
    "full_declaration": "native bool DHookRemoveEntityListener(ListenType type, ListenCB callback);"
  },
  {
    "name": "DHookCreate",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "DynamicHook",
    "comment": "Creates a hook",
    "tags": {
      "param": [
        {
          "name": "offset",
          "description": "vtable offset of function to hook"
        },
        {
          "name": "hooktype",
          "description": "Type of hook"
        },
        {
          "name": "returntype",
          "description": "Type of return value"
        },
        {
          "name": "thistype",
          "description": "Type of this pointer or ignore (ignore can be used if not needed)"
        },
        {
          "name": "callback",
          "description": "Optional callback function, if not set here must be set when hooking."
        }
      ],
      "error": [
        "Failed to create hook setup handle or invalid callback function."
      ],
      "note": [],
      "return": "Returns setup handle for the hook."
    },
    "params": [
      {
        "name": "offset",
        "type": "int",
        "default": null,
        "description": "vtable offset of function to hook"
      },
      {
        "name": "hooktype",
        "type": "HookType",
        "default": null,
        "description": "Type of hook"
      },
      {
        "name": "returntype",
        "type": "ReturnType",
        "default": null,
        "description": "Type of return value"
      },
      {
        "name": "thistype",
        "type": "ThisPointerType",
        "default": null,
        "description": "Type of this pointer or ignore (ignore can be used if not needed)"
      },
      {
        "name": "callback",
        "type": "DHookCallback",
        "default": "",
        "description": "Optional callback function, if not set here must be set when hooking."
      }
    ],
    "full_declaration": "native DynamicHook DHookCreate(int offset, HookType hooktype, ReturnType returntype, ThisPointerType thistype, DHookCallback callback=INVALID_FUNCTION);"
  },
  {
    "name": "DHookCreateDetour",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "DynamicDetour",
    "comment": "Creates a detour",
    "tags": {
      "param": [
        {
          "name": "funcaddr",
          "description": "The address of the function to detour. Can be Address_Null if you want to load the address from gamedata using DHookSetFromConf."
        },
        {
          "name": "callConv",
          "description": "Calling convention of the function."
        },
        {
          "name": "returnType",
          "description": "Type of the return value."
        },
        {
          "name": "thisType",
          "description": "Type of this pointer or ignore (ignore can be used if not needed)"
        }
      ],
      "error": [
        "Failed to create detour setup handle."
      ],
      "note": [],
      "return": "Setup handle for the detour."
    },
    "params": [
      {
        "name": "funcaddr",
        "type": "Address",
        "default": null,
        "description": "The address of the function to detour. Can be Address_Null if you want to load the address from gamedata using DHookSetFromConf."
      },
      {
        "name": "callConv",
        "type": "CallingConvention",
        "default": null,
        "description": "Calling convention of the function."
      },
      {
        "name": "returntype",
        "type": "ReturnType",
        "default": null,
        "description": ""
      },
      {
        "name": "thisType",
        "type": "ThisPointerType",
        "default": null,
        "description": "Type of this pointer or ignore (ignore can be used if not needed)"
      }
    ],
    "full_declaration": "native DynamicDetour DHookCreateDetour(Address funcaddr, CallingConvention callConv, ReturnType returntype, ThisPointerType thisType);"
  },
  {
    "name": "DHookCreateFromConf",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "DHookSetup",
    "comment": "Setup a detour or hook for a function as described in a \"Functions\" section in gamedata.",
    "tags": {
      "param": [
        {
          "name": "gameconf",
          "description": "GameConfig handle"
        },
        {
          "name": "name",
          "description": "Name of the function in the gamedata to load."
        }
      ],
      "error": [
        "Failed to create detour setup handle, invalid gamedata handle, invalid callback function or failed to find function in gamedata."
      ],
      "note": [],
      "return": "Setup handle for the detour or INVALID_HANDLE if offset/signature/address wasn't found."
    },
    "params": [
      {
        "name": "gameconf",
        "type": "Handle",
        "default": null,
        "description": "GameConfig handle"
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Name of the function in the gamedata to load."
      }
    ],
    "full_declaration": "native DHookSetup DHookCreateFromConf(Handle gameconf, const char[] name);"
  },
  {
    "name": "DHookSetFromConf",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "bool",
    "comment": "Load details for a vhook or detour from a gamedata file.",
    "tags": {
      "param": [
        {
          "name": "setup",
          "description": "Hook setup handle to set the offset or address on."
        },
        {
          "name": "gameconf",
          "description": "GameConfig handle"
        },
        {
          "name": "source",
          "description": "Whether to look in Offsets or Signatures."
        },
        {
          "name": "name",
          "description": "Name of the property to find."
        }
      ],
      "error": [
        "Invalid setup or gamedata handle."
      ],
      "note": [],
      "return": "true on success, false if nothing was found."
    },
    "params": [
      {
        "name": "setup",
        "type": "Handle",
        "default": null,
        "description": "Hook setup handle to set the offset or address on."
      },
      {
        "name": "gameconf",
        "type": "Handle",
        "default": null,
        "description": "GameConfig handle"
      },
      {
        "name": "source",
        "type": "SDKFuncConfSource",
        "default": null,
        "description": "Whether to look in Offsets or Signatures."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Name of the property to find."
      }
    ],
    "full_declaration": "native bool DHookSetFromConf(Handle setup, Handle gameconf, SDKFuncConfSource source, const char[] name);"
  },
  {
    "name": "DHookEnableDetour",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "bool",
    "comment": "Enable the detour of the function described in the hook setup handle.",
    "tags": {
      "param": [
        {
          "name": "setup",
          "description": "Hook setup handle"
        },
        {
          "name": "post",
          "description": "true to make the hook a post hook. (If you need to change the return value or need the return value use a post hook! If you need to change params and return use a pre and post hook!)"
        },
        {
          "name": "callback",
          "description": "Callback function"
        }
      ],
      "error": [
        "Hook handle is not setup for a detour."
      ],
      "note": [],
      "return": "true if detour was enabled, false otherwise."
    },
    "params": [
      {
        "name": "setup",
        "type": "Handle",
        "default": null,
        "description": "Hook setup handle"
      },
      {
        "name": "post",
        "type": "bool",
        "default": null,
        "description": "true to make the hook a post hook. (If you need to change the return value or need the return value use a post hook! If you need to change params and return use a pre and post hook!)"
      },
      {
        "name": "callback",
        "type": "DHookCallback",
        "default": null,
        "description": "Callback function"
      }
    ],
    "full_declaration": "native bool DHookEnableDetour(Handle setup, bool post, DHookCallback callback);"
  },
  {
    "name": "DHookDisableDetour",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "bool",
    "comment": "Disable the detour of the function described in the hook setup handle.",
    "tags": {
      "param": [
        {
          "name": "setup",
          "description": "Hook setup handle"
        },
        {
          "name": "post",
          "description": "true to disable a post hook."
        },
        {
          "name": "callback",
          "description": "Callback function"
        }
      ],
      "error": [
        "Hook handle is not setup for a detour or function is not detoured."
      ],
      "note": [],
      "return": "true if detour was disabled, false otherwise."
    },
    "params": [
      {
        "name": "setup",
        "type": "Handle",
        "default": null,
        "description": "Hook setup handle"
      },
      {
        "name": "post",
        "type": "bool",
        "default": null,
        "description": "true to disable a post hook."
      },
      {
        "name": "callback",
        "type": "DHookCallback",
        "default": null,
        "description": "Callback function"
      }
    ],
    "full_declaration": "native bool DHookDisableDetour(Handle setup, bool post, DHookCallback callback);"
  },
  {
    "name": "DHookAddParam",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "void",
    "comment": "Adds param to a hook setup",
    "tags": {
      "param": [
        {
          "name": "setup",
          "description": "Setup handle to add the param to."
        },
        {
          "name": "type",
          "description": "Param type"
        },
        {
          "name": "size",
          "description": "Used for Objects (not Object ptr) to define the size of the object."
        },
        {
          "name": "flag",
          "description": "Used to change the pass type."
        },
        {
          "name": "custom_register",
          "description": "The register this argument is passed in instead of the stack."
        }
      ],
      "error": [
        "Invalid setup handle or too many params added (request upping the max in thread)"
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "setup",
        "type": "Handle",
        "default": null,
        "description": "Setup handle to add the param to."
      },
      {
        "name": "type",
        "type": "HookParamType",
        "default": null,
        "description": "Param type"
      },
      {
        "name": "size",
        "type": "int",
        "default": "",
        "description": "Used for Objects (not Object ptr) to define the size of the object."
      },
      {
        "name": "flag",
        "type": "DHookPassFlag",
        "default": "",
        "description": "Used to change the pass type."
      },
      {
        "name": "custom_register",
        "type": "DHookRegister",
        "default": "",
        "description": "The register this argument is passed in instead of the stack."
      }
    ],
    "full_declaration": "native void DHookAddParam(Handle setup, HookParamType type, int size=-1, DHookPassFlag flag=DHookPass_ByVal, DHookRegister custom_register=DHookRegister_Default);"
  },
  {
    "name": "DHookEntity",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "int",
    "comment": "Hook entity",
    "tags": {
      "param": [
        {
          "name": "setup",
          "description": "Setup handle to use to add the hook."
        },
        {
          "name": "post",
          "description": "true to make the hook a post hook. (If you need to change the return value or need the return value use a post hook! If you need to change params and return use a pre and post hook!)"
        },
        {
          "name": "entity",
          "description": "Entity index to hook on."
        },
        {
          "name": "removalcb",
          "description": "Callback for when the hook is removed (Entity hooks are auto-removed on entity destroyed and will call this callback)"
        },
        {
          "name": "callback",
          "description": "Optional callback function, if not set here must be set when creating the hook."
        }
      ],
      "error": [
        "Invalid setup handle, invalid address, invalid hook type or invalid callback."
      ],
      "note": [],
      "return": "INVALID_HOOK_ID on fail a hookid on success"
    },
    "params": [
      {
        "name": "setup",
        "type": "Handle",
        "default": null,
        "description": "Setup handle to use to add the hook."
      },
      {
        "name": "post",
        "type": "bool",
        "default": null,
        "description": "true to make the hook a post hook. (If you need to change the return value or need the return value use a post hook! If you need to change params and return use a pre and post hook!)"
      },
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index to hook on."
      },
      {
        "name": "removalcb",
        "type": "DHookRemovalCB",
        "default": "",
        "description": "Callback for when the hook is removed (Entity hooks are auto-removed on entity destroyed and will call this callback)"
      },
      {
        "name": "callback",
        "type": "DHookCallback",
        "default": "",
        "description": "Optional callback function, if not set here must be set when creating the hook."
      }
    ],
    "full_declaration": "native int DHookEntity(Handle setup, bool post, int entity, DHookRemovalCB removalcb=INVALID_FUNCTION, DHookCallback callback=INVALID_FUNCTION);"
  },
  {
    "name": "DHookGamerules",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "int",
    "comment": "Hook gamerules",
    "tags": {
      "param": [
        {
          "name": "setup",
          "description": "Setup handle to use to add the hook."
        },
        {
          "name": "post",
          "description": "true to make the hook a post hook. (If you need to change the return value or need the return value use a post hook! If you need to change params and return use a pre and post hook!)"
        },
        {
          "name": "removalcb",
          "description": "Callback for when the hook is removed (Game rules hooks are auto-removed on map end and will call this callback)"
        },
        {
          "name": "callback",
          "description": "Optional callback function, if not set here must be set when creating the hook."
        }
      ],
      "error": [
        "Invalid setup handle, invalid address, invalid hook type or invalid callback."
      ],
      "note": [],
      "return": "INVALID_HOOK_ID on fail a hookid on success"
    },
    "params": [
      {
        "name": "setup",
        "type": "Handle",
        "default": null,
        "description": "Setup handle to use to add the hook."
      },
      {
        "name": "post",
        "type": "bool",
        "default": null,
        "description": "true to make the hook a post hook. (If you need to change the return value or need the return value use a post hook! If you need to change params and return use a pre and post hook!)"
      },
      {
        "name": "removalcb",
        "type": "DHookRemovalCB",
        "default": "",
        "description": "Callback for when the hook is removed (Game rules hooks are auto-removed on map end and will call this callback)"
      },
      {
        "name": "callback",
        "type": "DHookCallback",
        "default": "",
        "description": "Optional callback function, if not set here must be set when creating the hook."
      }
    ],
    "full_declaration": "native int DHookGamerules(Handle setup, bool post, DHookRemovalCB removalcb=INVALID_FUNCTION, DHookCallback callback=INVALID_FUNCTION);"
  },
  {
    "name": "DHookRaw",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "int",
    "comment": "Hook a raw pointer",
    "tags": {
      "param": [
        {
          "name": "setup",
          "description": "Setup handle to use to add the hook."
        },
        {
          "name": "post",
          "description": "true to make the hook a post hook. (If you need to change the return value or need the return value use a post hook! If you need to change params and return use a pre and post hook!)"
        },
        {
          "name": "addr",
          "description": "This pointer address."
        },
        {
          "name": "removalcb",
          "description": "Callback for when the hook is removed (Entity hooks are auto-removed on entity destroyed and will call this callback)"
        },
        {
          "name": "callback",
          "description": "Optional callback function, if not set here must be set when creating the hook."
        }
      ],
      "error": [
        "Invalid setup handle, invalid address, invalid hook type or invalid callback."
      ],
      "note": [],
      "return": "INVALID_HOOK_ID on fail a hookid on success"
    },
    "params": [
      {
        "name": "setup",
        "type": "Handle",
        "default": null,
        "description": "Setup handle to use to add the hook."
      },
      {
        "name": "post",
        "type": "bool",
        "default": null,
        "description": "true to make the hook a post hook. (If you need to change the return value or need the return value use a post hook! If you need to change params and return use a pre and post hook!)"
      },
      {
        "name": "addr",
        "type": "Address",
        "default": null,
        "description": "This pointer address."
      },
      {
        "name": "removalcb",
        "type": "DHookRemovalCB",
        "default": "",
        "description": "Callback for when the hook is removed (Entity hooks are auto-removed on entity destroyed and will call this callback)"
      },
      {
        "name": "callback",
        "type": "DHookCallback",
        "default": "",
        "description": "Optional callback function, if not set here must be set when creating the hook."
      }
    ],
    "full_declaration": "native int DHookRaw(Handle setup, bool post, Address addr, DHookRemovalCB removalcb=INVALID_FUNCTION, DHookCallback callback=INVALID_FUNCTION);"
  },
  {
    "name": "DHookRemoveHookID",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "bool",
    "comment": "Remove hook by hook id",
    "tags": {
      "param": [
        {
          "name": "hookid",
          "description": "Hook id to remove"
        }
      ],
      "error": [],
      "note": [],
      "return": "true on success, false otherwise"
    },
    "params": [
      {
        "name": "hookid",
        "type": "int",
        "default": null,
        "description": "Hook id to remove"
      }
    ],
    "full_declaration": "native bool DHookRemoveHookID(int hookid);"
  },
  {
    "name": "DHookGetParam",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "any",
    "comment": "Get param value (Use only for: int, entity, edict, bool or float param types)",
    "tags": {
      "param": [
        {
          "name": "hParams",
          "description": "Handle to params structure"
        },
        {
          "name": "num",
          "description": "Param number to get. (Example if the function has 2 params and you need the value of the first param num would be 1. 0 Will return the number of params stored)"
        }
      ],
      "error": [
        "Invalid handle. Invalid param number. Invalid param type."
      ],
      "note": [],
      "return": "value if num greater than 0. If 0 returns paramcount."
    },
    "params": [
      {
        "name": "hParams",
        "type": "Handle",
        "default": null,
        "description": "Handle to params structure"
      },
      {
        "name": "num",
        "type": "int",
        "default": null,
        "description": "Param number to get. (Example if the function has 2 params and you need the value of the first param num would be 1. 0 Will return the number of params stored)"
      }
    ],
    "full_declaration": "native any DHookGetParam(Handle hParams, int num);"
  },
  {
    "name": "DHookGetParamVector",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "void",
    "comment": "Get vector param value",
    "tags": {
      "param": [
        {
          "name": "hParams",
          "description": "Handle to params structure"
        },
        {
          "name": "num",
          "description": "Param number to get. (Example if the function has 2 params and you need the value of the first param num would be 1.)"
        },
        {
          "name": "vec",
          "description": "Vector buffer to store result."
        }
      ],
      "error": [
        "Invalid handle. Invalid param number. Invalid param type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hParams",
        "type": "Handle",
        "default": null,
        "description": "Handle to params structure"
      },
      {
        "name": "num",
        "type": "int",
        "default": null,
        "description": "Param number to get. (Example if the function has 2 params and you need the value of the first param num would be 1.)"
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Vector buffer to store result."
      }
    ],
    "full_declaration": "native void DHookGetParamVector(Handle hParams, int num, float vec[3]);"
  },
  {
    "name": "DHookGetParamString",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "void",
    "comment": "Get string param value",
    "tags": {
      "param": [
        {
          "name": "hParams",
          "description": "Handle to params structure"
        },
        {
          "name": "num",
          "description": "Param number to get. (Example if the function has 2 params and you need the value of the first param num would be 1.)"
        },
        {
          "name": "buffer",
          "description": "String buffer to store result"
        },
        {
          "name": "size",
          "description": "Buffer size"
        }
      ],
      "error": [
        "Invalid handle. Invalid param number. Invalid param type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hParams",
        "type": "Handle",
        "default": null,
        "description": "Handle to params structure"
      },
      {
        "name": "num",
        "type": "int",
        "default": null,
        "description": "Param number to get. (Example if the function has 2 params and you need the value of the first param num would be 1.)"
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "String buffer to store result"
      },
      {
        "name": "size",
        "type": "int",
        "default": null,
        "description": "Buffer size"
      }
    ],
    "full_declaration": "native void DHookGetParamString(Handle hParams, int num, char[] buffer, int size);"
  },
  {
    "name": "DHookSetParam",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "void",
    "comment": "Set param value (Use only for: int, entity, edict, bool or float param types)\n\nAn entity param type can be set to NULL using INVALID_ENT_REFERENCE (-1).",
    "tags": {
      "param": [
        {
          "name": "hParams",
          "description": "Handle to params structure"
        },
        {
          "name": "num",
          "description": "Param number to set (Example if the function has 2 params and you need to set the value of the first param num would be 1.)"
        },
        {
          "name": "value",
          "description": "Value to set it as (only pass int, bool, float or entity index)"
        }
      ],
      "error": [
        "Invalid handle. Invalid param number. Invalid param type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hParams",
        "type": "Handle",
        "default": null,
        "description": "Handle to params structure"
      },
      {
        "name": "num",
        "type": "int",
        "default": null,
        "description": "Param number to set (Example if the function has 2 params and you need to set the value of the first param num would be 1.)"
      },
      {
        "name": "value",
        "type": "any",
        "default": null,
        "description": "Value to set it as (only pass int, bool, float or entity index)"
      }
    ],
    "full_declaration": "native void DHookSetParam(Handle hParams, int num, any value);"
  },
  {
    "name": "DHookSetParamVector",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "void",
    "comment": "Set vector param value",
    "tags": {
      "param": [
        {
          "name": "hParams",
          "description": "Handle to params structure"
        },
        {
          "name": "num",
          "description": "Param number to set (Example if the function has 2 params and you need to set the value of the first param num would be 1.)"
        },
        {
          "name": "vec",
          "description": "Value to set vector as."
        }
      ],
      "error": [
        "Invalid handle. Invalid param number. Invalid param type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hParams",
        "type": "Handle",
        "default": null,
        "description": "Handle to params structure"
      },
      {
        "name": "num",
        "type": "int",
        "default": null,
        "description": "Param number to set (Example if the function has 2 params and you need to set the value of the first param num would be 1.)"
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Value to set vector as."
      }
    ],
    "full_declaration": "native void DHookSetParamVector(Handle hParams, int num, float vec[3]);"
  },
  {
    "name": "DHookSetParamString",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "void",
    "comment": "Set string param value",
    "tags": {
      "param": [
        {
          "name": "hParams",
          "description": "Handle to params structure"
        },
        {
          "name": "num",
          "description": "Param number to set (Example if the function has 2 params and you need to set the value of the first param num would be 1.)"
        },
        {
          "name": "value",
          "description": "Value to set string as."
        }
      ],
      "error": [
        "Invalid handle. Invalid param number. Invalid param type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hParams",
        "type": "Handle",
        "default": null,
        "description": "Handle to params structure"
      },
      {
        "name": "num",
        "type": "int",
        "default": null,
        "description": "Param number to set (Example if the function has 2 params and you need to set the value of the first param num would be 1.)"
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "Value to set string as."
      }
    ],
    "full_declaration": "native void DHookSetParamString(Handle hParams, int num, char[] value);"
  },
  {
    "name": "DHookGetReturn",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "any",
    "comment": "Get return value (Use only for: int, entity, bool or float return types)",
    "tags": {
      "param": [
        {
          "name": "hReturn",
          "description": "Handle to return structure"
        }
      ],
      "error": [
        "Invalid Handle, invalid type."
      ],
      "note": [],
      "return": "Returns default value if prehook returns actual value if post hook."
    },
    "params": [
      {
        "name": "hReturn",
        "type": "Handle",
        "default": null,
        "description": "Handle to return structure"
      }
    ],
    "full_declaration": "native any DHookGetReturn(Handle hReturn);"
  },
  {
    "name": "DHookGetReturnVector",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "void",
    "comment": "Get return vector value",
    "tags": {
      "param": [
        {
          "name": "hReturn",
          "description": "Handle to return structure"
        },
        {
          "name": "vec",
          "description": "Vector buffer to store result in. (In pre hooks will be default value (0.0,0.0,0.0))"
        }
      ],
      "error": [
        "Invalid Handle, invalid type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hReturn",
        "type": "Handle",
        "default": null,
        "description": "Handle to return structure"
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Vector buffer to store result in. (In pre hooks will be default value (0.0,0.0,0.0))"
      }
    ],
    "full_declaration": "native void DHookGetReturnVector(Handle hReturn, float vec[3]);"
  },
  {
    "name": "DHookGetReturnString",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "void",
    "comment": "Get return string value",
    "tags": {
      "param": [
        {
          "name": "hReturn",
          "description": "Handle to return structure"
        },
        {
          "name": "buffer",
          "description": "String buffer to store result in. (In pre hooks will be default value \"\")"
        },
        {
          "name": "size",
          "description": "String buffer size"
        }
      ],
      "error": [
        "Invalid Handle, invalid type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hReturn",
        "type": "Handle",
        "default": null,
        "description": "Handle to return structure"
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "String buffer to store result in. (In pre hooks will be default value \"\")"
      },
      {
        "name": "size",
        "type": "int",
        "default": null,
        "description": "String buffer size"
      }
    ],
    "full_declaration": "native void DHookGetReturnString(Handle hReturn, char[] buffer, int size);"
  },
  {
    "name": "DHookSetReturn",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "void",
    "comment": "Set return value (Use only for: int, entity, bool or float return types)\n\nAn entity return type can be set to NULL using INVALID_ENT_REFERENCE (-1).",
    "tags": {
      "param": [
        {
          "name": "hReturn",
          "description": "Handle to return structure"
        },
        {
          "name": "value",
          "description": "Value to set return as"
        }
      ],
      "error": [
        "Invalid Handle, invalid type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hReturn",
        "type": "Handle",
        "default": null,
        "description": "Handle to return structure"
      },
      {
        "name": "value",
        "type": "any",
        "default": null,
        "description": "Value to set return as"
      }
    ],
    "full_declaration": "native void DHookSetReturn(Handle hReturn, any value);"
  },
  {
    "name": "DHookSetReturnVector",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "void",
    "comment": "Set return vector value",
    "tags": {
      "param": [
        {
          "name": "hReturn",
          "description": "Handle to return structure"
        },
        {
          "name": "vec",
          "description": "Value to set return vector as"
        }
      ],
      "error": [
        "Invalid Handle, invalid type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hReturn",
        "type": "Handle",
        "default": null,
        "description": "Handle to return structure"
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Value to set return vector as"
      }
    ],
    "full_declaration": "native void DHookSetReturnVector(Handle hReturn, float vec[3]);"
  },
  {
    "name": "DHookSetReturnString",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "void",
    "comment": "Set return string value",
    "tags": {
      "param": [
        {
          "name": "hReturn",
          "description": "Handle to return structure"
        },
        {
          "name": "value",
          "description": "Value to set return string as"
        }
      ],
      "error": [
        "Invalid Handle, invalid type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hReturn",
        "type": "Handle",
        "default": null,
        "description": "Handle to return structure"
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "Value to set return string as"
      }
    ],
    "full_declaration": "native void DHookSetReturnString(Handle hReturn, char[] value);"
  },
  {
    "name": "DHookGetParamObjectPtrVar",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "any",
    "comment": "Gets an objects variable value",
    "tags": {
      "param": [
        {
          "name": "hParams",
          "description": "Handle to params structure"
        },
        {
          "name": "num",
          "description": "Param number to get."
        },
        {
          "name": "offset",
          "description": "Offset within the object to the var to get."
        },
        {
          "name": "type",
          "description": "Type of var it is"
        }
      ],
      "error": [
        "Invalid handle. Invalid param number. Invalid param type. Invalid Object type."
      ],
      "note": [],
      "return": "Value of the objects var. If EHANDLE type or entity returns entity index."
    },
    "params": [
      {
        "name": "hParams",
        "type": "Handle",
        "default": null,
        "description": "Handle to params structure"
      },
      {
        "name": "num",
        "type": "int",
        "default": null,
        "description": "Param number to get."
      },
      {
        "name": "offset",
        "type": "int",
        "default": null,
        "description": "Offset within the object to the var to get."
      },
      {
        "name": "type",
        "type": "ObjectValueType",
        "default": null,
        "description": "Type of var it is"
      }
    ],
    "full_declaration": "native any DHookGetParamObjectPtrVar(Handle hParams, int num, int offset, ObjectValueType type);"
  },
  {
    "name": "DHookSetParamObjectPtrVar",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "void",
    "comment": "Sets an objects variable value",
    "tags": {
      "param": [
        {
          "name": "hParams",
          "description": "Handle to params structure"
        },
        {
          "name": "num",
          "description": "Param number to set."
        },
        {
          "name": "offset",
          "description": "Offset within the object to the var to set."
        },
        {
          "name": "type",
          "description": "Type of var it is"
        },
        {
          "name": "value",
          "description": "The value to set the var to."
        }
      ],
      "error": [
        "Invalid handle. Invalid param number. Invalid param type. Invalid Object type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hParams",
        "type": "Handle",
        "default": null,
        "description": "Handle to params structure"
      },
      {
        "name": "num",
        "type": "int",
        "default": null,
        "description": "Param number to set."
      },
      {
        "name": "offset",
        "type": "int",
        "default": null,
        "description": "Offset within the object to the var to set."
      },
      {
        "name": "type",
        "type": "ObjectValueType",
        "default": null,
        "description": "Type of var it is"
      },
      {
        "name": "value",
        "type": "any",
        "default": null,
        "description": "The value to set the var to."
      }
    ],
    "full_declaration": "native void DHookSetParamObjectPtrVar(Handle hParams, int num, int offset, ObjectValueType type, any value);"
  },
  {
    "name": "DHookGetParamObjectPtrVarVector",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "void",
    "comment": "Gets an objects vector variable value",
    "tags": {
      "param": [
        {
          "name": "hParams",
          "description": "Handle to params structure"
        },
        {
          "name": "num",
          "description": "Param number to get."
        },
        {
          "name": "offset",
          "description": "Offset within the object to the var to get."
        },
        {
          "name": "type",
          "description": "Type of var it is"
        },
        {
          "name": "buffer",
          "description": "Buffer to store the result vector"
        }
      ],
      "error": [
        "Invalid handle. Invalid param number. Invalid param type. Invalid Object type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hParams",
        "type": "Handle",
        "default": null,
        "description": "Handle to params structure"
      },
      {
        "name": "num",
        "type": "int",
        "default": null,
        "description": "Param number to get."
      },
      {
        "name": "offset",
        "type": "int",
        "default": null,
        "description": "Offset within the object to the var to get."
      },
      {
        "name": "type",
        "type": "ObjectValueType",
        "default": null,
        "description": "Type of var it is"
      },
      {
        "name": "buffer",
        "type": "float",
        "default": null,
        "description": "Buffer to store the result vector"
      }
    ],
    "full_declaration": "native void DHookGetParamObjectPtrVarVector(Handle hParams, int num, int offset, ObjectValueType type, float buffer[3]);"
  },
  {
    "name": "DHookSetParamObjectPtrVarVector",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "void",
    "comment": "Sets an objects vector variable value",
    "tags": {
      "param": [
        {
          "name": "hParams",
          "description": "Handle to params structure"
        },
        {
          "name": "num",
          "description": "Param number to set."
        },
        {
          "name": "offset",
          "description": "Offset within the object to the var to set."
        },
        {
          "name": "type",
          "description": "Type of var it is"
        },
        {
          "name": "value",
          "description": "The value to set the vector var to."
        }
      ],
      "error": [
        "Invalid handle. Invalid param number. Invalid param type. Invalid Object type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hParams",
        "type": "Handle",
        "default": null,
        "description": "Handle to params structure"
      },
      {
        "name": "num",
        "type": "int",
        "default": null,
        "description": "Param number to set."
      },
      {
        "name": "offset",
        "type": "int",
        "default": null,
        "description": "Offset within the object to the var to set."
      },
      {
        "name": "type",
        "type": "ObjectValueType",
        "default": null,
        "description": "Type of var it is"
      },
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "The value to set the vector var to."
      }
    ],
    "full_declaration": "native void DHookSetParamObjectPtrVarVector(Handle hParams, int num, int offset, ObjectValueType type, float value[3]);"
  },
  {
    "name": "DHookGetParamObjectPtrString",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "void",
    "comment": "Gets an objects string variable value",
    "tags": {
      "param": [
        {
          "name": "hParams",
          "description": "Handle to params structure"
        },
        {
          "name": "num",
          "description": "Param number to get."
        },
        {
          "name": "offset",
          "description": "Offset within the object to the var to get."
        },
        {
          "name": "type",
          "description": "Type of var it is"
        },
        {
          "name": "buffer",
          "description": "Buffer to store the result vector"
        },
        {
          "name": "size",
          "description": "Size of the buffer"
        }
      ],
      "error": [
        "Invalid handle. Invalid param number. Invalid param type. Invalid Object type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hParams",
        "type": "Handle",
        "default": null,
        "description": "Handle to params structure"
      },
      {
        "name": "num",
        "type": "int",
        "default": null,
        "description": "Param number to get."
      },
      {
        "name": "offset",
        "type": "int",
        "default": null,
        "description": "Offset within the object to the var to get."
      },
      {
        "name": "type",
        "type": "ObjectValueType",
        "default": null,
        "description": "Type of var it is"
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the result vector"
      },
      {
        "name": "size",
        "type": "int",
        "default": null,
        "description": "Size of the buffer"
      }
    ],
    "full_declaration": "native void DHookGetParamObjectPtrString(Handle hParams, int num, int offset, ObjectValueType type, char[] buffer, int size);"
  },
  {
    "name": "DHookIsNullParam",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "bool",
    "comment": "Checks if a pointer param is null",
    "tags": {
      "param": [
        {
          "name": "hParams",
          "description": "Handle to params structure"
        },
        {
          "name": "num",
          "description": "Param number to check."
        }
      ],
      "error": [
        "Non pointer param"
      ],
      "note": [],
      "return": "true if null, false otherwise."
    },
    "params": [
      {
        "name": "hParams",
        "type": "Handle",
        "default": null,
        "description": "Handle to params structure"
      },
      {
        "name": "num",
        "type": "int",
        "default": null,
        "description": "Param number to check."
      }
    ],
    "full_declaration": "native bool DHookIsNullParam(Handle hParams, int num);"
  },
  {
    "name": "DHookGetParamAddress",
    "type": "native",
    "source_file": "dhooks.inc",
    "return_type": "Address",
    "comment": "Get param address (Use only for ptr param types)",
    "tags": {
      "param": [
        {
          "name": "hParams",
          "description": "Handle to params structure"
        },
        {
          "name": "num",
          "description": "Param number to get. (Example if the function has 2 params and you need the value of the first param num would be 1.)"
        }
      ],
      "error": [
        "Invalid handle. Invalid param number. Invalid param type."
      ],
      "note": [],
      "return": "Address of the parameter."
    },
    "params": [
      {
        "name": "hParams",
        "type": "Handle",
        "default": null,
        "description": "Handle to params structure"
      },
      {
        "name": "num",
        "type": "int",
        "default": null,
        "description": "Param number to get. (Example if the function has 2 params and you need the value of the first param num would be 1.)"
      }
    ],
    "full_declaration": "native Address DHookGetParamAddress(Handle hParams, int num);"
  },
  {
    "name": "GetMaxEntities",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "int",
    "comment": "Returns the maximum number of networked entities.\n\nNote: For legacy reasons, this only returns the maximum\nnetworked entities (maximum edicts), rather than total\nmaximum entities.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "Maximum number of networked entities."
    },
    "params": [],
    "full_declaration": "native int GetMaxEntities();"
  },
  {
    "name": "GetEntityCount",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "int",
    "comment": "Returns the number of networked entities in the server.\n\nNote: For legacy reasons, this only returns the current count\nof networked entities (current edicts), rather than total\ncount of current entities.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "Number of entities in the server."
    },
    "params": [],
    "full_declaration": "native int GetEntityCount();"
  },
  {
    "name": "IsValidEntity",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "bool",
    "comment": "Returns whether or not an entity is valid.  Returns false\nif there is no matching CBaseEntity for this entity index.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Index of the entity."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if valid, false otherwise."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Index of the entity."
      }
    ],
    "full_declaration": "native bool IsValidEntity(int entity);"
  },
  {
    "name": "IsValidEdict",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "bool",
    "comment": "Returns whether or not an edict index is valid.",
    "tags": {
      "param": [
        {
          "name": "edict",
          "description": "Index of the edict."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if valid, false otherwise."
    },
    "params": [
      {
        "name": "edict",
        "type": "int",
        "default": null,
        "description": "Index of the edict."
      }
    ],
    "full_declaration": "native bool IsValidEdict(int edict);"
  },
  {
    "name": "IsEntNetworkable",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "bool",
    "comment": "Returns whether or not an entity has a valid networkable edict.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Index of the entity."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if networkable, false if invalid or not networkable."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Index of the entity."
      }
    ],
    "full_declaration": "native bool IsEntNetworkable(int entity);"
  },
  {
    "name": "CreateEdict",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "int",
    "comment": "Creates a new edict (the basis of a networkable entity)",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "Index of the edict, 0 on failure."
    },
    "params": [],
    "full_declaration": "native int CreateEdict();"
  },
  {
    "name": "RemoveEdict",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "void",
    "comment": "Removes an edict from the world.",
    "tags": {
      "param": [
        {
          "name": "edict",
          "description": "Index of the edict."
        }
      ],
      "error": [
        "Invalid edict index."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "edict",
        "type": "int",
        "default": null,
        "description": "Index of the edict."
      }
    ],
    "full_declaration": "native void RemoveEdict(int edict);"
  },
  {
    "name": "RemoveEntity",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "void",
    "comment": "Marks an entity for deletion.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Index of the entity."
        }
      ],
      "error": [
        "Invalid entity index."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Index of the entity."
      }
    ],
    "full_declaration": "native void RemoveEntity(int entity);"
  },
  {
    "name": "GetEdictFlags",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "int",
    "comment": "Returns the flags on an edict.  These are not the same as entity flags.",
    "tags": {
      "param": [
        {
          "name": "edict",
          "description": "Index of the entity."
        }
      ],
      "error": [
        "Invalid edict index."
      ],
      "note": [],
      "return": "Edict flags."
    },
    "params": [
      {
        "name": "edict",
        "type": "int",
        "default": null,
        "description": "Index of the entity."
      }
    ],
    "full_declaration": "native int GetEdictFlags(int edict);"
  },
  {
    "name": "SetEdictFlags",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "void",
    "comment": "Sets the flags on an edict.  These are not the same as entity flags.",
    "tags": {
      "param": [
        {
          "name": "edict",
          "description": "Index of the entity."
        },
        {
          "name": "flags",
          "description": "Flags to set."
        }
      ],
      "error": [
        "Invalid edict index."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "edict",
        "type": "int",
        "default": null,
        "description": "Index of the entity."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "Flags to set."
      }
    ],
    "full_declaration": "native void SetEdictFlags(int edict, int flags);"
  },
  {
    "name": "GetEdictClassname",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "bool",
    "comment": "Retrieves an edict classname.",
    "tags": {
      "param": [
        {
          "name": "edict",
          "description": "Index of the entity."
        },
        {
          "name": "clsname",
          "description": "Buffer to store the classname."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of the buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false if there is no classname set."
    },
    "params": [
      {
        "name": "edict",
        "type": "int",
        "default": null,
        "description": "Index of the entity."
      },
      {
        "name": "clsname",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the classname."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the buffer."
      }
    ],
    "full_declaration": "native bool GetEdictClassname(int edict, char[] clsname, int maxlength);"
  },
  {
    "name": "GetEntityNetClass",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "bool",
    "comment": "Retrieves an entity's networkable serverclass name.\nThis is not the same as the classname and is used for networkable state changes.",
    "tags": {
      "param": [
        {
          "name": "edict",
          "description": "Index of the entity."
        },
        {
          "name": "clsname",
          "description": "Buffer to store the serverclass name."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of the buffer."
        }
      ],
      "error": [
        "Invalid edict index."
      ],
      "note": [],
      "return": "True on success, false if the edict is not networkable."
    },
    "params": [
      {
        "name": "edict",
        "type": "int",
        "default": null,
        "description": "Index of the entity."
      },
      {
        "name": "clsname",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the serverclass name."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the buffer."
      }
    ],
    "full_declaration": "native bool GetEntityNetClass(int edict, char[] clsname, int maxlength);"
  },
  {
    "name": "ChangeEdictState",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "void",
    "comment": "Marks an entity as state changed.  This can be useful if you set an offset\nand wish for it to be immediately changed over the network.  By default this\nis not done for offset setting functions.",
    "tags": {
      "param": [
        {
          "name": "edict",
          "description": "Index to the edict."
        },
        {
          "name": "offset",
          "description": "Offset to mark as changed.  If 0, the entire edict is marked as changed."
        }
      ],
      "error": [
        "Invalid entity or offset out of bounds."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "edict",
        "type": "int",
        "default": null,
        "description": "Index to the edict."
      },
      {
        "name": "offset",
        "type": "int",
        "default": "",
        "description": "Offset to mark as changed.  If 0, the entire edict is marked as changed."
      }
    ],
    "full_declaration": "native void ChangeEdictState(int edict, int offset = 0);"
  },
  {
    "name": "GetEntData",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "int",
    "comment": "Peeks into an entity's object data and retrieves the integer value at\nthe given offset.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Edict index."
        },
        {
          "name": "offset",
          "description": "Offset to use."
        },
        {
          "name": "size",
          "description": "Number of bytes to read (valid values are 1, 2, or 4)."
        }
      ],
      "error": [
        "Invalid entity or offset out of reasonable bounds."
      ],
      "note": [],
      "return": "Value at the given memory location."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Edict index."
      },
      {
        "name": "offset",
        "type": "int",
        "default": null,
        "description": "Offset to use."
      },
      {
        "name": "size",
        "type": "int",
        "default": "",
        "description": "Number of bytes to read (valid values are 1, 2, or 4)."
      }
    ],
    "full_declaration": "native int GetEntData(int entity, int offset, int size=4);"
  },
  {
    "name": "SetEntData",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "void",
    "comment": "Peeks into an entity's object data and sets the integer value at\nthe given offset.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Edict index."
        },
        {
          "name": "offset",
          "description": "Offset to use."
        },
        {
          "name": "value",
          "description": "Value to set."
        },
        {
          "name": "size",
          "description": "Number of bytes to write (valid values are 1, 2, or 4)."
        },
        {
          "name": "changeState",
          "description": "If true, change will be sent over the network."
        }
      ],
      "error": [
        "Invalid entity or offset out of reasonable bounds."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Edict index."
      },
      {
        "name": "offset",
        "type": "int",
        "default": null,
        "description": "Offset to use."
      },
      {
        "name": "value",
        "type": "any",
        "default": null,
        "description": "Value to set."
      },
      {
        "name": "size",
        "type": "int",
        "default": "",
        "description": "Number of bytes to write (valid values are 1, 2, or 4)."
      },
      {
        "name": "changeState",
        "type": "bool",
        "default": "",
        "description": "If true, change will be sent over the network."
      }
    ],
    "full_declaration": "native void SetEntData(int entity, int offset, any value, int size=4, bool changeState=false);"
  },
  {
    "name": "GetEntDataFloat",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "float",
    "comment": "Peeks into an entity's object data and retrieves the float value at\nthe given offset.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Edict index."
        },
        {
          "name": "offset",
          "description": "Offset to use."
        }
      ],
      "error": [
        "Invalid entity or offset out of reasonable bounds."
      ],
      "note": [],
      "return": "Value at the given memory location."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Edict index."
      },
      {
        "name": "offset",
        "type": "int",
        "default": null,
        "description": "Offset to use."
      }
    ],
    "full_declaration": "native float GetEntDataFloat(int entity, int offset);"
  },
  {
    "name": "SetEntDataFloat",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "void",
    "comment": "Peeks into an entity's object data and sets the float value at\nthe given offset.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Edict index."
        },
        {
          "name": "offset",
          "description": "Offset to use."
        },
        {
          "name": "value",
          "description": "Value to set."
        },
        {
          "name": "changeState",
          "description": "If true, change will be sent over the network."
        }
      ],
      "error": [
        "Invalid entity or offset out of reasonable bounds."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Edict index."
      },
      {
        "name": "offset",
        "type": "int",
        "default": null,
        "description": "Offset to use."
      },
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Value to set."
      },
      {
        "name": "changeState",
        "type": "bool",
        "default": "",
        "description": "If true, change will be sent over the network."
      }
    ],
    "full_declaration": "native void SetEntDataFloat(int entity, int offset, float value, bool changeState=false);"
  },
  {
    "name": "GetEntDataEnt",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "int",
    "comment": "This function is deprecated.  Use GetEntDataEnt2 instead, for\nreasons explained in the notes.\n\nNote: This function returns 0 on failure, which may be misleading,\nas the number 0 is also used for the world entity index.\n\nNote: This function makes no attempt to validate the returned\nentity, and in fact, it could be garbage or completely unexpected.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Edict index."
        },
        {
          "name": "offset",
          "description": "Offset to use."
        }
      ],
      "error": [
        "Invalid entity or offset out of reasonable bounds."
      ],
      "note": [],
      "return": "Entity index at the given location, or 0 if none.",
      "deprecated": [
        "Use GetEntDataEnt2() instead."
      ]
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Edict index."
      },
      {
        "name": "offset",
        "type": "int",
        "default": null,
        "description": "Offset to use."
      }
    ],
    "full_declaration": "native int GetEntDataEnt(int entity, int offset);"
  },
  {
    "name": "SetEntDataEnt",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "void",
    "comment": "This function is deprecated.   Use SetEntDataEnt2 instead, for\nreasons explained in the notes.\n\nNote: This function uses 0 as an indicator to unset data, but\n0 is also the world entity index.  Thus, a property cannot\nbe set to the world entity using this native.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Edict index."
        },
        {
          "name": "offset",
          "description": "Offset to use."
        },
        {
          "name": "other",
          "description": "Entity index to set, or 0 to clear."
        },
        {
          "name": "changeState",
          "description": "If true, change will be sent over the network."
        }
      ],
      "error": [
        "Invalid entity or offset out of reasonable bounds."
      ],
      "note": [],
      "return": "",
      "deprecated": [
        "Use SetEntDataEnt2() instead."
      ]
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Edict index."
      },
      {
        "name": "offset",
        "type": "int",
        "default": null,
        "description": "Offset to use."
      },
      {
        "name": "other",
        "type": "int",
        "default": null,
        "description": "Entity index to set, or 0 to clear."
      },
      {
        "name": "changeState",
        "type": "bool",
        "default": "",
        "description": "If true, change will be sent over the network."
      }
    ],
    "full_declaration": "native void SetEntDataEnt(int entity, int offset, int other, bool changeState=false);"
  },
  {
    "name": "GetEntDataEnt2",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "int",
    "comment": "Peeks into an entity's object data and retrieves the entity index\nat the given offset.\n\nNote: This will only work on offsets that are stored as \"entity\nhandles\" (which usually looks like m_h* in properties).  These\nare not SourceMod Handles, but internal Source structures.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Edict index."
        },
        {
          "name": "offset",
          "description": "Offset to use."
        }
      ],
      "error": [
        "Invalid input entity, or offset out of reasonable bounds."
      ],
      "note": [],
      "return": "Entity index at the given location.  If there is no entity, or the stored entity is invalid, then -1 is returned."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Edict index."
      },
      {
        "name": "offset",
        "type": "int",
        "default": null,
        "description": "Offset to use."
      }
    ],
    "full_declaration": "native int GetEntDataEnt2(int entity, int offset);"
  },
  {
    "name": "SetEntDataEnt2",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "void",
    "comment": "Peeks into an entity's object data and sets the entity index at the\ngiven offset.\n\nNote: This will only work on offsets that are stored as \"entity\nhandles\" (which usually looks like m_h* in properties).  These\nare not SourceMod Handles, but internal Source structures.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Edict index."
        },
        {
          "name": "offset",
          "description": "Offset to use."
        },
        {
          "name": "other",
          "description": "Entity index to set, or -1 to clear."
        },
        {
          "name": "changeState",
          "description": "If true, change will be sent over the network."
        }
      ],
      "error": [
        "Invalid input entity, or offset out of reasonable bounds."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Edict index."
      },
      {
        "name": "offset",
        "type": "int",
        "default": null,
        "description": "Offset to use."
      },
      {
        "name": "other",
        "type": "int",
        "default": null,
        "description": "Entity index to set, or -1 to clear."
      },
      {
        "name": "changeState",
        "type": "bool",
        "default": "",
        "description": "If true, change will be sent over the network."
      }
    ],
    "full_declaration": "native void SetEntDataEnt2(int entity, int offset, int other, bool changeState=false);"
  },
  {
    "name": "GetEntDataVector",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "void",
    "comment": "Peeks into an entity's object data and retrieves the vector at the\ngiven offset.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Edict index."
        },
        {
          "name": "offset",
          "description": "Offset to use."
        },
        {
          "name": "vec",
          "description": "Vector buffer to store data in."
        }
      ],
      "error": [
        "Invalid entity or offset out of reasonable bounds."
      ],
      "note": [
        "Both a Vector and a QAngle are three floats.  This is a convenience function and will work with both types."
      ],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Edict index."
      },
      {
        "name": "offset",
        "type": "int",
        "default": null,
        "description": "Offset to use."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Vector buffer to store data in."
      }
    ],
    "full_declaration": "native void GetEntDataVector(int entity, int offset, float vec[3]);"
  },
  {
    "name": "SetEntDataVector",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "void",
    "comment": "Peeks into an entity's object data and sets the vector at the given\noffset.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Edict index."
        },
        {
          "name": "offset",
          "description": "Offset to use."
        },
        {
          "name": "vec",
          "description": "Vector to set."
        },
        {
          "name": "changeState",
          "description": "If true, change will be sent over the network."
        }
      ],
      "error": [
        "Invalid entity or offset out of reasonable bounds."
      ],
      "note": [
        "Both a Vector and a QAngle are three floats.  This is a convenience function and will work with both types."
      ],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Edict index."
      },
      {
        "name": "offset",
        "type": "int",
        "default": null,
        "description": "Offset to use."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Vector to set."
      },
      {
        "name": "changeState",
        "type": "bool",
        "default": "",
        "description": "If true, change will be sent over the network."
      }
    ],
    "full_declaration": "native void SetEntDataVector(int entity, int offset, const float vec[3], bool changeState=false);"
  },
  {
    "name": "GetEntDataString",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "int",
    "comment": "Peeks into an entity's object data and retrieves the string at\nthe given offset.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Edict index."
        },
        {
          "name": "offset",
          "description": "Offset to use."
        },
        {
          "name": "buffer",
          "description": "Destination string buffer."
        },
        {
          "name": "maxlen",
          "description": "Maximum length of output string buffer."
        }
      ],
      "error": [
        "Invalid entity or offset out of reasonable bounds."
      ],
      "note": [],
      "return": "Number of non-null bytes written."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Edict index."
      },
      {
        "name": "offset",
        "type": "int",
        "default": null,
        "description": "Offset to use."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Destination string buffer."
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "Maximum length of output string buffer."
      }
    ],
    "full_declaration": "native int GetEntDataString(int entity, int offset, char[] buffer, int maxlen);"
  },
  {
    "name": "SetEntDataString",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "int",
    "comment": "Peeks into an entity's object data and sets the string at\nthe given offset.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Edict index."
        },
        {
          "name": "offset",
          "description": "Offset to use."
        },
        {
          "name": "buffer",
          "description": "String to set."
        },
        {
          "name": "maxlen",
          "description": "Maximum length of bytes to write."
        },
        {
          "name": "changeState",
          "description": "If true, change will be sent over the network."
        }
      ],
      "error": [
        "Invalid entity or offset out of reasonable bounds."
      ],
      "note": [],
      "return": "Number of non-null bytes written."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Edict index."
      },
      {
        "name": "offset",
        "type": "int",
        "default": null,
        "description": "Offset to use."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "String to set."
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "Maximum length of bytes to write."
      },
      {
        "name": "changeState",
        "type": "bool",
        "default": "",
        "description": "If true, change will be sent over the network."
      }
    ],
    "full_declaration": "native int SetEntDataString(int entity, int offset, const char[] buffer, int maxlen, bool changeState=false);"
  },
  {
    "name": "FindSendPropOffs",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "int",
    "comment": "Given a ServerClass name, finds a networkable send property offset.\nThis information is cached for future calls.\n\nNote, this function may return offsets that do not work!\nIf a property is nested beneath a parent object, the resulting offset\nwill be invalid for direct use with data functions.  Therefore, you\nshould use FindSendPropInfo() instead.  An example of such a property is\nCTFPlayer::DT_LocalPlayer.m_nDisguiseClass on Team Fortress.",
    "tags": {
      "param": [
        {
          "name": "cls",
          "description": "Classname."
        },
        {
          "name": "prop",
          "description": "Property name."
        }
      ],
      "error": [],
      "note": [],
      "return": "An offset, or -1 on failure.",
      "deprecated": [
        "Use FindSendPropInfo instead, or HasEntProp if you just want to check for existence."
      ]
    },
    "params": [
      {
        "name": "cls",
        "type": "char[]",
        "default": null,
        "description": "Classname."
      },
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property name."
      }
    ],
    "full_declaration": "native int FindSendPropOffs(const char[] cls, const char[] prop);"
  },
  {
    "name": "FindSendPropInfo",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "int",
    "comment": "Given a ServerClass name, finds a networkable send property offset.\nThis information is cached for future calls.",
    "tags": {
      "param": [
        {
          "name": "cls",
          "description": "Classname."
        },
        {
          "name": "prop",
          "description": "Property name."
        },
        {
          "name": "type",
          "description": "Optional parameter to store the type."
        },
        {
          "name": "num_bits",
          "description": "Optional parameter to store the number of bits the field uses, if applicable (otherwise 0 is stored).  The number of bits varies for integers and floats, and is always 0 for strings."
        },
        {
          "name": "local_offset",
          "description": "Optional parameter to store the local offset, as FindSendPropOffs() would return."
        },
        {
          "name": "array_size",
          "description": "Optional parameter to store array size, 0 if not an array."
        }
      ],
      "error": [],
      "note": [],
      "return": "On success, returns an absolutely computed offset. If no offset is available, 0 is returned. If the property is not found, -1 is returned."
    },
    "params": [
      {
        "name": "cls",
        "type": "char[]",
        "default": null,
        "description": "Classname."
      },
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property name."
      },
      {
        "name": "type",
        "type": "PropFieldType",
        "default": "",
        "description": "Optional parameter to store the type."
      },
      {
        "name": "num_bits",
        "type": "int",
        "default": "",
        "description": "Optional parameter to store the number of bits the field uses, if applicable (otherwise 0 is stored).  The number of bits varies for integers and floats, and is always 0 for strings."
      },
      {
        "name": "local_offset",
        "type": "int",
        "default": "",
        "description": "Optional parameter to store the local offset, as FindSendPropOffs() would return."
      },
      {
        "name": "array_size",
        "type": "int",
        "default": "",
        "description": "Optional parameter to store array size, 0 if not an array."
      }
    ],
    "full_declaration": "native int FindSendPropInfo(const char[] cls, \t\t\t\t\t\tconst char[] prop, \t\t\t\t\t\tPropFieldType &type=view_as<PropFieldType>(0), \t\t\t\t\t\tint &num_bits=0, \t\t\t\t\t\tint &local_offset=0, \t\t\t\t\t\tint &array_size=0);"
  },
  {
    "name": "FindDataMapOffs",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "int",
    "comment": "Given an entity, finds a datamap property offset.\nThis information is cached for future calls.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index."
        },
        {
          "name": "prop",
          "description": "Property name."
        },
        {
          "name": "type",
          "description": "Optional parameter to store the type."
        },
        {
          "name": "num_bits",
          "description": "Optional parameter to store the number of bits the field uses.  The bit count will either be 1 (for boolean) or divisible by 8 (including 0 if unknown)."
        }
      ],
      "error": [],
      "note": [],
      "return": "An offset, or -1 on failure.",
      "deprecated": [
        "Use FindDataMapInfo instead, or HasEntProp if you just want to check for existence."
      ]
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      },
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property name."
      },
      {
        "name": "type",
        "type": "PropFieldType",
        "default": "",
        "description": "Optional parameter to store the type."
      },
      {
        "name": "num_bits",
        "type": "int",
        "default": "",
        "description": "Optional parameter to store the number of bits the field uses.  The bit count will either be 1 (for boolean) or divisible by 8 (including 0 if unknown)."
      }
    ],
    "full_declaration": "native int FindDataMapOffs(int entity, \t\t\t\t\t   const char[] prop, \t\t\t\t\t   PropFieldType &type=view_as<PropFieldType>(0), \t\t\t\t\t   int &num_bits=0);"
  },
  {
    "name": "FindDataMapInfo",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "int",
    "comment": "Given an entity, finds a nested datamap property offset.\nThis information is cached for future calls.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index."
        },
        {
          "name": "prop",
          "description": "Property name."
        },
        {
          "name": "type",
          "description": "Optional parameter to store the type."
        },
        {
          "name": "num_bits",
          "description": "Optional parameter to store the number of bits the field uses.  The bit count will either be 1 (for boolean) or divisible by 8 (including 0 if unknown)."
        },
        {
          "name": "local_offset",
          "description": "Optional parameter to store the local offset, as FindDataMapOffs() would return."
        }
      ],
      "error": [],
      "note": [],
      "return": "An offset, or -1 on failure."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      },
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property name."
      },
      {
        "name": "type",
        "type": "PropFieldType",
        "default": "",
        "description": "Optional parameter to store the type."
      },
      {
        "name": "num_bits",
        "type": "int",
        "default": "",
        "description": "Optional parameter to store the number of bits the field uses.  The bit count will either be 1 (for boolean) or divisible by 8 (including 0 if unknown)."
      },
      {
        "name": "local_offset",
        "type": "int",
        "default": "",
        "description": "Optional parameter to store the local offset, as FindDataMapOffs() would return."
      }
    ],
    "full_declaration": "native int FindDataMapInfo(int entity, \t\t\t\t\t   const char[] prop, \t\t\t\t\t   PropFieldType &type=view_as<PropFieldType>(0), \t\t\t\t\t   int &num_bits=0, \t\t\t\t\t   int &local_offset=0);"
  },
  {
    "name": "GetEntSendPropOffs",
    "type": "stock",
    "source_file": "entity.inc",
    "return_type": "int",
    "comment": "Wrapper function for finding a send property for a particular entity.",
    "tags": {
      "param": [
        {
          "name": "ent",
          "description": "Entity index."
        },
        {
          "name": "prop",
          "description": "Property name."
        },
        {
          "name": "actual",
          "description": "Defaults to false for backwards compatibility. If true, the newer FindSendPropInfo() function is used instead."
        }
      ],
      "error": [],
      "note": [],
      "return": "An offset, or -1 on failure."
    },
    "params": [
      {
        "name": "ent",
        "type": "int",
        "default": null,
        "description": "Entity index."
      },
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property name."
      },
      {
        "name": "actual",
        "type": "bool",
        "default": "",
        "description": "Defaults to false for backwards compatibility. If true, the newer FindSendPropInfo() function is used instead."
      }
    ],
    "full_declaration": "stock int GetEntSendPropOffs(int ent, const char[] prop, bool actual=false) { \tchar cls[64];  \tif (!GetEntityNetClass(ent, cls, sizeof(cls))) \t{ \t\treturn -1; \t}  \tint local = -1; \tint offset = FindSendPropInfo(cls, prop, _, _, local);"
  },
  {
    "name": "HasEntProp",
    "type": "stock",
    "source_file": "entity.inc",
    "return_type": "bool",
    "comment": "Checks if an entity property exists on an entity.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity/edict index."
        },
        {
          "name": "type",
          "description": "Property type."
        },
        {
          "name": "prop",
          "description": "Property name."
        }
      ],
      "error": [
        "Invalid entity."
      ],
      "note": [],
      "return": "Whether the property exists on the entity."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity/edict index."
      },
      {
        "name": "type",
        "type": "PropType",
        "default": null,
        "description": "Property type."
      },
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property name."
      }
    ],
    "full_declaration": "stock bool HasEntProp(int entity, PropType type, const char[] prop) { \tif (type == Prop_Data) \t{ \t\treturn (FindDataMapInfo(entity, prop) != -1);"
  },
  {
    "name": "GetEntProp",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "int",
    "comment": "Retrieves an integer value from an entity's property.\n\nThis function is considered safer and more robust over GetEntData,\nbecause it performs strict offset checking and typing rules.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity/edict index."
        },
        {
          "name": "type",
          "description": "Property type."
        },
        {
          "name": "prop",
          "description": "Property name."
        },
        {
          "name": "size",
          "description": "Number of bytes to write (valid values are 1, 2, or 4). This value is auto-detected, and the size parameter is only used as a fallback in case detection fails."
        },
        {
          "name": "element",
          "description": "Element # (starting from 0) if property is an array."
        }
      ],
      "error": [
        "Invalid entity or property not found."
      ],
      "note": [],
      "return": "Value at the given property offset."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity/edict index."
      },
      {
        "name": "type",
        "type": "PropType",
        "default": null,
        "description": "Property type."
      },
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property name."
      },
      {
        "name": "size",
        "type": "int",
        "default": "",
        "description": "Number of bytes to write (valid values are 1, 2, or 4). This value is auto-detected, and the size parameter is only used as a fallback in case detection fails."
      },
      {
        "name": "element",
        "type": "int",
        "default": "",
        "description": "Element # (starting from 0) if property is an array."
      }
    ],
    "full_declaration": "native int GetEntProp(int entity, PropType type, const char[] prop, int size=4, int element=0);"
  },
  {
    "name": "SetEntProp",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "void",
    "comment": "Sets an integer value in an entity's property.\n\nThis function is considered safer and more robust over SetEntData,\nbecause it performs strict offset checking and typing rules.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity/edict index."
        },
        {
          "name": "type",
          "description": "Property type."
        },
        {
          "name": "prop",
          "description": "Property name."
        },
        {
          "name": "value",
          "description": "Value to set."
        },
        {
          "name": "size",
          "description": "Number of bytes to write (valid values are 1, 2, or 4). This value is auto-detected, and the size parameter is only used as a fallback in case detection fails."
        },
        {
          "name": "element",
          "description": "Element # (starting from 0) if property is an array."
        }
      ],
      "error": [
        "Invalid entity or offset out of reasonable bounds."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity/edict index."
      },
      {
        "name": "type",
        "type": "PropType",
        "default": null,
        "description": "Property type."
      },
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property name."
      },
      {
        "name": "value",
        "type": "any",
        "default": null,
        "description": "Value to set."
      },
      {
        "name": "size",
        "type": "int",
        "default": "",
        "description": "Number of bytes to write (valid values are 1, 2, or 4). This value is auto-detected, and the size parameter is only used as a fallback in case detection fails."
      },
      {
        "name": "element",
        "type": "int",
        "default": "",
        "description": "Element # (starting from 0) if property is an array."
      }
    ],
    "full_declaration": "native void SetEntProp(int entity, PropType type, const char[] prop, any value, int size=4, int element=0);"
  },
  {
    "name": "GetEntPropFloat",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "float",
    "comment": "Retrieves a float value from an entity's property.\n\nThis function is considered safer and more robust over GetEntDataFloat,\nbecause it performs strict offset checking and typing rules.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity/edict index."
        },
        {
          "name": "type",
          "description": "Property type."
        },
        {
          "name": "prop",
          "description": "Property name."
        },
        {
          "name": "element",
          "description": "Element # (starting from 0) if property is an array."
        }
      ],
      "error": [
        "Invalid entity or offset out of reasonable bounds."
      ],
      "note": [],
      "return": "Value at the given property offset."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity/edict index."
      },
      {
        "name": "type",
        "type": "PropType",
        "default": null,
        "description": "Property type."
      },
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property name."
      },
      {
        "name": "element",
        "type": "int",
        "default": "",
        "description": "Element # (starting from 0) if property is an array."
      }
    ],
    "full_declaration": "native float GetEntPropFloat(int entity, PropType type, const char[] prop, int element=0);"
  },
  {
    "name": "SetEntPropFloat",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "void",
    "comment": "Sets a float value in an entity's property.\n\nThis function is considered safer and more robust over SetEntDataFloat,\nbecause it performs strict offset checking and typing rules.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity/edict index."
        },
        {
          "name": "type",
          "description": "Property type."
        },
        {
          "name": "prop",
          "description": "Property name."
        },
        {
          "name": "value",
          "description": "Value to set."
        },
        {
          "name": "element",
          "description": "Element # (starting from 0) if property is an array."
        }
      ],
      "error": [
        "Invalid entity or offset out of reasonable bounds."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity/edict index."
      },
      {
        "name": "type",
        "type": "PropType",
        "default": null,
        "description": "Property type."
      },
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property name."
      },
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Value to set."
      },
      {
        "name": "element",
        "type": "int",
        "default": "",
        "description": "Element # (starting from 0) if property is an array."
      }
    ],
    "full_declaration": "native void SetEntPropFloat(int entity, PropType type, const char[] prop, float value, int element=0);"
  },
  {
    "name": "GetEntPropEnt",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "int",
    "comment": "Retrieves an entity index from an entity's property.\n\nThis function is considered safer and more robust over GetEntDataEnt*,\nbecause it performs strict offset checking and typing rules.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity/edict index."
        },
        {
          "name": "type",
          "description": "Property type."
        },
        {
          "name": "prop",
          "description": "Property name."
        },
        {
          "name": "element",
          "description": "Element # (starting from 0) if property is an array."
        }
      ],
      "error": [
        "Invalid entity or offset out of reasonable bounds."
      ],
      "note": [],
      "return": "Entity index at the given property. If there is no entity, or the entity is not valid, then -1 is returned."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity/edict index."
      },
      {
        "name": "type",
        "type": "PropType",
        "default": null,
        "description": "Property type."
      },
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property name."
      },
      {
        "name": "element",
        "type": "int",
        "default": "",
        "description": "Element # (starting from 0) if property is an array."
      }
    ],
    "full_declaration": "native int GetEntPropEnt(int entity, PropType type, const char[] prop, int element=0);"
  },
  {
    "name": "SetEntPropEnt",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "void",
    "comment": "Sets an entity index in an entity's property.\n\nThis function is considered safer and more robust over SetEntDataEnt*,\nbecause it performs strict offset checking and typing rules.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity/edict index."
        },
        {
          "name": "type",
          "description": "Property type."
        },
        {
          "name": "prop",
          "description": "Property name."
        },
        {
          "name": "other",
          "description": "Entity index to set, or -1 to unset."
        },
        {
          "name": "element",
          "description": "Element # (starting from 0) if property is an array."
        }
      ],
      "error": [
        "Invalid entity or offset out of reasonable bounds."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity/edict index."
      },
      {
        "name": "type",
        "type": "PropType",
        "default": null,
        "description": "Property type."
      },
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property name."
      },
      {
        "name": "other",
        "type": "int",
        "default": null,
        "description": "Entity index to set, or -1 to unset."
      },
      {
        "name": "element",
        "type": "int",
        "default": "",
        "description": "Element # (starting from 0) if property is an array."
      }
    ],
    "full_declaration": "native void SetEntPropEnt(int entity, PropType type, const char[] prop, int other, int element=0);"
  },
  {
    "name": "GetEntPropVector",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "void",
    "comment": "Retrieves a vector of floats from an entity, given a named network property.\n\nThis function is considered safer and more robust over GetEntDataVector,\nbecause it performs strict offset checking and typing rules.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity/edict index."
        },
        {
          "name": "type",
          "description": "Property type."
        },
        {
          "name": "prop",
          "description": "Property name."
        },
        {
          "name": "vec",
          "description": "Vector buffer to store data in."
        },
        {
          "name": "element",
          "description": "Element # (starting from 0) if property is an array."
        }
      ],
      "error": [
        "Invalid entity, property not found, or property not actually a vector data type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity/edict index."
      },
      {
        "name": "type",
        "type": "PropType",
        "default": null,
        "description": "Property type."
      },
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property name."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Vector buffer to store data in."
      },
      {
        "name": "element",
        "type": "int",
        "default": "",
        "description": "Element # (starting from 0) if property is an array."
      }
    ],
    "full_declaration": "native void GetEntPropVector(int entity, PropType type, const char[] prop, float vec[3], int element=0);"
  },
  {
    "name": "SetEntPropVector",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "void",
    "comment": "Sets a vector of floats in an entity, given a named network property.\n\nThis function is considered safer and more robust over SetEntDataVector,\nbecause it performs strict offset checking and typing rules.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity/edict index."
        },
        {
          "name": "type",
          "description": "Property type."
        },
        {
          "name": "prop",
          "description": "Property name."
        },
        {
          "name": "vec",
          "description": "Vector to set."
        },
        {
          "name": "element",
          "description": "Element # (starting from 0) if property is an array."
        }
      ],
      "error": [
        "Invalid entity, property not found, or property not actually a vector data type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity/edict index."
      },
      {
        "name": "type",
        "type": "PropType",
        "default": null,
        "description": "Property type."
      },
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property name."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Vector to set."
      },
      {
        "name": "element",
        "type": "int",
        "default": "",
        "description": "Element # (starting from 0) if property is an array."
      }
    ],
    "full_declaration": "native void SetEntPropVector(int entity, PropType type, const char[] prop, const float vec[3], int element=0);"
  },
  {
    "name": "GetEntPropString",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "int",
    "comment": "Gets a network property as a string.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Edict index."
        },
        {
          "name": "type",
          "description": "Property type."
        },
        {
          "name": "prop",
          "description": "Property to use."
        },
        {
          "name": "buffer",
          "description": "Destination string buffer."
        },
        {
          "name": "maxlen",
          "description": "Maximum length of output string buffer."
        },
        {
          "name": "element",
          "description": "Element # (starting from 0) if property is an array."
        }
      ],
      "error": [
        "Invalid entity, offset out of reasonable bounds, or property is not a valid string."
      ],
      "note": [],
      "return": "Number of non-null bytes written."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Edict index."
      },
      {
        "name": "type",
        "type": "PropType",
        "default": null,
        "description": "Property type."
      },
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property to use."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Destination string buffer."
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "Maximum length of output string buffer."
      },
      {
        "name": "element",
        "type": "int",
        "default": "",
        "description": "Element # (starting from 0) if property is an array."
      }
    ],
    "full_declaration": "native int GetEntPropString(int entity, PropType type, const char[] prop, char[] buffer, int maxlen, int element=0);"
  },
  {
    "name": "SetEntPropString",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "int",
    "comment": "Sets a network property as a string.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Edict index."
        },
        {
          "name": "type",
          "description": "Property type."
        },
        {
          "name": "prop",
          "description": "Property to use."
        },
        {
          "name": "buffer",
          "description": "String to set."
        },
        {
          "name": "element",
          "description": "Element # (starting from 0) if property is an array."
        }
      ],
      "error": [
        "Invalid entity, offset out of reasonable bounds, or property is not a valid string."
      ],
      "note": [],
      "return": "Number of non-null bytes written."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Edict index."
      },
      {
        "name": "type",
        "type": "PropType",
        "default": null,
        "description": "Property type."
      },
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property to use."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "String to set."
      },
      {
        "name": "element",
        "type": "int",
        "default": "",
        "description": "Element # (starting from 0) if property is an array."
      }
    ],
    "full_declaration": "native int SetEntPropString(int entity, PropType type, const char[] prop, const char[] buffer, int element=0);"
  },
  {
    "name": "GetEntPropArraySize",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "int",
    "comment": "Retrieves the count of values that an entity property's array can store.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity/edict index."
        },
        {
          "name": "type",
          "description": "Property type."
        },
        {
          "name": "prop",
          "description": "Property name."
        }
      ],
      "error": [
        "Invalid entity or property not found."
      ],
      "note": [],
      "return": "Size of array (in elements) or 0 if property is not an array."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity/edict index."
      },
      {
        "name": "type",
        "type": "PropType",
        "default": null,
        "description": "Property type."
      },
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property name."
      }
    ],
    "full_declaration": "native int GetEntPropArraySize(int entity, PropType type, const char[] prop);"
  },
  {
    "name": "GetEntDataArray",
    "type": "stock",
    "source_file": "entity.inc",
    "return_type": "void",
    "comment": "Copies an array of cells from an entity at a given offset.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index."
        },
        {
          "name": "offset",
          "description": "Offset to use."
        },
        {
          "name": "array",
          "description": "Array to read into."
        },
        {
          "name": "arraySize",
          "description": "Number of values to read."
        },
        {
          "name": "dataSize",
          "description": "Size of each value in bytes (1, 2, or 4)."
        }
      ],
      "error": [
        "Invalid entity or offset out of reasonable bounds."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      },
      {
        "name": "offset",
        "type": "int",
        "default": null,
        "description": "Offset to use."
      },
      {
        "name": "array",
        "type": "any[]",
        "default": null,
        "description": "Array to read into."
      },
      {
        "name": "arraySize",
        "type": "int",
        "default": null,
        "description": "Number of values to read."
      },
      {
        "name": "dataSize",
        "type": "int",
        "default": "",
        "description": "Size of each value in bytes (1, 2, or 4)."
      }
    ],
    "full_declaration": "stock void GetEntDataArray(int entity, int offset, any[] array, int arraySize, int dataSize=4) { \tfor (int i = 0; i < arraySize; i++) \t{ \t\tarray[i] = GetEntData(entity, offset + i*dataSize, dataSize);"
  },
  {
    "name": "SetEntDataArray",
    "type": "stock",
    "source_file": "entity.inc",
    "return_type": "void",
    "comment": "Copies an array of cells to an entity at a given offset.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index."
        },
        {
          "name": "offset",
          "description": "Offset to use."
        },
        {
          "name": "array",
          "description": "Array of values to copy."
        },
        {
          "name": "arraySize",
          "description": "Number of values to copy."
        },
        {
          "name": "dataSize",
          "description": "Size of each value in bytes (1, 2, or 4)."
        },
        {
          "name": "changeState",
          "description": "True to set the network state as changed; false otherwise."
        }
      ],
      "error": [
        "Invalid entity or offset out of reasonable bounds."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      },
      {
        "name": "offset",
        "type": "int",
        "default": null,
        "description": "Offset to use."
      },
      {
        "name": "array",
        "type": "any[]",
        "default": null,
        "description": "Array of values to copy."
      },
      {
        "name": "arraySize",
        "type": "int",
        "default": null,
        "description": "Number of values to copy."
      },
      {
        "name": "dataSize",
        "type": "int",
        "default": "",
        "description": "Size of each value in bytes (1, 2, or 4)."
      },
      {
        "name": "changeState",
        "type": "bool",
        "default": "",
        "description": "True to set the network state as changed; false otherwise."
      }
    ],
    "full_declaration": "stock void SetEntDataArray(int entity, int offset, const any[] array, int arraySize, int dataSize=4, bool changeState=false) { \tfor (int i = 0; i < arraySize; i++) \t{ \t\tSetEntData(entity, offset + i*dataSize, array[i], dataSize, changeState);"
  },
  {
    "name": "GetEntityAddress",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "Address",
    "comment": "Gets the memory address of an entity.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index."
        }
      ],
      "error": [
        "Invalid entity."
      ],
      "note": [],
      "return": "Address of the entity."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      }
    ],
    "full_declaration": "native Address GetEntityAddress(int entity);"
  },
  {
    "name": "GetEntityClassname",
    "type": "stock",
    "source_file": "entity.inc",
    "return_type": "bool",
    "comment": "Retrieves the classname of an entity.\nThis is like GetEdictClassname(), except it works for ALL\nentities, not just edicts.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Index of the entity."
        },
        {
          "name": "clsname",
          "description": "Buffer to store the classname."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of the buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false if there is no classname set."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Index of the entity."
      },
      {
        "name": "clsname",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the classname."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the buffer."
      }
    ],
    "full_declaration": "stock bool GetEntityClassname(int entity, char[] clsname, int maxlength) { \treturn !!GetEntPropString(entity, Prop_Data, \"m_iClassname\", clsname, maxlength);"
  },
  {
    "name": "LoadEntityFromHandleAddress",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "int",
    "comment": "Interprets the address as an entity handle and returns the associated entity.",
    "tags": {
      "param": [
        {
          "name": "addr",
          "description": "Address to a memory location."
        }
      ],
      "error": [],
      "note": [],
      "return": "Entity index at the given location.  If there is no entity, or the stored entity is invalid, then -1 is returned."
    },
    "params": [
      {
        "name": "addr",
        "type": "Address",
        "default": null,
        "description": "Address to a memory location."
      }
    ],
    "full_declaration": "native int LoadEntityFromHandleAddress(Address addr);"
  },
  {
    "name": "StoreEntityToHandleAddress",
    "type": "native",
    "source_file": "entity.inc",
    "return_type": "void",
    "comment": "Interprets the address as an entity handle and sets the entity.",
    "tags": {
      "param": [
        {
          "name": "addr",
          "description": "Address to a memory location."
        },
        {
          "name": "entity",
          "description": "Entity index to set, or -1 to clear."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "addr",
        "type": "Address",
        "default": null,
        "description": "Address to a memory location."
      },
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index to set, or -1 to clear."
      }
    ],
    "full_declaration": "native void StoreEntityToHandleAddress(Address addr, int entity);"
  },
  {
    "name": "EntityLumpEntry",
    "type": "methodmap",
    "source_file": "entitylump.inc",
    "inherits": "Handle",
    "comment": "An ordered list of key / value pairs for a map entity.\nIf the entry in the EntityLump is removed, the handle will error on all operations.\n(The handle will remain valid on the scripting side, and will still need to be deleted.)\n\nWrite operations (update, insert, erase, append) are only allowed during OnMapInit.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "methods": [],
    "properties": [],
    "full_declaration": "methodmap EntityLumpEntry < Handle"
  },
  {
    "name": "GetNextKey",
    "type": "public",
    "source_file": "entitylump.inc",
    "return_type": "int",
    "comment": "Searches the entry list for an index matching a key starting from a position.\nThis also copies the value from that index into the given buffer.\n\nThis can be used to find the first / only value matching a key, or to iterate over all\nthe values that match said key.",
    "tags": {
      "param": [
        {
          "name": "key",
          "description": "Key name to search."
        },
        {
          "name": "buffer",
          "description": "Value buffer.  This will contain the result of the next match, or empty if no match was found."
        },
        {
          "name": "maxlen",
          "description": "Maximum length of the value buffer."
        },
        {
          "name": "start",
          "description": "An index after which to begin searching from.  Use -1 to start from the first entry."
        }
      ],
      "error": [
        "Invalid start position; must be a value between -1 and one less than the length of the entry."
      ],
      "note": [],
      "return": "Position after start with an entry matching the given key, or -1 if no match was found."
    },
    "params": [
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Key name to search."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Value buffer.  This will contain the result of the next match, or empty if no match was found."
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "Maximum length of the value buffer."
      },
      {
        "name": "start",
        "type": "int",
        "default": "",
        "description": "An index after which to begin searching from.  Use -1 to start from the first entry."
      }
    ],
    "full_declaration": "public int GetNextKey(const char[] key, char[] buffer, int maxlen, int start = -1) { \t\tint result = this.FindKey(key, start);"
  },
  {
    "name": "EntityLump",
    "type": "methodmap",
    "source_file": "entitylump.inc",
    "inherits": null,
    "comment": "A group of natives for a singleton entity lump, representing all the entities defined in the map.\n\nWrite operations (insert, erase, append) are only allowed during OnMapInit.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "methods": [],
    "properties": [],
    "full_declaration": "methodmap EntityLump"
  },
  {
    "name": "GetEntityFlags",
    "type": "native",
    "source_file": "entity_prop_stocks.inc",
    "return_type": "int",
    "comment": "Get an entity's flags.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index."
        }
      ],
      "error": [
        "Invalid entity index, or lack of mod compliance."
      ],
      "note": [
        "The game's actual flags are internally translated by SM to match the entity flags defined above as the actual values can differ per engine."
      ],
      "return": "Entity's flags, see entity flag defines above."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      }
    ],
    "full_declaration": "native int GetEntityFlags(int entity);"
  },
  {
    "name": "SetEntityFlags",
    "type": "native",
    "source_file": "entity_prop_stocks.inc",
    "return_type": "void",
    "comment": "Sets an entity's flags.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index."
        },
        {
          "name": "flags",
          "description": "Entity flags, see entity flag defines above."
        }
      ],
      "error": [
        "Invalid entity index, or lack of mod compliance."
      ],
      "note": [
        "The entity flags as defined above are internally translated by SM to match the current game's expected value for the flags as the actual values can differ per engine."
      ],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "Entity flags, see entity flag defines above."
      }
    ],
    "full_declaration": "native void SetEntityFlags(int entity, int flags);"
  },
  {
    "name": "GetEntityMoveType",
    "type": "stock",
    "source_file": "entity_prop_stocks.inc",
    "return_type": "MoveType",
    "comment": "Gets an entity's movetype.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index."
        }
      ],
      "error": [
        "Invalid entity index, or lack of mod compliance."
      ],
      "note": [],
      "return": "Movetype, see enum above."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      }
    ],
    "full_declaration": "stock MoveType GetEntityMoveType(int entity) { \tstatic bool gotconfig = false; \tstatic char datamap[32];  \tif (!gotconfig) \t{ \t\tGameData gc = new GameData(\"core.games\");"
  },
  {
    "name": "SetEntityMoveType",
    "type": "stock",
    "source_file": "entity_prop_stocks.inc",
    "return_type": "void",
    "comment": "Sets an entity's movetype.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index."
        },
        {
          "name": "mt",
          "description": "Movetype, see enum above."
        }
      ],
      "error": [
        "Invalid entity index, or lack of mod compliance."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      },
      {
        "name": "mt",
        "type": "MoveType",
        "default": null,
        "description": "Movetype, see enum above."
      }
    ],
    "full_declaration": "stock void SetEntityMoveType(int entity, MoveType mt) { \tstatic bool gotconfig = false; \tstatic char datamap[32];  \tif (!gotconfig) \t{ \t\tGameData gc = new GameData(\"core.games\");"
  },
  {
    "name": "GetEntityRenderMode",
    "type": "stock",
    "source_file": "entity_prop_stocks.inc",
    "return_type": "RenderMode",
    "comment": "Gets an entity's render mode.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index."
        }
      ],
      "error": [
        "Invalid entity index, or lack of mod compliance."
      ],
      "note": [],
      "return": "RenderMode value."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      }
    ],
    "full_declaration": "stock RenderMode GetEntityRenderMode(int entity) { \tstatic bool gotconfig = false; \tstatic char prop[32];  \tif (!gotconfig) \t{ \t\tGameData gc = new GameData(\"core.games\");"
  },
  {
    "name": "SetEntityRenderMode",
    "type": "stock",
    "source_file": "entity_prop_stocks.inc",
    "return_type": "void",
    "comment": "Sets an entity's render mode.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index."
        },
        {
          "name": "mode",
          "description": "RenderMode value."
        }
      ],
      "error": [
        "Invalid entity index, or lack of mod compliance."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      },
      {
        "name": "mode",
        "type": "RenderMode",
        "default": null,
        "description": "RenderMode value."
      }
    ],
    "full_declaration": "stock void SetEntityRenderMode(int entity, RenderMode mode) { \tstatic bool gotconfig = false; \tstatic char prop[32];  \tif (!gotconfig) \t{ \t\tGameData gc = new GameData(\"core.games\");"
  },
  {
    "name": "GetEntityRenderFx",
    "type": "stock",
    "source_file": "entity_prop_stocks.inc",
    "return_type": "RenderFx",
    "comment": "Gets an entity's render Fx.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index."
        }
      ],
      "error": [
        "Invalid entity index, or lack of mod compliance."
      ],
      "note": [],
      "return": "RenderFx value."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      }
    ],
    "full_declaration": "stock RenderFx GetEntityRenderFx(int entity) { \tstatic bool gotconfig = false; \tstatic char prop[32];  \tif (!gotconfig) \t{ \t\tGameData gc = new GameData(\"core.games\");"
  },
  {
    "name": "SetEntityRenderFx",
    "type": "stock",
    "source_file": "entity_prop_stocks.inc",
    "return_type": "void",
    "comment": "Sets an entity's render Fx.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index."
        },
        {
          "name": "fx",
          "description": "RenderFx value."
        }
      ],
      "error": [
        "Invalid entity index, or lack of mod compliance."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      },
      {
        "name": "fx",
        "type": "RenderFx",
        "default": null,
        "description": "RenderFx value."
      }
    ],
    "full_declaration": "stock void SetEntityRenderFx(int entity, RenderFx fx) { \tstatic bool gotconfig = false; \tstatic char prop[32];  \tif (!gotconfig) \t{ \t\tGameData gc = new GameData(\"core.games\");"
  },
  {
    "name": "GetEntityRenderColor",
    "type": "stock",
    "source_file": "entity_prop_stocks.inc",
    "return_type": "void",
    "comment": "Gets an entity's color.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index."
        },
        {
          "name": "r",
          "description": "Amount of red (0-255)"
        },
        {
          "name": "g",
          "description": "Amount of green (0-255)"
        },
        {
          "name": "b",
          "description": "Amount of blue (0-255)"
        },
        {
          "name": "a",
          "description": "Amount of alpha (0-255)"
        }
      ],
      "error": [
        "Invalid entity index, or lack of mod compliance."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      },
      {
        "name": "r",
        "type": "int",
        "default": null,
        "description": "Amount of red (0-255)"
      },
      {
        "name": "g",
        "type": "int",
        "default": null,
        "description": "Amount of green (0-255)"
      },
      {
        "name": "b",
        "type": "int",
        "default": null,
        "description": "Amount of blue (0-255)"
      },
      {
        "name": "a",
        "type": "int",
        "default": null,
        "description": "Amount of alpha (0-255)"
      }
    ],
    "full_declaration": "stock void GetEntityRenderColor(int entity, int &r, int &g, int &b, int &a) { \tstatic bool gotconfig = false; \tstatic char prop[32];  \tif (!gotconfig) \t{ \t\tGameData gc = new GameData(\"core.games\");"
  },
  {
    "name": "SetEntityRenderColor",
    "type": "stock",
    "source_file": "entity_prop_stocks.inc",
    "return_type": "void",
    "comment": "Sets an entity's color.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index"
        },
        {
          "name": "r",
          "description": "Amount of red (0-255)"
        },
        {
          "name": "g",
          "description": "Amount of green (0-255)"
        },
        {
          "name": "b",
          "description": "Amount of blue (0-255)"
        },
        {
          "name": "a",
          "description": "Amount of alpha (0-255)"
        }
      ],
      "error": [
        "Invalid entity index, or lack of mod compliance."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index"
      },
      {
        "name": "r",
        "type": "int",
        "default": "",
        "description": "Amount of red (0-255)"
      },
      {
        "name": "g",
        "type": "int",
        "default": "",
        "description": "Amount of green (0-255)"
      },
      {
        "name": "b",
        "type": "int",
        "default": "",
        "description": "Amount of blue (0-255)"
      },
      {
        "name": "a",
        "type": "int",
        "default": "",
        "description": "Amount of alpha (0-255)"
      }
    ],
    "full_declaration": "stock void SetEntityRenderColor(int entity, int r=255, int g=255, int b=255, int a=255) { \tstatic bool gotconfig = false; \tstatic char prop[32];  \tif (!gotconfig) \t{ \t\tGameData gc = new GameData(\"core.games\");"
  },
  {
    "name": "GetEntityGravity",
    "type": "stock",
    "source_file": "entity_prop_stocks.inc",
    "return_type": "float",
    "comment": "Gets an entity's gravity.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index."
        }
      ],
      "error": [
        "Invalid entity index, or lack of mod compliance."
      ],
      "note": [],
      "return": "Entity's m_flGravity value."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      }
    ],
    "full_declaration": "stock float GetEntityGravity(int entity) { \tstatic bool gotconfig = false; \tstatic char datamap[32];  \tif (!gotconfig) \t{ \t\tGameData gc = new GameData(\"core.games\");"
  },
  {
    "name": "SetEntityGravity",
    "type": "stock",
    "source_file": "entity_prop_stocks.inc",
    "return_type": "void",
    "comment": "Sets an entity's gravity.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index."
        },
        {
          "name": "amount",
          "description": "Gravity to set (default = 1.0, half = 0.5, double = 2.0)."
        }
      ],
      "error": [
        "Invalid entity index, or lack of mod compliance."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      },
      {
        "name": "amount",
        "type": "float",
        "default": null,
        "description": "Gravity to set (default = 1.0, half = 0.5, double = 2.0)."
      }
    ],
    "full_declaration": "stock void SetEntityGravity(int entity, float amount) { \tstatic bool gotconfig = false; \tstatic char datamap[32];  \tif (!gotconfig) \t{ \t\tGameData gc = new GameData(\"core.games\");"
  },
  {
    "name": "SetEntityHealth",
    "type": "stock",
    "source_file": "entity_prop_stocks.inc",
    "return_type": "void",
    "comment": "Sets an entity's health",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index."
        },
        {
          "name": "amount",
          "description": "Health amount."
        }
      ],
      "error": [
        "Invalid entity index, or lack of mod compliance."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      },
      {
        "name": "amount",
        "type": "int",
        "default": null,
        "description": "Health amount."
      }
    ],
    "full_declaration": "stock void SetEntityHealth(int entity, int amount) { \tstatic bool gotconfig = false; \tstatic char prop[32];  \tif (!gotconfig) \t{ \t\tGameData gc = new GameData(\"core.games\");"
  },
  {
    "name": "GetClientButtons",
    "type": "stock",
    "source_file": "entity_prop_stocks.inc",
    "return_type": "int",
    "comment": "Get's a users current pressed buttons",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index"
        }
      ],
      "error": [
        "Invalid client index, client not in game, or lack of mod compliance."
      ],
      "note": [],
      "return": "Bitsum of buttons"
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index"
      }
    ],
    "full_declaration": "stock int GetClientButtons(int client) { \tstatic bool gotconfig = false; \tstatic char datamap[32];  \tif (!gotconfig) \t{ \t\tGameData gc = new GameData(\"core.games\");"
  },
  {
    "name": "HookEvent",
    "type": "native",
    "source_file": "events.inc",
    "return_type": "void",
    "comment": "Creates a hook for when a game event is fired.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Name of event."
        },
        {
          "name": "callback",
          "description": "An EventHook function pointer."
        },
        {
          "name": "mode",
          "description": "Optional EventHookMode determining the type of hook."
        }
      ],
      "error": [
        "Invalid event name or invalid callback function."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Name of event."
      },
      {
        "name": "callback",
        "type": "EventHook",
        "default": null,
        "description": "An EventHook function pointer."
      },
      {
        "name": "mode",
        "type": "EventHookMode",
        "default": "",
        "description": "Optional EventHookMode determining the type of hook."
      }
    ],
    "full_declaration": "native void HookEvent(const char[] name, EventHook callback, EventHookMode mode=EventHookMode_Post);"
  },
  {
    "name": "HookEventEx",
    "type": "native",
    "source_file": "events.inc",
    "return_type": "bool",
    "comment": "Creates a hook for when a game event is fired.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Name of event."
        },
        {
          "name": "callback",
          "description": "An EventHook function pointer."
        },
        {
          "name": "mode",
          "description": "Optional EventHookMode determining the type of hook."
        }
      ],
      "error": [
        "Invalid callback function."
      ],
      "note": [],
      "return": "True if event exists and was hooked successfully, false otherwise."
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Name of event."
      },
      {
        "name": "callback",
        "type": "EventHook",
        "default": null,
        "description": "An EventHook function pointer."
      },
      {
        "name": "mode",
        "type": "EventHookMode",
        "default": "",
        "description": "Optional EventHookMode determining the type of hook."
      }
    ],
    "full_declaration": "native bool HookEventEx(const char[] name, EventHook callback, EventHookMode mode=EventHookMode_Post);"
  },
  {
    "name": "UnhookEvent",
    "type": "native",
    "source_file": "events.inc",
    "return_type": "void",
    "comment": "Removes a hook for when a game event is fired.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Name of event."
        },
        {
          "name": "callback",
          "description": "An EventHook function pointer."
        },
        {
          "name": "mode",
          "description": "Optional EventHookMode determining the type of hook."
        }
      ],
      "error": [
        "Invalid callback function or no active hook for specified event."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Name of event."
      },
      {
        "name": "callback",
        "type": "EventHook",
        "default": null,
        "description": "An EventHook function pointer."
      },
      {
        "name": "mode",
        "type": "EventHookMode",
        "default": "",
        "description": "Optional EventHookMode determining the type of hook."
      }
    ],
    "full_declaration": "native void UnhookEvent(const char[] name, EventHook callback, EventHookMode mode=EventHookMode_Post);"
  },
  {
    "name": "CreateEvent",
    "type": "native",
    "source_file": "events.inc",
    "return_type": "Event",
    "comment": "Creates a game event to be fired later.\n\nThe Handle should not be closed via CloseHandle().  It must be closed via\nevent.Fire() or event.Cancel().",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Name of event."
        },
        {
          "name": "force",
          "description": "If set to true, this forces the event to be created even if it's not being hooked. Note that this will not force it if the event doesn't exist at all."
        }
      ],
      "error": [],
      "note": [],
      "return": "Handle to event. INVALID_HANDLE is returned if the event doesn't exist or isn't being hooked (unless force is true)."
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Name of event."
      },
      {
        "name": "force",
        "type": "bool",
        "default": "",
        "description": "If set to true, this forces the event to be created even if it's not being hooked. Note that this will not force it if the event doesn't exist at all."
      }
    ],
    "full_declaration": "native Event CreateEvent(const char[] name, bool force=false);"
  },
  {
    "name": "FireEvent",
    "type": "native",
    "source_file": "events.inc",
    "return_type": "void",
    "comment": "Fires a game event.\n\nThis function closes the event Handle after completing.",
    "tags": {
      "param": [
        {
          "name": "event",
          "description": "Handle to the event."
        },
        {
          "name": "dontBroadcast",
          "description": "Optional boolean that determines if event should be broadcast to clients."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "event",
        "type": "Handle",
        "default": null,
        "description": "Handle to the event."
      },
      {
        "name": "dontBroadcast",
        "type": "bool",
        "default": "",
        "description": "Optional boolean that determines if event should be broadcast to clients."
      }
    ],
    "full_declaration": "native void FireEvent(Handle event, bool dontBroadcast=false);"
  },
  {
    "name": "CancelCreatedEvent",
    "type": "native",
    "source_file": "events.inc",
    "return_type": "void",
    "comment": "Cancels a previously created game event that has not been fired.",
    "tags": {
      "param": [
        {
          "name": "event",
          "description": "Handled to the event."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "event",
        "type": "Handle",
        "default": null,
        "description": "Handled to the event."
      }
    ],
    "full_declaration": "native void CancelCreatedEvent(Handle event);"
  },
  {
    "name": "GetEventBool",
    "type": "native",
    "source_file": "events.inc",
    "return_type": "bool",
    "comment": "Returns the boolean value of a game event's key.",
    "tags": {
      "param": [
        {
          "name": "event",
          "description": "Handle to the event."
        },
        {
          "name": "key",
          "description": "Name of event key."
        },
        {
          "name": "defValue",
          "description": "Optional default value to use if the key is not found."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": "The boolean value of the specified event key."
    },
    "params": [
      {
        "name": "event",
        "type": "Handle",
        "default": null,
        "description": "Handle to the event."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Name of event key."
      },
      {
        "name": "defValue",
        "type": "bool",
        "default": "",
        "description": "Optional default value to use if the key is not found."
      }
    ],
    "full_declaration": "native bool GetEventBool(Handle event, const char[] key, bool defValue=false);"
  },
  {
    "name": "SetEventBool",
    "type": "native",
    "source_file": "events.inc",
    "return_type": "void",
    "comment": "Sets the boolean value of a game event's key.",
    "tags": {
      "param": [
        {
          "name": "event",
          "description": "Handle to the event."
        },
        {
          "name": "key",
          "description": "Name of event key."
        },
        {
          "name": "value",
          "description": "New boolean value."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "event",
        "type": "Handle",
        "default": null,
        "description": "Handle to the event."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Name of event key."
      },
      {
        "name": "value",
        "type": "bool",
        "default": null,
        "description": "New boolean value."
      }
    ],
    "full_declaration": "native void SetEventBool(Handle event, const char[] key, bool value);"
  },
  {
    "name": "GetEventInt",
    "type": "native",
    "source_file": "events.inc",
    "return_type": "int",
    "comment": "Returns the integer value of a game event's key.",
    "tags": {
      "param": [
        {
          "name": "event",
          "description": "Handle to the event."
        },
        {
          "name": "key",
          "description": "Name of event key."
        },
        {
          "name": "defValue",
          "description": "Optional default value to use if the key is not found."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": "The integer value of the specified event key."
    },
    "params": [
      {
        "name": "event",
        "type": "Handle",
        "default": null,
        "description": "Handle to the event."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Name of event key."
      },
      {
        "name": "defValue",
        "type": "int",
        "default": "",
        "description": "Optional default value to use if the key is not found."
      }
    ],
    "full_declaration": "native int GetEventInt(Handle event, const char[] key, int defValue=0);"
  },
  {
    "name": "SetEventInt",
    "type": "native",
    "source_file": "events.inc",
    "return_type": "void",
    "comment": "Sets the integer value of a game event's key.\n\nInteger value refers to anything that can be reduced to an integer.\nThe various size specifiers, such as \"byte\" and \"short\" are still\nintegers, and only refer to how much data will actually be sent\nover the network (if applicable).",
    "tags": {
      "param": [
        {
          "name": "event",
          "description": "Handle to the event."
        },
        {
          "name": "key",
          "description": "Name of event key."
        },
        {
          "name": "value",
          "description": "New integer value."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "event",
        "type": "Handle",
        "default": null,
        "description": "Handle to the event."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Name of event key."
      },
      {
        "name": "value",
        "type": "int",
        "default": null,
        "description": "New integer value."
      }
    ],
    "full_declaration": "native void SetEventInt(Handle event, const char[] key, int value);"
  },
  {
    "name": "GetEventFloat",
    "type": "native",
    "source_file": "events.inc",
    "return_type": "float",
    "comment": "Returns the floating point value of a game event's key.",
    "tags": {
      "param": [
        {
          "name": "event",
          "description": "Handle to the event."
        },
        {
          "name": "key",
          "description": "Name of event key."
        },
        {
          "name": "defValue",
          "description": "Optional default value to use if the key is not found."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": "The floating point value of the specified event key."
    },
    "params": [
      {
        "name": "event",
        "type": "Handle",
        "default": null,
        "description": "Handle to the event."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Name of event key."
      },
      {
        "name": "defValue",
        "type": "float",
        "default": "",
        "description": "Optional default value to use if the key is not found."
      }
    ],
    "full_declaration": "native float GetEventFloat(Handle event, const char[] key, float defValue=0.0);"
  },
  {
    "name": "SetEventFloat",
    "type": "native",
    "source_file": "events.inc",
    "return_type": "void",
    "comment": "Sets the floating point value of a game event's key.",
    "tags": {
      "param": [
        {
          "name": "event",
          "description": "Handle to the event."
        },
        {
          "name": "key",
          "description": "Name of event key."
        },
        {
          "name": "value",
          "description": "New floating point value."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "event",
        "type": "Handle",
        "default": null,
        "description": "Handle to the event."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Name of event key."
      },
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "New floating point value."
      }
    ],
    "full_declaration": "native void SetEventFloat(Handle event, const char[] key, float value);"
  },
  {
    "name": "GetEventString",
    "type": "native",
    "source_file": "events.inc",
    "return_type": "void",
    "comment": "Retrieves the string value of a game event's key.",
    "tags": {
      "param": [
        {
          "name": "event",
          "description": "Handle to the event."
        },
        {
          "name": "key",
          "description": "Name of event key."
        },
        {
          "name": "value",
          "description": "Buffer to store the value of the specified event key."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of string buffer."
        },
        {
          "name": "defValue",
          "description": "Optional default value to use if the key is not found."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "event",
        "type": "Handle",
        "default": null,
        "description": "Handle to the event."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Name of event key."
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the value of the specified event key."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of string buffer."
      },
      {
        "name": "defvalue",
        "type": "char[]",
        "default": "",
        "description": ""
      }
    ],
    "full_declaration": "native void GetEventString(Handle event, const char[] key, char[] value, int maxlength, const char[] defvalue=\"\");"
  },
  {
    "name": "SetEventString",
    "type": "native",
    "source_file": "events.inc",
    "return_type": "void",
    "comment": "Sets the string value of a game event's key.",
    "tags": {
      "param": [
        {
          "name": "event",
          "description": "Handle to the event."
        },
        {
          "name": "key",
          "description": "Name of event key."
        },
        {
          "name": "value",
          "description": "New string value."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "event",
        "type": "Handle",
        "default": null,
        "description": "Handle to the event."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Name of event key."
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "New string value."
      }
    ],
    "full_declaration": "native void SetEventString(Handle event, const char[] key, const char[] value);"
  },
  {
    "name": "GetEventName",
    "type": "native",
    "source_file": "events.inc",
    "return_type": "void",
    "comment": "Retrieves the name of a game event.",
    "tags": {
      "param": [
        {
          "name": "event",
          "description": "Handle to the event."
        },
        {
          "name": "name",
          "description": "Buffer to store the name of the event."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of string buffer."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "event",
        "type": "Handle",
        "default": null,
        "description": "Handle to the event."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the name of the event."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of string buffer."
      }
    ],
    "full_declaration": "native void GetEventName(Handle event, char[] name, int maxlength);"
  },
  {
    "name": "SetEventBroadcast",
    "type": "native",
    "source_file": "events.inc",
    "return_type": "void",
    "comment": "Sets whether an event's broadcasting will be disabled or not.\n\nThis has no effect on events Handles that are not from HookEvent\nor HookEventEx callbacks.",
    "tags": {
      "param": [
        {
          "name": "event",
          "description": "Handle to an event from an event hook."
        },
        {
          "name": "dontBroadcast",
          "description": "True to disable broadcasting, false otherwise."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "event",
        "type": "Handle",
        "default": null,
        "description": "Handle to an event from an event hook."
      },
      {
        "name": "dontBroadcast",
        "type": "bool",
        "default": null,
        "description": "True to disable broadcasting, false otherwise."
      }
    ],
    "full_declaration": "native void SetEventBroadcast(Handle event, bool dontBroadcast);"
  },
  {
    "name": "BuildPath",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "int",
    "comment": "Builds a path relative to the SourceMod folder.  This should be used instead of\ndirectly referencing addons/sourcemod, in case users change the name of their\nfolder layout.",
    "tags": {
      "param": [
        {
          "name": "type",
          "description": "Type of path to build as the base."
        },
        {
          "name": "buffer",
          "description": "Buffer to store the path."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of buffer."
        },
        {
          "name": "fmt",
          "description": "Format string."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of bytes written to buffer (not including null terminator)."
    },
    "params": [
      {
        "name": "type",
        "type": "PathType",
        "default": null,
        "description": "Type of path to build as the base."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the path."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of buffer."
      },
      {
        "name": "fmt",
        "type": "char[]",
        "default": null,
        "description": "Format string."
      }
    ],
    "full_declaration": "native int BuildPath(PathType type, char[] buffer, int maxlength, const char[] fmt, any ...);"
  },
  {
    "name": "OpenDirectory",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "DirectoryListing",
    "comment": "Opens a directory/folder for contents enumeration.",
    "tags": {
      "param": [
        {
          "name": "path",
          "description": "Path to open."
        },
        {
          "name": "use_valve_fs",
          "description": "If true, the Valve file system will be used instead. This can be used to find files existing in any of the Valve search paths, rather than solely files existing directly in the gamedir."
        },
        {
          "name": "valve_path_id",
          "description": "If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths."
        }
      ],
      "error": [],
      "note": [
        "Directories are closed with CloseHandle() or delete.",
        "Directories Handles can be cloned.",
        "OpenDirectory() supports the \"file://\" notation."
      ],
      "return": "A Handle to the directory, null on error."
    },
    "params": [
      {
        "name": "path",
        "type": "char[]",
        "default": null,
        "description": "Path to open."
      },
      {
        "name": "use_valve_fs",
        "type": "bool",
        "default": "",
        "description": "If true, the Valve file system will be used instead. This can be used to find files existing in any of the Valve search paths, rather than solely files existing directly in the gamedir."
      },
      {
        "name": "valve_path_id",
        "type": "char[]",
        "default": "",
        "description": "If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths."
      }
    ],
    "full_declaration": "native DirectoryListing OpenDirectory(const char[] path, bool use_valve_fs=false, const char[] valve_path_id=\"GAME\");"
  },
  {
    "name": "ReadDirEntry",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "bool",
    "comment": "Reads the current directory entry as a local filename, then moves to the next file.",
    "tags": {
      "param": [
        {
          "name": "dir",
          "description": "Handle to a directory."
        },
        {
          "name": "buffer",
          "description": "String buffer to hold directory name."
        },
        {
          "name": "maxlength",
          "description": "Maximum size of string buffer."
        },
        {
          "name": "type",
          "description": "Optional variable to store the file type."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [
        "Contents of buffers are undefined when returning false.",
        "Both the '.' and '..' automatic directory entries will be retrieved for Windows and Linux."
      ],
      "return": "True on success, false if there are no more files to read."
    },
    "params": [
      {
        "name": "dir",
        "type": "Handle",
        "default": null,
        "description": "Handle to a directory."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "String buffer to hold directory name."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum size of string buffer."
      },
      {
        "name": "type",
        "type": "FileType",
        "default": "",
        "description": "Optional variable to store the file type."
      }
    ],
    "full_declaration": "native bool ReadDirEntry(Handle dir, char[] buffer, int maxlength, FileType &type=FileType_Unknown);"
  },
  {
    "name": "OpenFile",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "File",
    "comment": "Opens or creates a file, returning a File handle on success. File handles\nshould be closed with delete or CloseHandle().\n\nThe open mode may be one of the following strings:\n\"r\": Open an existing file for reading.\n\"w\": Create a file for writing, or truncate (delete the contents of) an\nexisting file and then open it for writing.\n\"a\": Create a file for writing, or open an existing file such that writes\nwill be appended to the end.\n\"r+\": Open an existing file for both reading and writing.\n\"w+\": Create a file for reading and writing, or truncate an existing file\nand then open it for reading and writing.\n\"a+\": Create a file for both reading and writing, or open an existing file\nsuch that writes will be appended to the end.\n\nThe open mode may also contain an additional character after \"r\", \"w\", or \"a\",\nbut before any \"+\" sign. This character may be \"b\" (indicating binary mode) or\n\"t\" (indicating text mode). By default, \"text\" mode is implied. On Linux and\nMac, this has no distinction from binary mode. On Windows, it causes the '\\n'\ncharacter (0xA) to be written as \"\\r\\n\" (0xD, 0xA).\n\nExample: \"rb\" opens a binary file for reading; \"at\" opens a text file for\nappending.",
    "tags": {
      "param": [
        {
          "name": "file",
          "description": "File to open."
        },
        {
          "name": "mode",
          "description": "Open mode."
        },
        {
          "name": "use_valve_fs",
          "description": "If true, the Valve file system will be used instead. This can be used to find files existing in valve search paths, rather than solely files existing directly in the gamedir."
        },
        {
          "name": "valve_path_id",
          "description": "If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths."
        }
      ],
      "error": [],
      "note": [],
      "return": "A File handle, or null if the file could not be opened."
    },
    "params": [
      {
        "name": "file",
        "type": "char[]",
        "default": null,
        "description": "File to open."
      },
      {
        "name": "mode",
        "type": "char[]",
        "default": null,
        "description": "Open mode."
      },
      {
        "name": "use_valve_fs",
        "type": "bool",
        "default": "",
        "description": "If true, the Valve file system will be used instead. This can be used to find files existing in valve search paths, rather than solely files existing directly in the gamedir."
      },
      {
        "name": "valve_path_id",
        "type": "char[]",
        "default": "",
        "description": "If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths."
      }
    ],
    "full_declaration": "native File OpenFile(const char[] file, const char[] mode, bool use_valve_fs=false, const char[] valve_path_id=\"GAME\");"
  },
  {
    "name": "DeleteFile",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "bool",
    "comment": "Deletes a file.",
    "tags": {
      "param": [
        {
          "name": "path",
          "description": "Path of the file to delete."
        },
        {
          "name": "use_valve_fs",
          "description": "If true, the Valve file system will be used instead. This can be used to delete files existing in the Valve search path, rather than solely files existing directly in the gamedir."
        },
        {
          "name": "valve_path_id",
          "description": "If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false on failure or if file not immediately removed."
    },
    "params": [
      {
        "name": "path",
        "type": "char[]",
        "default": null,
        "description": "Path of the file to delete."
      },
      {
        "name": "use_valve_fs",
        "type": "bool",
        "default": "",
        "description": "If true, the Valve file system will be used instead. This can be used to delete files existing in the Valve search path, rather than solely files existing directly in the gamedir."
      },
      {
        "name": "valve_path_id",
        "type": "char[]",
        "default": "",
        "description": "If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths."
      }
    ],
    "full_declaration": "native bool DeleteFile(const char[] path, bool use_valve_fs=false, const char[] valve_path_id=\"DEFAULT_WRITE_PATH\");"
  },
  {
    "name": "ReadFileLine",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "bool",
    "comment": "Reads a line from a text file.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "Handle to the file."
        },
        {
          "name": "buffer",
          "description": "String buffer to hold the line."
        },
        {
          "name": "maxlength",
          "description": "Maximum size of string buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": null,
        "description": "Handle to the file."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "String buffer to hold the line."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum size of string buffer."
      }
    ],
    "full_declaration": "native bool ReadFileLine(Handle hndl, char[] buffer, int maxlength);"
  },
  {
    "name": "ReadFile",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "int",
    "comment": "Reads binary data from a file.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "Handle to the file."
        },
        {
          "name": "items",
          "description": "Array to store each item read."
        },
        {
          "name": "num_items",
          "description": "Number of items to read into the array."
        },
        {
          "name": "size",
          "description": "Size of each element, in bytes, to be read. Valid sizes are 1, 2, or 4."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of elements read, or -1 on error."
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": null,
        "description": "Handle to the file."
      },
      {
        "name": "items",
        "type": "any[]",
        "default": null,
        "description": "Array to store each item read."
      },
      {
        "name": "num_items",
        "type": "int",
        "default": null,
        "description": "Number of items to read into the array."
      },
      {
        "name": "size",
        "type": "int",
        "default": null,
        "description": "Size of each element, in bytes, to be read. Valid sizes are 1, 2, or 4."
      }
    ],
    "full_declaration": "native int ReadFile(Handle hndl, any[] items, int num_items, int size);"
  },
  {
    "name": "ReadFileString",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "int",
    "comment": "Reads a UTF8 or ANSI string from a file.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "Handle to the file."
        },
        {
          "name": "buffer",
          "description": "Buffer to store the string."
        },
        {
          "name": "max_size",
          "description": "Maximum size of the string buffer."
        },
        {
          "name": "read_count",
          "description": "If -1, reads until a null terminator is encountered in the file.  Otherwise, read_count bytes are read into the buffer provided.  In this case the buffer is not explicitly null terminated, and the buffer will contain any null terminators read from the file."
        }
      ],
      "error": [
        "Invalid Handle, or read_count > max_size."
      ],
      "note": [],
      "return": "Number of characters written to the buffer, or -1 if an error was encountered."
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": null,
        "description": "Handle to the file."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the string."
      },
      {
        "name": "max_size",
        "type": "int",
        "default": null,
        "description": "Maximum size of the string buffer."
      },
      {
        "name": "read_count",
        "type": "int",
        "default": "",
        "description": "If -1, reads until a null terminator is encountered in the file.  Otherwise, read_count bytes are read into the buffer provided.  In this case the buffer is not explicitly null terminated, and the buffer will contain any null terminators read from the file."
      }
    ],
    "full_declaration": "native int ReadFileString(Handle hndl, char[] buffer, int max_size, int read_count=-1);"
  },
  {
    "name": "WriteFile",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "bool",
    "comment": "Writes binary data to a file.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "Handle to the file."
        },
        {
          "name": "items",
          "description": "Array of items to write.  The data is read directly. That is, in 1 or 2-byte mode, the lower byte(s) in each cell are used directly, rather than performing any casts from a 4-byte number to a smaller number."
        },
        {
          "name": "num_items",
          "description": "Number of items in the array."
        },
        {
          "name": "size",
          "description": "Size of each item in the array in bytes. Valid sizes are 1, 2, or 4."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false on error."
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": null,
        "description": "Handle to the file."
      },
      {
        "name": "items",
        "type": "any[]",
        "default": null,
        "description": "Array of items to write.  The data is read directly. That is, in 1 or 2-byte mode, the lower byte(s) in each cell are used directly, rather than performing any casts from a 4-byte number to a smaller number."
      },
      {
        "name": "num_items",
        "type": "int",
        "default": null,
        "description": "Number of items in the array."
      },
      {
        "name": "size",
        "type": "int",
        "default": null,
        "description": "Size of each item in the array in bytes. Valid sizes are 1, 2, or 4."
      }
    ],
    "full_declaration": "native bool WriteFile(Handle hndl, const any[] items, int num_items, int size);"
  },
  {
    "name": "WriteFileString",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "bool",
    "comment": "Writes a binary string to a file.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "Handle to the file."
        },
        {
          "name": "buffer",
          "description": "String to write."
        },
        {
          "name": "term",
          "description": "True to append NUL terminator, false otherwise."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false on error."
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": null,
        "description": "Handle to the file."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "String to write."
      },
      {
        "name": "term",
        "type": "bool",
        "default": null,
        "description": "True to append NUL terminator, false otherwise."
      }
    ],
    "full_declaration": "native bool WriteFileString(Handle hndl, const char[] buffer, bool term);"
  },
  {
    "name": "WriteFileLine",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "bool",
    "comment": "Writes a line of text to a text file.  A newline is automatically appended.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "Handle to the file."
        },
        {
          "name": "format",
          "description": "Formatting rules."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": null,
        "description": "Handle to the file."
      },
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "Formatting rules."
      }
    ],
    "full_declaration": "native bool WriteFileLine(Handle hndl, const char[] format, any ...);"
  },
  {
    "name": "WriteFileCell",
    "type": "stock",
    "source_file": "files.inc",
    "return_type": "bool",
    "comment": "Writes a single binary cell to a file.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "Handle to the file."
        },
        {
          "name": "data",
          "description": "Cell to write to the file."
        },
        {
          "name": "size",
          "description": "Size of the data to read in bytes.  Valid sizes are 1, 2, or 4 bytes.  If the size is less than 4 bytes, the data is truncated rather than casted.  That is, only the lower bits will be read."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false on error."
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": null,
        "description": "Handle to the file."
      },
      {
        "name": "data",
        "type": "int",
        "default": null,
        "description": "Cell to write to the file."
      },
      {
        "name": "size",
        "type": "int",
        "default": null,
        "description": "Size of the data to read in bytes.  Valid sizes are 1, 2, or 4 bytes.  If the size is less than 4 bytes, the data is truncated rather than casted.  That is, only the lower bits will be read."
      }
    ],
    "full_declaration": "stock bool WriteFileCell(Handle hndl, int data, int size) { \tint array[1]; \tarray[0] = data;  \treturn WriteFile(hndl, array, 1, size);"
  },
  {
    "name": "IsEndOfFile",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "bool",
    "comment": "Tests if the end of file has been reached.",
    "tags": {
      "param": [
        {
          "name": "file",
          "description": "Handle to the file."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True if end of file has been reached, false otherwise."
    },
    "params": [
      {
        "name": "file",
        "type": "Handle",
        "default": null,
        "description": "Handle to the file."
      }
    ],
    "full_declaration": "native bool IsEndOfFile(Handle file);"
  },
  {
    "name": "FileSeek",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "bool",
    "comment": "Sets the file position indicator.",
    "tags": {
      "param": [
        {
          "name": "file",
          "description": "Handle to the file."
        },
        {
          "name": "position",
          "description": "Position relative to what is specified in whence."
        },
        {
          "name": "where",
          "description": "SEEK_ constant value of where to see from."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "file",
        "type": "Handle",
        "default": null,
        "description": "Handle to the file."
      },
      {
        "name": "position",
        "type": "int",
        "default": null,
        "description": "Position relative to what is specified in whence."
      },
      {
        "name": "where",
        "type": "int",
        "default": null,
        "description": "SEEK_ constant value of where to see from."
      }
    ],
    "full_declaration": "native bool FileSeek(Handle file, int position, int where);"
  },
  {
    "name": "FilePosition",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "int",
    "comment": "Get current position in the file.",
    "tags": {
      "param": [
        {
          "name": "file",
          "description": "Handle to the file."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Value for the file position indicator."
    },
    "params": [
      {
        "name": "file",
        "type": "Handle",
        "default": null,
        "description": "Handle to the file."
      }
    ],
    "full_declaration": "native int FilePosition(Handle file);"
  },
  {
    "name": "FileExists",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "bool",
    "comment": "Checks if a file exists.",
    "tags": {
      "param": [
        {
          "name": "path",
          "description": "Path to the file."
        },
        {
          "name": "use_valve_fs",
          "description": "If true, the Valve file system will be used instead. This can be used to find files existing in any of the Valve search paths, rather than solely files existing directly in the gamedir."
        },
        {
          "name": "valve_path_id",
          "description": "If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if the file exists, false otherwise."
    },
    "params": [
      {
        "name": "path",
        "type": "char[]",
        "default": null,
        "description": "Path to the file."
      },
      {
        "name": "use_valve_fs",
        "type": "bool",
        "default": "",
        "description": "If true, the Valve file system will be used instead. This can be used to find files existing in any of the Valve search paths, rather than solely files existing directly in the gamedir."
      },
      {
        "name": "valve_path_id",
        "type": "char[]",
        "default": "",
        "description": "If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths."
      }
    ],
    "full_declaration": "native bool FileExists(const char[] path, bool use_valve_fs=false, const char[] valve_path_id=\"GAME\");"
  },
  {
    "name": "RenameFile",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "bool",
    "comment": "Renames a file.",
    "tags": {
      "param": [
        {
          "name": "newpath",
          "description": "New path to the file."
        },
        {
          "name": "oldpath",
          "description": "Path to the existing file."
        },
        {
          "name": "use_valve_fs",
          "description": "If true, the Valve file system will be used instead. This can be used to rename files in the game's Valve search paths, rather than directly in the gamedir."
        },
        {
          "name": "valve_path_id",
          "description": "If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success or use_valve_fs specified, false otherwise."
    },
    "params": [
      {
        "name": "newpath",
        "type": "char[]",
        "default": null,
        "description": "New path to the file."
      },
      {
        "name": "oldpath",
        "type": "char[]",
        "default": null,
        "description": "Path to the existing file."
      },
      {
        "name": "use_valve_fs",
        "type": "bool",
        "default": "",
        "description": "If true, the Valve file system will be used instead. This can be used to rename files in the game's Valve search paths, rather than directly in the gamedir."
      },
      {
        "name": "valve_path_id",
        "type": "char[]",
        "default": "",
        "description": "If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths."
      }
    ],
    "full_declaration": "native bool RenameFile(const char[] newpath, const char[] oldpath, bool use_valve_fs=false, const char[] valve_path_id=\"DEFAULT_WRITE_PATH\");"
  },
  {
    "name": "DirExists",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "bool",
    "comment": "Checks if a directory exists.",
    "tags": {
      "param": [
        {
          "name": "path",
          "description": "Path to the directory."
        },
        {
          "name": "use_valve_fs",
          "description": "If true, the Valve file system will be used instead. This can be used to find files existing in any of the Valve search paths, rather than solely files existing directly in the gamedir."
        },
        {
          "name": "valve_path_id",
          "description": "If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if the directory exists, false otherwise."
    },
    "params": [
      {
        "name": "path",
        "type": "char[]",
        "default": null,
        "description": "Path to the directory."
      },
      {
        "name": "use_valve_fs",
        "type": "bool",
        "default": "",
        "description": "If true, the Valve file system will be used instead. This can be used to find files existing in any of the Valve search paths, rather than solely files existing directly in the gamedir."
      },
      {
        "name": "valve_path_id",
        "type": "char[]",
        "default": "",
        "description": "If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths."
      }
    ],
    "full_declaration": "native bool DirExists(const char[] path, bool use_valve_fs=false, const char[] valve_path_id=\"GAME\");"
  },
  {
    "name": "FileSize",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "int",
    "comment": "Get the file size in bytes.",
    "tags": {
      "param": [
        {
          "name": "path",
          "description": "Path to the file."
        },
        {
          "name": "use_valve_fs",
          "description": "If true, the Valve file system will be used instead. This can be used to find files existing in any of the Valve search paths, rather than solely files existing directly in the gamedir."
        },
        {
          "name": "valve_path_id",
          "description": "If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths."
        }
      ],
      "error": [],
      "note": [],
      "return": "File size in bytes, -1 if file not found."
    },
    "params": [
      {
        "name": "path",
        "type": "char[]",
        "default": null,
        "description": "Path to the file."
      },
      {
        "name": "use_valve_fs",
        "type": "bool",
        "default": "",
        "description": "If true, the Valve file system will be used instead. This can be used to find files existing in any of the Valve search paths, rather than solely files existing directly in the gamedir."
      },
      {
        "name": "valve_path_id",
        "type": "char[]",
        "default": "",
        "description": "If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths."
      }
    ],
    "full_declaration": "native int FileSize(const char[] path, bool use_valve_fs=false, const char[] valve_path_id=\"GAME\");"
  },
  {
    "name": "FlushFile",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "bool",
    "comment": "Flushes a file's buffered output; any buffered output\nis immediately written to the file.",
    "tags": {
      "param": [
        {
          "name": "file",
          "description": "Handle to the file."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success or use_valve_fs specified with OpenFile, otherwise false on failure."
    },
    "params": [
      {
        "name": "file",
        "type": "Handle",
        "default": null,
        "description": "Handle to the file."
      }
    ],
    "full_declaration": "native bool FlushFile(Handle file);"
  },
  {
    "name": "RemoveDir",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "bool",
    "comment": "Removes a directory.",
    "tags": {
      "param": [
        {
          "name": "path",
          "description": "Path to the directory."
        }
      ],
      "error": [],
      "note": [
        "On most Operating Systems you cannot remove a directory which has files inside it."
      ],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "path",
        "type": "char[]",
        "default": null,
        "description": "Path to the directory."
      }
    ],
    "full_declaration": "native bool RemoveDir(const char[] path);"
  },
  {
    "name": "CreateDirectory",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "bool",
    "comment": "Creates a directory.",
    "tags": {
      "param": [
        {
          "name": "path",
          "description": "Path to create. Note that directories are not created recursively unless use_valve_fs is used."
        },
        {
          "name": "mode",
          "description": "Permissions (default is o=rx,g=rx,u=rwx).  Note that folders must have the execute bit set on Linux.  On Windows, the mode is ignored."
        },
        {
          "name": "use_valve_fs",
          "description": "If true, the Valve file system will be used instead. This can be used to create folders in the game's Valve search paths, rather than directly in the gamedir."
        },
        {
          "name": "valve_path_id",
          "description": "If use_valve_fs, a search path from gameinfo or NULL_STRING for default. In this case, mode is ignored."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "path",
        "type": "char[]",
        "default": null,
        "description": "Path to create. Note that directories are not created recursively unless use_valve_fs is used."
      },
      {
        "name": "mode",
        "type": "int",
        "default": "",
        "description": "Permissions (default is o=rx,g=rx,u=rwx).  Note that folders must have the execute bit set on Linux.  On Windows, the mode is ignored."
      },
      {
        "name": "use_valve_fs",
        "type": "bool",
        "default": "",
        "description": "If true, the Valve file system will be used instead. This can be used to create folders in the game's Valve search paths, rather than directly in the gamedir."
      },
      {
        "name": "valve_path_id",
        "type": "char[]",
        "default": "",
        "description": "If use_valve_fs, a search path from gameinfo or NULL_STRING for default. In this case, mode is ignored."
      }
    ],
    "full_declaration": "native bool CreateDirectory(const char[] path, int mode=FPERM_O_READ|FPERM_O_EXEC|FPERM_G_READ|FPERM_G_EXEC|FPERM_U_READ|FPERM_U_WRITE|FPERM_U_EXEC, bool use_valve_fs=false, const char[] valve_path_id=\"DEFAULT_WRITE_PATH\");"
  },
  {
    "name": "SetFilePermissions",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "bool",
    "comment": "Changes a file or directories permissions.",
    "tags": {
      "param": [
        {
          "name": "path",
          "description": "Path to the file."
        },
        {
          "name": "mode",
          "description": "Permissions to set."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "path",
        "type": "char[]",
        "default": null,
        "description": "Path to the file."
      },
      {
        "name": "mode",
        "type": "int",
        "default": null,
        "description": "Permissions to set."
      }
    ],
    "full_declaration": "native bool SetFilePermissions(const char[] path, int mode);"
  },
  {
    "name": "GetFilePermissions",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "bool",
    "comment": "Retrieves a file or directories permissions.",
    "tags": {
      "param": [
        {
          "name": "path",
          "description": "Path to the file."
        },
        {
          "name": "mode",
          "description": "Variable to store the permissions in."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "path",
        "type": "char[]",
        "default": null,
        "description": "Path to the file."
      },
      {
        "name": "mode",
        "type": "int",
        "default": null,
        "description": "Variable to store the permissions in."
      }
    ],
    "full_declaration": "native bool GetFilePermissions(const char[] path, int &mode);"
  },
  {
    "name": "GetFileTime",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "int",
    "comment": "Returns a file timestamp as a unix timestamp.",
    "tags": {
      "param": [
        {
          "name": "file",
          "description": "File name."
        },
        {
          "name": "tmode",
          "description": "Time mode."
        }
      ],
      "error": [],
      "note": [],
      "return": "Time value, or -1 on failure."
    },
    "params": [
      {
        "name": "file",
        "type": "char[]",
        "default": null,
        "description": "File name."
      },
      {
        "name": "tmode",
        "type": "FileTimeMode",
        "default": null,
        "description": "Time mode."
      }
    ],
    "full_declaration": "native int GetFileTime(const char[] file, FileTimeMode tmode);"
  },
  {
    "name": "LogToOpenFile",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "void",
    "comment": "Same as LogToFile(), except uses an open file Handle.  The file must\nbe opened in text appending mode.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "Handle to the file."
        },
        {
          "name": "message",
          "description": "Message format."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": null,
        "description": "Handle to the file."
      },
      {
        "name": "message",
        "type": "char[]",
        "default": null,
        "description": "Message format."
      }
    ],
    "full_declaration": "native void LogToOpenFile(Handle hndl, const char[] message, any ...);"
  },
  {
    "name": "LogToOpenFileEx",
    "type": "native",
    "source_file": "files.inc",
    "return_type": "void",
    "comment": "Same as LogToFileEx(), except uses an open file Handle.  The file must\nbe opened in text appending mode.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "Handle to the file."
        },
        {
          "name": "message",
          "description": "Message format."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": null,
        "description": "Handle to the file."
      },
      {
        "name": "message",
        "type": "char[]",
        "default": null,
        "description": "Message format."
      }
    ],
    "full_declaration": "native void LogToOpenFileEx(Handle hndl, const char[] message, any ...);"
  },
  {
    "name": "float",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "float",
    "comment": "Converts an integer into a floating point value.",
    "tags": {
      "param": [
        {
          "name": "value",
          "description": "Integer to convert."
        }
      ],
      "error": [],
      "note": [],
      "return": "Floating point value."
    },
    "params": [
      {
        "name": "value",
        "type": "int",
        "default": null,
        "description": "Integer to convert."
      }
    ],
    "full_declaration": "native float float(int value);"
  },
  {
    "name": "FloatMul",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "float",
    "comment": "Multiplies two floats together.\n\nNote: This native is internal implementation. For multiplication use the '*' operator.",
    "tags": {
      "param": [
        {
          "name": "oper1",
          "description": "First value."
        },
        {
          "name": "oper2",
          "description": "Second value."
        }
      ],
      "error": [],
      "note": [],
      "return": "oper1*oper2.",
      "deprecated": [
        "This native is internal implementation. For multiplication use the '*' operator."
      ]
    },
    "params": [
      {
        "name": "oper1",
        "type": "float",
        "default": null,
        "description": "First value."
      },
      {
        "name": "oper2",
        "type": "float",
        "default": null,
        "description": "Second value."
      }
    ],
    "full_declaration": "native float FloatMul(float oper1, float oper2);"
  },
  {
    "name": "FloatDiv",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "float",
    "comment": "Divides the dividend by the divisor.\n\nNote: This native is internal implementation. For division use the '/' operator.",
    "tags": {
      "param": [
        {
          "name": "dividend",
          "description": "First value."
        },
        {
          "name": "divisor",
          "description": "Second value."
        }
      ],
      "error": [],
      "note": [],
      "return": "dividend/divisor.",
      "deprecated": [
        "This native is internal implementation. For division use the '/' operator."
      ]
    },
    "params": [
      {
        "name": "dividend",
        "type": "float",
        "default": null,
        "description": "First value."
      },
      {
        "name": "divisor",
        "type": "float",
        "default": null,
        "description": "Second value."
      }
    ],
    "full_declaration": "native float FloatDiv(float dividend, float divisor);"
  },
  {
    "name": "FloatAdd",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "float",
    "comment": "Adds two floats together.\n\nNote: This native is internal implementation. For addition use the '+' operator.",
    "tags": {
      "param": [
        {
          "name": "oper1",
          "description": "First value."
        },
        {
          "name": "oper2",
          "description": "Second value."
        }
      ],
      "error": [],
      "note": [],
      "return": "oper1+oper2.",
      "deprecated": [
        "This native is internal implementation. For addition use the '+' operator."
      ]
    },
    "params": [
      {
        "name": "oper1",
        "type": "float",
        "default": null,
        "description": "First value."
      },
      {
        "name": "oper2",
        "type": "float",
        "default": null,
        "description": "Second value."
      }
    ],
    "full_declaration": "native float FloatAdd(float oper1, float oper2);"
  },
  {
    "name": "FloatSub",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "float",
    "comment": "Subtracts oper2 from oper1.\n\nNote: This native is internal implementation. For subtraction use the '-' operator.",
    "tags": {
      "param": [
        {
          "name": "oper1",
          "description": "First value."
        },
        {
          "name": "oper2",
          "description": "Second value."
        }
      ],
      "error": [],
      "note": [],
      "return": "oper1-oper2.",
      "deprecated": [
        "This native is internal implementation. For subtraction use the '-' operator."
      ]
    },
    "params": [
      {
        "name": "oper1",
        "type": "float",
        "default": null,
        "description": "First value."
      },
      {
        "name": "oper2",
        "type": "float",
        "default": null,
        "description": "Second value."
      }
    ],
    "full_declaration": "native float FloatSub(float oper1, float oper2);"
  },
  {
    "name": "FloatMod",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "float",
    "comment": "Returns the modulus of oper1 and oper2.\n\nNote: This native is internal implementation. For modulo use the '%' operator.",
    "tags": {
      "param": [
        {
          "name": "oper1",
          "description": "First value."
        },
        {
          "name": "oper2",
          "description": "Second value."
        }
      ],
      "error": [],
      "note": [],
      "return": "oper1%oper2.",
      "deprecated": [
        "This native is internal implementation. For modulo use the '%' operator."
      ]
    },
    "params": [
      {
        "name": "oper1",
        "type": "float",
        "default": null,
        "description": "First value."
      },
      {
        "name": "oper2",
        "type": "float",
        "default": null,
        "description": "Second value."
      }
    ],
    "full_declaration": "native float FloatMod(float oper1, float oper2);"
  },
  {
    "name": "FloatFraction",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "float",
    "comment": "Returns the decimal part of a float.",
    "tags": {
      "param": [
        {
          "name": "value",
          "description": "Input value."
        }
      ],
      "error": [],
      "note": [],
      "return": "Decimal part."
    },
    "params": [
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Input value."
      }
    ],
    "full_declaration": "native float FloatFraction(float value);"
  },
  {
    "name": "RoundToZero",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "int",
    "comment": "Rounds a float to the closest integer to zero.",
    "tags": {
      "param": [
        {
          "name": "value",
          "description": "Input value to be rounded."
        }
      ],
      "error": [],
      "note": [],
      "return": "Rounded value."
    },
    "params": [
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Input value to be rounded."
      }
    ],
    "full_declaration": "native int RoundToZero(float value);"
  },
  {
    "name": "RoundToCeil",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "int",
    "comment": "Rounds a float to the next highest integer value.",
    "tags": {
      "param": [
        {
          "name": "value",
          "description": "Input value to be rounded."
        }
      ],
      "error": [],
      "note": [],
      "return": "Rounded value."
    },
    "params": [
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Input value to be rounded."
      }
    ],
    "full_declaration": "native int RoundToCeil(float value);"
  },
  {
    "name": "RoundToFloor",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "int",
    "comment": "Rounds a float to the next lowest integer value.",
    "tags": {
      "param": [
        {
          "name": "value",
          "description": "Input value to be rounded."
        }
      ],
      "error": [],
      "note": [],
      "return": "Rounded value."
    },
    "params": [
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Input value to be rounded."
      }
    ],
    "full_declaration": "native int RoundToFloor(float value);"
  },
  {
    "name": "RoundToNearest",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "int",
    "comment": "Standard IEEE rounding.",
    "tags": {
      "param": [
        {
          "name": "value",
          "description": "Input value to be rounded."
        }
      ],
      "error": [],
      "note": [],
      "return": "Rounded value."
    },
    "params": [
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Input value to be rounded."
      }
    ],
    "full_declaration": "native int RoundToNearest(float value);"
  },
  {
    "name": "FloatCompare",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "int",
    "comment": "Compares two floats.",
    "tags": {
      "param": [
        {
          "name": "fOne",
          "description": "First value."
        },
        {
          "name": "fTwo",
          "description": "Second value."
        }
      ],
      "error": [],
      "note": [],
      "return": "Returns 1 if the first argument is greater than the second argument. Returns -1 if the first argument is smaller than the second argument. Returns 0 if both arguments are equal."
    },
    "params": [
      {
        "name": "fOne",
        "type": "float",
        "default": null,
        "description": "First value."
      },
      {
        "name": "fTwo",
        "type": "float",
        "default": null,
        "description": "Second value."
      }
    ],
    "full_declaration": "native int FloatCompare(float fOne, float fTwo);"
  },
  {
    "name": "SquareRoot",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "float",
    "comment": "Returns the square root of the input value, equivalent to floatpower(value, 0.5).",
    "tags": {
      "param": [
        {
          "name": "value",
          "description": "Input value."
        }
      ],
      "error": [],
      "note": [],
      "return": "Square root of the value."
    },
    "params": [
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Input value."
      }
    ],
    "full_declaration": "native float SquareRoot(float value);"
  },
  {
    "name": "Pow",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "float",
    "comment": "Returns the value raised to the power of the exponent.",
    "tags": {
      "param": [
        {
          "name": "value",
          "description": "Value to be raised."
        },
        {
          "name": "exponent",
          "description": "Value to raise the base."
        }
      ],
      "error": [],
      "note": [],
      "return": "value^exponent."
    },
    "params": [
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Value to be raised."
      },
      {
        "name": "exponent",
        "type": "float",
        "default": null,
        "description": "Value to raise the base."
      }
    ],
    "full_declaration": "native float Pow(float value, float exponent);"
  },
  {
    "name": "Exponential",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "float",
    "comment": "Returns the value of raising the input by e.",
    "tags": {
      "param": [
        {
          "name": "value",
          "description": "Input value."
        }
      ],
      "error": [],
      "note": [],
      "return": "exp(value)."
    },
    "params": [
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Input value."
      }
    ],
    "full_declaration": "native float Exponential(float value);"
  },
  {
    "name": "Logarithm",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "float",
    "comment": "Returns the logarithm of any base specified.",
    "tags": {
      "param": [
        {
          "name": "value",
          "description": "Input value."
        },
        {
          "name": "base",
          "description": "Logarithm base to use, default is 10."
        }
      ],
      "error": [],
      "note": [],
      "return": "log(value)/log(base)."
    },
    "params": [
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Input value."
      },
      {
        "name": "base",
        "type": "float",
        "default": "",
        "description": "Logarithm base to use, default is 10."
      }
    ],
    "full_declaration": "native float Logarithm(float value, float base=10.0);"
  },
  {
    "name": "Sine",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "float",
    "comment": "Returns the sine of the argument.",
    "tags": {
      "param": [
        {
          "name": "value",
          "description": "Input value in radians."
        }
      ],
      "error": [],
      "note": [],
      "return": "sin(value)."
    },
    "params": [
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Input value in radians."
      }
    ],
    "full_declaration": "native float Sine(float value);"
  },
  {
    "name": "Cosine",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "float",
    "comment": "Returns the cosine of the argument.",
    "tags": {
      "param": [
        {
          "name": "value",
          "description": "Input value in radians."
        }
      ],
      "error": [],
      "note": [],
      "return": "cos(value)."
    },
    "params": [
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Input value in radians."
      }
    ],
    "full_declaration": "native float Cosine(float value);"
  },
  {
    "name": "Tangent",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "float",
    "comment": "Returns the tangent of the argument.",
    "tags": {
      "param": [
        {
          "name": "value",
          "description": "Input value in radians."
        }
      ],
      "error": [],
      "note": [],
      "return": "tan(value)."
    },
    "params": [
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Input value in radians."
      }
    ],
    "full_declaration": "native float Tangent(float value);"
  },
  {
    "name": "FloatAbs",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "float",
    "comment": "Returns an absolute value.",
    "tags": {
      "param": [
        {
          "name": "value",
          "description": "Input value."
        }
      ],
      "error": [],
      "note": [],
      "return": "Absolute value of the input."
    },
    "params": [
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Input value."
      }
    ],
    "full_declaration": "native float FloatAbs(float value);"
  },
  {
    "name": "ArcTangent",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "float",
    "comment": "Returns the arctangent of the input value.",
    "tags": {
      "param": [
        {
          "name": "angle",
          "description": "Input value."
        }
      ],
      "error": [],
      "note": [],
      "return": "atan(value) in radians."
    },
    "params": [
      {
        "name": "angle",
        "type": "float",
        "default": null,
        "description": "Input value."
      }
    ],
    "full_declaration": "native float ArcTangent(float angle);"
  },
  {
    "name": "ArcCosine",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "float",
    "comment": "Returns the arccosine of the input value.",
    "tags": {
      "param": [
        {
          "name": "angle",
          "description": "Input value."
        }
      ],
      "error": [],
      "note": [],
      "return": "acos(value) in radians."
    },
    "params": [
      {
        "name": "angle",
        "type": "float",
        "default": null,
        "description": "Input value."
      }
    ],
    "full_declaration": "native float ArcCosine(float angle);"
  },
  {
    "name": "ArcSine",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "float",
    "comment": "Returns the arcsine of the input value.",
    "tags": {
      "param": [
        {
          "name": "angle",
          "description": "Input value."
        }
      ],
      "error": [],
      "note": [],
      "return": "asin(value) in radians."
    },
    "params": [
      {
        "name": "angle",
        "type": "float",
        "default": null,
        "description": "Input value."
      }
    ],
    "full_declaration": "native float ArcSine(float angle);"
  },
  {
    "name": "ArcTangent2",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "float",
    "comment": "Returns the arctangent2 of the input values.",
    "tags": {
      "param": [
        {
          "name": "x",
          "description": "Horizontal value."
        },
        {
          "name": "y",
          "description": "Vertical value."
        }
      ],
      "error": [],
      "note": [],
      "return": "atan2(value) in radians."
    },
    "params": [
      {
        "name": "x",
        "type": "float",
        "default": null,
        "description": "Horizontal value."
      },
      {
        "name": "y",
        "type": "float",
        "default": null,
        "description": "Vertical value."
      }
    ],
    "full_declaration": "native float ArcTangent2(float x, float y);"
  },
  {
    "name": "RoundFloat",
    "type": "stock",
    "source_file": "float.inc",
    "return_type": "int",
    "comment": "Rounds a floating point number using the \"round to nearest\" algorithm.",
    "tags": {
      "param": [
        {
          "name": "value",
          "description": "Floating point value to round."
        }
      ],
      "error": [],
      "note": [],
      "return": "The value rounded to the nearest integer."
    },
    "params": [
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Floating point value to round."
      }
    ],
    "full_declaration": "stock int RoundFloat(float value) { \treturn RoundToNearest(value);"
  },
  {
    "name": "__FLOAT_MUL__",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "float",
    "comment": "User defined operators.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "a",
        "type": "float",
        "default": null,
        "description": ""
      },
      {
        "name": "b",
        "type": "float",
        "default": null,
        "description": ""
      }
    ],
    "full_declaration": "native float __FLOAT_MUL__(float a, float b);"
  },
  {
    "name": "GetURandomInt",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "int",
    "comment": "Returns a random integer in the range [0, 2^31-1].\n\nNote: Uniform random number streams are seeded automatically per-plugin.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "Random integer."
    },
    "params": [],
    "full_declaration": "native int GetURandomInt();"
  },
  {
    "name": "GetURandomFloat",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "float",
    "comment": "Returns a uniform random float in the range [0, 1).\n\nNote: Uniform random number streams are seeded automatically per-plugin.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "Uniform random floating-point number."
    },
    "params": [],
    "full_declaration": "native float GetURandomFloat();"
  },
  {
    "name": "SetURandomSeed",
    "type": "native",
    "source_file": "float.inc",
    "return_type": "void",
    "comment": "Seeds a plugin's uniform random number stream. This is done automatically,\nso normally it is totally unnecessary to call this.",
    "tags": {
      "param": [
        {
          "name": "seeds",
          "description": "Array of numbers to use as seeding data."
        },
        {
          "name": "numSeeds",
          "description": "Number of seeds in the seeds array."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "seeds",
        "type": "int[]",
        "default": null,
        "description": "Array of numbers to use as seeding data."
      },
      {
        "name": "numSeeds",
        "type": "int",
        "default": null,
        "description": "Number of seeds in the seeds array."
      }
    ],
    "full_declaration": "native void SetURandomSeed(const int[] seeds, int numSeeds);"
  },
  {
    "name": "SetURandomSeedSimple",
    "type": "stock",
    "source_file": "float.inc",
    "return_type": "void",
    "comment": "Seeds a plugin's uniform random number stream. This is done automatically,\nso normally it is totally unnecessary to call this.",
    "tags": {
      "param": [
        {
          "name": "seed",
          "description": "Single seed value."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "seed",
        "type": "int",
        "default": null,
        "description": "Single seed value."
      }
    ],
    "full_declaration": "stock void SetURandomSeedSimple(int seed) { \tint seeds[1]; \tseeds[0] = seed; \tSetURandomSeed(seeds, 1);"
  },
  {
    "name": "GlobalForward",
    "type": "methodmap",
    "source_file": "functions.inc",
    "inherits": "Handle",
    "comment": "@endsection",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "methods": [],
    "properties": [],
    "full_declaration": "methodmap GlobalForward < Handle"
  },
  {
    "name": "GetFunctionByName",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "Function",
    "comment": "Gets a function id from a function name.",
    "tags": {
      "param": [
        {
          "name": "plugin",
          "description": "Handle of the plugin that contains the function. Pass INVALID_HANDLE to search in the calling plugin."
        },
        {
          "name": "name",
          "description": "Name of the function."
        }
      ],
      "error": [
        "Invalid or corrupt plugin handle."
      ],
      "note": [],
      "return": "Function id or INVALID_FUNCTION if not found."
    },
    "params": [
      {
        "name": "plugin",
        "type": "Handle",
        "default": null,
        "description": "Handle of the plugin that contains the function. Pass INVALID_HANDLE to search in the calling plugin."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Name of the function."
      }
    ],
    "full_declaration": "native Function GetFunctionByName(Handle plugin, const char[] name);"
  },
  {
    "name": "CreateGlobalForward",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "GlobalForward",
    "comment": "Creates a global forward.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Name of public function to use in forward."
        },
        {
          "name": "type",
          "description": "Execution type to be used."
        }
      ],
      "error": [
        "More than 32 parameter types passed."
      ],
      "note": [
        "The name used to create the forward is used as its public function in all target plugins.",
        "This is ideal for global, static forwards that are never changed.",
        "Global forwards cannot be cloned.",
        "Use CloseHandle() to destroy these."
      ],
      "return": "Handle to new global forward."
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Name of public function to use in forward."
      },
      {
        "name": "type",
        "type": "ExecType",
        "default": null,
        "description": "Execution type to be used."
      }
    ],
    "full_declaration": "native GlobalForward CreateGlobalForward(const char[] name, ExecType type, ParamType ...);"
  },
  {
    "name": "CreateForward",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "PrivateForward",
    "comment": "Creates a private forward.",
    "tags": {
      "param": [
        {
          "name": "type",
          "description": "Execution type to be used."
        }
      ],
      "error": [
        "More than 32 parameter types passed."
      ],
      "note": [
        "No functions are automatically added. Use AddToForward() to do this.",
        "Private forwards can be cloned.",
        "Use CloseHandle() to destroy these."
      ],
      "return": "Handle to new private forward."
    },
    "params": [
      {
        "name": "type",
        "type": "ExecType",
        "default": null,
        "description": "Execution type to be used."
      }
    ],
    "full_declaration": "native PrivateForward CreateForward(ExecType type, ParamType ...);"
  },
  {
    "name": "GetForwardFunctionCount",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "int",
    "comment": "Returns the number of functions in a global or private forward's call list.",
    "tags": {
      "param": [
        {
          "name": "fwd",
          "description": "Handle to global or private forward."
        }
      ],
      "error": [
        "Invalid or corrupt forward handle."
      ],
      "note": [],
      "return": "Number of functions in forward."
    },
    "params": [
      {
        "name": "fwd",
        "type": "Handle",
        "default": null,
        "description": "Handle to global or private forward."
      }
    ],
    "full_declaration": "native int GetForwardFunctionCount(Handle fwd);"
  },
  {
    "name": "AddToForward",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "bool",
    "comment": "Adds a function to a private forward's call list.",
    "tags": {
      "param": [
        {
          "name": "fwd",
          "description": "Handle to private forward."
        },
        {
          "name": "plugin",
          "description": "Handle of the plugin that contains the function. Pass INVALID_HANDLE to specify the calling plugin."
        },
        {
          "name": "func",
          "description": "Function to add to forward."
        }
      ],
      "error": [
        "Invalid or corrupt private forward handle, invalid or corrupt plugin handle, or invalid function."
      ],
      "note": [
        "Cannot be used during an incomplete call."
      ],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "fwd",
        "type": "Handle",
        "default": null,
        "description": "Handle to private forward."
      },
      {
        "name": "plugin",
        "type": "Handle",
        "default": null,
        "description": "Handle of the plugin that contains the function. Pass INVALID_HANDLE to specify the calling plugin."
      },
      {
        "name": "func",
        "type": "Function",
        "default": null,
        "description": "Function to add to forward."
      }
    ],
    "full_declaration": "native bool AddToForward(Handle fwd, Handle plugin, Function func);"
  },
  {
    "name": "RemoveFromForward",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "bool",
    "comment": "Removes a function from a private forward's call list.",
    "tags": {
      "param": [
        {
          "name": "fwd",
          "description": "Handle to private forward."
        },
        {
          "name": "plugin",
          "description": "Handle of the plugin that contains the function. Pass INVALID_HANDLE to specify the calling plugin."
        },
        {
          "name": "func",
          "description": "Function to remove from forward."
        }
      ],
      "error": [
        "Invalid or corrupt private forward handle, invalid or corrupt plugin handle, or invalid function."
      ],
      "note": [
        "Only removes one instance.",
        "Functions will be removed automatically if their parent plugin is unloaded."
      ],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "fwd",
        "type": "Handle",
        "default": null,
        "description": "Handle to private forward."
      },
      {
        "name": "plugin",
        "type": "Handle",
        "default": null,
        "description": "Handle of the plugin that contains the function. Pass INVALID_HANDLE to specify the calling plugin."
      },
      {
        "name": "func",
        "type": "Function",
        "default": null,
        "description": "Function to remove from forward."
      }
    ],
    "full_declaration": "native bool RemoveFromForward(Handle fwd, Handle plugin, Function func);"
  },
  {
    "name": "RemoveAllFromForward",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "int",
    "comment": "Removes all instances of a plugin from a private forward's call list.",
    "tags": {
      "param": [
        {
          "name": "fwd",
          "description": "Handle to private forward."
        },
        {
          "name": "plugin",
          "description": "Handle of the plugin to remove instances of. Pass INVALID_HANDLE to specify the calling plugin."
        }
      ],
      "error": [
        "Invalid or corrupt private forward handle or invalid or corrupt plugin handle."
      ],
      "note": [
        "Functions will be removed automatically if their parent plugin is unloaded."
      ],
      "return": "Number of functions removed from forward."
    },
    "params": [
      {
        "name": "fwd",
        "type": "Handle",
        "default": null,
        "description": "Handle to private forward."
      },
      {
        "name": "plugin",
        "type": "Handle",
        "default": null,
        "description": "Handle of the plugin to remove instances of. Pass INVALID_HANDLE to specify the calling plugin."
      }
    ],
    "full_declaration": "native int RemoveAllFromForward(Handle fwd, Handle plugin);"
  },
  {
    "name": "Call_StartForward",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "void",
    "comment": "Starts a call to functions in a forward's call list.",
    "tags": {
      "param": [
        {
          "name": "fwd",
          "description": "Handle to global or private forward."
        }
      ],
      "error": [
        "Invalid or corrupt forward handle or called before another call has completed."
      ],
      "note": [
        "Cannot be used during an incomplete call."
      ],
      "return": ""
    },
    "params": [
      {
        "name": "fwd",
        "type": "Handle",
        "default": null,
        "description": "Handle to global or private forward."
      }
    ],
    "full_declaration": "native void Call_StartForward(Handle fwd);"
  },
  {
    "name": "Call_StartFunction",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "void",
    "comment": "Starts a call to a function.",
    "tags": {
      "param": [
        {
          "name": "plugin",
          "description": "Handle of the plugin that contains the function. Pass INVALID_HANDLE to specify the calling plugin."
        },
        {
          "name": "func",
          "description": "Function to call."
        }
      ],
      "error": [
        "Invalid or corrupt plugin handle, invalid function, or called before another call has completed."
      ],
      "note": [
        "Cannot be used during an incomplete call."
      ],
      "return": ""
    },
    "params": [
      {
        "name": "plugin",
        "type": "Handle",
        "default": null,
        "description": "Handle of the plugin that contains the function. Pass INVALID_HANDLE to specify the calling plugin."
      },
      {
        "name": "func",
        "type": "Function",
        "default": null,
        "description": "Function to call."
      }
    ],
    "full_declaration": "native void Call_StartFunction(Handle plugin, Function func);"
  },
  {
    "name": "Call_PushCell",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "void",
    "comment": "Pushes a cell onto the current call.",
    "tags": {
      "param": [
        {
          "name": "value",
          "description": "Cell value to push."
        }
      ],
      "error": [
        "Called before a call has been started."
      ],
      "note": [
        "Cannot be used before a call has been started."
      ],
      "return": ""
    },
    "params": [
      {
        "name": "value",
        "type": "any",
        "default": null,
        "description": "Cell value to push."
      }
    ],
    "full_declaration": "native void Call_PushCell(any value);"
  },
  {
    "name": "Call_PushCellRef",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "void",
    "comment": "Pushes a cell by reference onto the current call.",
    "tags": {
      "param": [
        {
          "name": "value",
          "description": "Cell reference to push."
        }
      ],
      "error": [
        "Called before a call has been started."
      ],
      "note": [
        "Cannot be used before a call has been started."
      ],
      "return": ""
    },
    "params": [
      {
        "name": "value",
        "type": "any",
        "default": null,
        "description": "Cell reference to push."
      }
    ],
    "full_declaration": "native void Call_PushCellRef(any &value);"
  },
  {
    "name": "Call_PushFloat",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "void",
    "comment": "Pushes a float onto the current call.",
    "tags": {
      "param": [
        {
          "name": "value",
          "description": "Floating point value to push."
        }
      ],
      "error": [
        "Called before a call has been started."
      ],
      "note": [
        "Cannot be used before a call has been started."
      ],
      "return": ""
    },
    "params": [
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Floating point value to push."
      }
    ],
    "full_declaration": "native void Call_PushFloat(float value);"
  },
  {
    "name": "Call_PushFloatRef",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "void",
    "comment": "Pushes a float by reference onto the current call.",
    "tags": {
      "param": [
        {
          "name": "value",
          "description": "Floating point reference to push."
        }
      ],
      "error": [
        "Called before a call has been started."
      ],
      "note": [
        "Cannot be used before a call has been started."
      ],
      "return": ""
    },
    "params": [
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Floating point reference to push."
      }
    ],
    "full_declaration": "native void Call_PushFloatRef(float &value);"
  },
  {
    "name": "Call_PushArray",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "void",
    "comment": "Pushes an array onto the current call.",
    "tags": {
      "param": [
        {
          "name": "value",
          "description": "Array to push."
        },
        {
          "name": "size",
          "description": "Size of array."
        }
      ],
      "error": [
        "Called before a call has been started."
      ],
      "note": [
        "Changes to array are not copied back to caller. Use PushArrayEx() to do this.",
        "Cannot be used before a call has been started."
      ],
      "return": ""
    },
    "params": [
      {
        "name": "value",
        "type": "any[]",
        "default": null,
        "description": "Array to push."
      },
      {
        "name": "size",
        "type": "int",
        "default": null,
        "description": "Size of array."
      }
    ],
    "full_declaration": "native void Call_PushArray(const any[] value, int size);"
  },
  {
    "name": "Call_PushArrayEx",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "void",
    "comment": "Pushes an array onto the current call.",
    "tags": {
      "param": [
        {
          "name": "value",
          "description": "Array to push."
        },
        {
          "name": "size",
          "description": "Size of array."
        },
        {
          "name": "cpflags",
          "description": "Whether or not changes should be copied back to the input array. See SM_PARAM_* constants for details."
        }
      ],
      "error": [
        "Called before a call has been started."
      ],
      "note": [
        "Cannot be used before a call has been started."
      ],
      "return": ""
    },
    "params": [
      {
        "name": "value",
        "type": "any[]",
        "default": null,
        "description": "Array to push."
      },
      {
        "name": "size",
        "type": "int",
        "default": null,
        "description": "Size of array."
      },
      {
        "name": "cpflags",
        "type": "int",
        "default": null,
        "description": "Whether or not changes should be copied back to the input array. See SM_PARAM_* constants for details."
      }
    ],
    "full_declaration": "native void Call_PushArrayEx(any[] value, int size, int cpflags);"
  },
  {
    "name": "Call_PushNullVector",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "void",
    "comment": "Pushes the NULL_VECTOR onto the current call.",
    "tags": {
      "param": [],
      "error": [
        "Called before a call has been started."
      ],
      "note": [
        "Cannot be used before a call has been started."
      ],
      "return": "",
      "see": [
        "IsNullVector"
      ]
    },
    "params": [],
    "full_declaration": "native void Call_PushNullVector();"
  },
  {
    "name": "Call_PushString",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "void",
    "comment": "Pushes a string onto the current call.",
    "tags": {
      "param": [
        {
          "name": "value",
          "description": "String to push."
        }
      ],
      "error": [
        "Called before a call has been started."
      ],
      "note": [
        "Changes to string are not copied back to caller. Use PushStringEx() to do this.",
        "Cannot be used before a call has been started."
      ],
      "return": ""
    },
    "params": [
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "String to push."
      }
    ],
    "full_declaration": "native void Call_PushString(const char[] value);"
  },
  {
    "name": "Call_PushStringEx",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "void",
    "comment": "Pushes a string onto the current call.",
    "tags": {
      "param": [
        {
          "name": "value",
          "description": "String to push."
        },
        {
          "name": "length",
          "description": "Length of string buffer."
        },
        {
          "name": "szflags",
          "description": "Flags determining how string should be handled. See SM_PARAM_STRING_* constants for details. The default (0) is to push ASCII."
        },
        {
          "name": "cpflags",
          "description": "Whether or not changes should be copied back to the input array. See SM_PARAM_* constants for details."
        }
      ],
      "error": [
        "Called before a call has been started."
      ],
      "note": [
        "Cannot be used before a call has been started."
      ],
      "return": ""
    },
    "params": [
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "String to push."
      },
      {
        "name": "length",
        "type": "int",
        "default": null,
        "description": "Length of string buffer."
      },
      {
        "name": "szflags",
        "type": "int",
        "default": null,
        "description": "Flags determining how string should be handled. See SM_PARAM_STRING_* constants for details. The default (0) is to push ASCII."
      },
      {
        "name": "cpflags",
        "type": "int",
        "default": null,
        "description": "Whether or not changes should be copied back to the input array. See SM_PARAM_* constants for details."
      }
    ],
    "full_declaration": "native void Call_PushStringEx(char[] value, int length, int szflags, int cpflags);"
  },
  {
    "name": "Call_PushNullString",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "void",
    "comment": "Pushes the NULL_STRING onto the current call.",
    "tags": {
      "param": [],
      "error": [
        "Called before a call has been started."
      ],
      "note": [
        "Cannot be used before a call has been started."
      ],
      "return": "",
      "see": [
        "IsNullString"
      ]
    },
    "params": [],
    "full_declaration": "native void Call_PushNullString();"
  },
  {
    "name": "Call_Finish",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "int",
    "comment": "Completes a call to a function or forward's call list.",
    "tags": {
      "param": [
        {
          "name": "result",
          "description": "Return value of function or forward's call list."
        }
      ],
      "error": [
        "Called before a call has been started."
      ],
      "note": [
        "Cannot be used before a call has been started."
      ],
      "return": "SP_ERROR_NONE on success, any other integer on failure."
    },
    "params": [
      {
        "name": "result",
        "type": "any",
        "default": "",
        "description": "Return value of function or forward's call list."
      }
    ],
    "full_declaration": "native int Call_Finish(any &result=0);"
  },
  {
    "name": "Call_Cancel",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "void",
    "comment": "Cancels a call to a function or forward's call list.",
    "tags": {
      "param": [],
      "error": [
        "Called before a call has been started."
      ],
      "note": [
        "Cannot be used before a call has been started."
      ],
      "return": ""
    },
    "params": [],
    "full_declaration": "native void Call_Cancel();"
  },
  {
    "name": "CreateNative",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "void",
    "comment": "Creates a dynamic native.  This should only be called in AskPluginLoad(), or\nelse you risk not having your native shared with other plugins.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Name of the dynamic native; must be unique among all other registered dynamic natives."
        },
        {
          "name": "func",
          "description": "Function to use as the dynamic native."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Name of the dynamic native; must be unique among all other registered dynamic natives."
      },
      {
        "name": "func",
        "type": "NativeCall",
        "default": null,
        "description": "Function to use as the dynamic native."
      }
    ],
    "full_declaration": "native void CreateNative(const char[] name, NativeCall func);"
  },
  {
    "name": "ThrowNativeError",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "int",
    "comment": "Throws an error in the calling plugin of a native, instead of your own plugin.",
    "tags": {
      "param": [
        {
          "name": "error",
          "description": "Error code to use."
        },
        {
          "name": "fmt",
          "description": "Error message format."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "error",
        "type": "int",
        "default": null,
        "description": "Error code to use."
      },
      {
        "name": "fmt",
        "type": "char[]",
        "default": null,
        "description": "Error message format."
      }
    ],
    "full_declaration": "native int ThrowNativeError(int error, const char[] fmt, any ...);"
  },
  {
    "name": "GetNativeStringLength",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "int",
    "comment": "Retrieves the string length from a native parameter string.  This is useful for\nfetching the entire string using dynamic arrays.",
    "tags": {
      "param": [
        {
          "name": "param",
          "description": "Parameter number, starting from 1."
        },
        {
          "name": "length",
          "description": "Stores the length of the string."
        }
      ],
      "error": [
        "Invalid parameter number or calling from a non-native function."
      ],
      "note": [
        "If this function succeeds, Get/SetNativeString will also succeed."
      ],
      "return": "SP_ERROR_NONE on success, any other integer on failure."
    },
    "params": [
      {
        "name": "param",
        "type": "int",
        "default": null,
        "description": "Parameter number, starting from 1."
      },
      {
        "name": "length",
        "type": "int",
        "default": null,
        "description": "Stores the length of the string."
      }
    ],
    "full_declaration": "native int GetNativeStringLength(int param, int &length);"
  },
  {
    "name": "GetNativeString",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "int",
    "comment": "Retrieves a string from a native parameter.",
    "tags": {
      "param": [
        {
          "name": "param",
          "description": "Parameter number, starting from 1."
        },
        {
          "name": "buffer",
          "description": "Buffer to store the string in."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of the buffer."
        },
        {
          "name": "bytes",
          "description": "Optionally store the number of bytes written."
        }
      ],
      "error": [
        "Invalid parameter number or calling from a non-native function."
      ],
      "note": [
        "Output conditions are undefined on failure."
      ],
      "return": "SP_ERROR_NONE on success, any other integer on failure."
    },
    "params": [
      {
        "name": "param",
        "type": "int",
        "default": null,
        "description": "Parameter number, starting from 1."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the string in."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the buffer."
      },
      {
        "name": "bytes",
        "type": "int",
        "default": "",
        "description": "Optionally store the number of bytes written."
      }
    ],
    "full_declaration": "native int GetNativeString(int param, char[] buffer, int maxlength, int &bytes=0);"
  },
  {
    "name": "SetNativeString",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "int",
    "comment": "Sets a string in a native parameter.",
    "tags": {
      "param": [
        {
          "name": "param",
          "description": "Parameter number, starting from 1."
        },
        {
          "name": "source",
          "description": "Source string to use."
        },
        {
          "name": "maxlength",
          "description": "Maximum number of bytes to write."
        },
        {
          "name": "utf8",
          "description": "If false, string will not be written with UTF8 safety."
        },
        {
          "name": "bytes",
          "description": "Optionally store the number of bytes written."
        }
      ],
      "error": [
        "Invalid parameter number or calling from a non-native function."
      ],
      "note": [
        "Output conditions are undefined on failure."
      ],
      "return": "SP_ERROR_NONE on success, any other integer on failure."
    },
    "params": [
      {
        "name": "param",
        "type": "int",
        "default": null,
        "description": "Parameter number, starting from 1."
      },
      {
        "name": "source",
        "type": "char[]",
        "default": null,
        "description": "Source string to use."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum number of bytes to write."
      },
      {
        "name": "utf8",
        "type": "bool",
        "default": "",
        "description": "If false, string will not be written with UTF8 safety."
      },
      {
        "name": "bytes",
        "type": "int",
        "default": "",
        "description": "Optionally store the number of bytes written."
      }
    ],
    "full_declaration": "native int SetNativeString(int param, const char[] source, int maxlength, bool utf8=true, int &bytes=0);"
  },
  {
    "name": "GetNativeCell",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "any",
    "comment": "Gets a cell from a native parameter.",
    "tags": {
      "param": [
        {
          "name": "param",
          "description": "Parameter number, starting from 1."
        }
      ],
      "error": [
        "Invalid parameter number or calling from a non-native function."
      ],
      "note": [],
      "return": "Cell value at the parameter number."
    },
    "params": [
      {
        "name": "param",
        "type": "int",
        "default": null,
        "description": "Parameter number, starting from 1."
      }
    ],
    "full_declaration": "native any GetNativeCell(int param);"
  },
  {
    "name": "GetNativeFunction",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "Function",
    "comment": "Gets a function pointer from a native parameter.",
    "tags": {
      "param": [
        {
          "name": "param",
          "description": "Parameter number, starting from 1."
        }
      ],
      "error": [
        "Invalid parameter number, or calling from a non-native function."
      ],
      "note": [],
      "return": "Function pointer at the given parameter number."
    },
    "params": [
      {
        "name": "param",
        "type": "int",
        "default": null,
        "description": "Parameter number, starting from 1."
      }
    ],
    "full_declaration": "native Function GetNativeFunction(int param);"
  },
  {
    "name": "GetNativeCellRef",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "any",
    "comment": "Gets a cell from a native parameter, by reference.",
    "tags": {
      "param": [
        {
          "name": "param",
          "description": "Parameter number, starting from 1."
        }
      ],
      "error": [
        "Invalid parameter number or calling from a non-native function."
      ],
      "note": [],
      "return": "Cell value at the parameter number."
    },
    "params": [
      {
        "name": "param",
        "type": "int",
        "default": null,
        "description": "Parameter number, starting from 1."
      }
    ],
    "full_declaration": "native any GetNativeCellRef(int param);"
  },
  {
    "name": "SetNativeCellRef",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "void",
    "comment": "Sets a cell from a native parameter, by reference.",
    "tags": {
      "param": [
        {
          "name": "param",
          "description": "Parameter number, starting from 1."
        },
        {
          "name": "value",
          "description": "Cell value at the parameter number to set by reference."
        }
      ],
      "error": [
        "Invalid parameter number or calling from a non-native function."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "param",
        "type": "int",
        "default": null,
        "description": "Parameter number, starting from 1."
      },
      {
        "name": "value",
        "type": "any",
        "default": null,
        "description": "Cell value at the parameter number to set by reference."
      }
    ],
    "full_declaration": "native void SetNativeCellRef(int param, any value);"
  },
  {
    "name": "GetNativeArray",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "int",
    "comment": "Gets an array from a native parameter (always by reference).",
    "tags": {
      "param": [
        {
          "name": "param",
          "description": "Parameter number, starting from 1."
        },
        {
          "name": "local",
          "description": "Local array to copy into."
        },
        {
          "name": "size",
          "description": "Maximum size of local array."
        }
      ],
      "error": [
        "Invalid parameter number or calling from a non-native function."
      ],
      "note": [],
      "return": "SP_ERROR_NONE on success, anything else on failure."
    },
    "params": [
      {
        "name": "param",
        "type": "int",
        "default": null,
        "description": "Parameter number, starting from 1."
      },
      {
        "name": "local",
        "type": "any[]",
        "default": null,
        "description": "Local array to copy into."
      },
      {
        "name": "size",
        "type": "int",
        "default": null,
        "description": "Maximum size of local array."
      }
    ],
    "full_declaration": "native int GetNativeArray(int param, any[] local, int size);"
  },
  {
    "name": "SetNativeArray",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "int",
    "comment": "Copies a local array into a native parameter array (always by reference).",
    "tags": {
      "param": [
        {
          "name": "param",
          "description": "Parameter number, starting from 1."
        },
        {
          "name": "local",
          "description": "Local array to copy from."
        },
        {
          "name": "size",
          "description": "Size of the local array to copy."
        }
      ],
      "error": [
        "Invalid parameter number or calling from a non-native function."
      ],
      "note": [],
      "return": "SP_ERROR_NONE on success, anything else on failure."
    },
    "params": [
      {
        "name": "param",
        "type": "int",
        "default": null,
        "description": "Parameter number, starting from 1."
      },
      {
        "name": "local",
        "type": "any[]",
        "default": null,
        "description": "Local array to copy from."
      },
      {
        "name": "size",
        "type": "int",
        "default": null,
        "description": "Size of the local array to copy."
      }
    ],
    "full_declaration": "native int SetNativeArray(int param, const any[] local, int size);"
  },
  {
    "name": "IsNativeParamNullVector",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "bool",
    "comment": "Check if the native parameter is the NULL_VECTOR.",
    "tags": {
      "param": [
        {
          "name": "param",
          "description": "Parameter number, starting from 1."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if NULL_VECTOR, false otherwise."
    },
    "params": [
      {
        "name": "param",
        "type": "int",
        "default": null,
        "description": "Parameter number, starting from 1."
      }
    ],
    "full_declaration": "native bool IsNativeParamNullVector(int param);"
  },
  {
    "name": "IsNativeParamNullString",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "bool",
    "comment": "Check if the native parameter is the NULL_STRING.",
    "tags": {
      "param": [
        {
          "name": "param",
          "description": "Parameter number, starting from 1."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if NULL_STRING, false otherwise."
    },
    "params": [
      {
        "name": "param",
        "type": "int",
        "default": null,
        "description": "Parameter number, starting from 1."
      }
    ],
    "full_declaration": "native bool IsNativeParamNullString(int param);"
  },
  {
    "name": "FormatNativeString",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "int",
    "comment": "Formats a string using parameters from a native.",
    "tags": {
      "param": [
        {
          "name": "out_param",
          "description": "Output parameter number to write to.  If 0, out_string is used."
        },
        {
          "name": "fmt_param",
          "description": "Format parameter number.  If 0, fmt_string is used."
        },
        {
          "name": "vararg_param",
          "description": "First variable parameter number."
        },
        {
          "name": "out_len",
          "description": "Output string buffer maximum length (always required)."
        },
        {
          "name": "written",
          "description": "Optionally stores the number of bytes written."
        },
        {
          "name": "out_string",
          "description": "Output string buffer to use if out_param is not used."
        },
        {
          "name": "fmt_string",
          "description": "Format string to use if fmt_param is not used."
        }
      ],
      "error": [],
      "note": [
        "All parameter indexes start at 1.",
        "If the input and output buffers overlap, the contents of the output buffer at the end is undefined."
      ],
      "return": "SP_ERROR_NONE on success, anything else on failure."
    },
    "params": [
      {
        "name": "out_param",
        "type": "int",
        "default": null,
        "description": "Output parameter number to write to.  If 0, out_string is used."
      },
      {
        "name": "fmt_param",
        "type": "int",
        "default": null,
        "description": "Format parameter number.  If 0, fmt_string is used."
      },
      {
        "name": "vararg_param",
        "type": "int",
        "default": null,
        "description": "First variable parameter number."
      },
      {
        "name": "out_len",
        "type": "int",
        "default": null,
        "description": "Output string buffer maximum length (always required)."
      },
      {
        "name": "written",
        "type": "int",
        "default": "",
        "description": "Optionally stores the number of bytes written."
      },
      {
        "name": "out_string",
        "type": "char[]",
        "default": "",
        "description": "Output string buffer to use if out_param is not used."
      },
      {
        "name": "fmt_string",
        "type": "char[]",
        "default": "",
        "description": "Format string to use if fmt_param is not used."
      }
    ],
    "full_declaration": "native int FormatNativeString(int out_param, \t\t\t\t\t\t  int fmt_param, \t\t\t\t\t\t  int vararg_param, \t\t\t\t\t\t  int out_len, \t\t\t\t\t\t  int &written=0, \t\t\t\t\t\t  char[] out_string=\"\", \t\t\t\t\t\t  const char[] fmt_string=\"\");"
  },
  {
    "name": "RequestFrame",
    "type": "native",
    "source_file": "functions.inc",
    "return_type": "void",
    "comment": "Creates a single use Next Frame hook.",
    "tags": {
      "param": [
        {
          "name": "Function",
          "description": "Function to call on the next frame."
        },
        {
          "name": "data",
          "description": "Value to be passed on the invocation of the Function."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "Function",
        "type": "RequestFrameCallback",
        "default": null,
        "description": "Function to call on the next frame."
      },
      {
        "name": "data",
        "type": "any",
        "default": "",
        "description": "Value to be passed on the invocation of the Function."
      }
    ],
    "full_declaration": "native void RequestFrame(RequestFrameCallback Function, any data=0);"
  },
  {
    "name": "GeoipCode2",
    "type": "native",
    "source_file": "geoip.inc",
    "return_type": "bool",
    "comment": "Gets the two character country code from an IP address. (US, CA, etc)",
    "tags": {
      "param": [
        {
          "name": "ip",
          "description": "Ip to determine the country code."
        },
        {
          "name": "ccode",
          "description": "Destination string buffer to store the code."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "ip",
        "type": "char[]",
        "default": null,
        "description": "Ip to determine the country code."
      },
      {
        "name": "ccode",
        "type": "char",
        "default": null,
        "description": "Destination string buffer to store the code."
      }
    ],
    "full_declaration": "native bool GeoipCode2(const char[] ip, char ccode[3]);"
  },
  {
    "name": "GeoipCode3",
    "type": "native",
    "source_file": "geoip.inc",
    "return_type": "bool",
    "comment": "Gets the three character country code from an IP address. (USA, CAN, etc)",
    "tags": {
      "param": [
        {
          "name": "ip",
          "description": "Ip to determine the country code."
        },
        {
          "name": "ccode",
          "description": "Destination string buffer to store the code."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "ip",
        "type": "char[]",
        "default": null,
        "description": "Ip to determine the country code."
      },
      {
        "name": "ccode",
        "type": "char",
        "default": null,
        "description": "Destination string buffer to store the code."
      }
    ],
    "full_declaration": "native bool GeoipCode3(const char[] ip, char ccode[4]);"
  },
  {
    "name": "GeoipRegionCode",
    "type": "native",
    "source_file": "geoip.inc",
    "return_type": "bool",
    "comment": "Gets the region code with country code from an IP address. (US-IL, CH-CHE, etc)",
    "tags": {
      "param": [
        {
          "name": "ip",
          "description": "Ip to determine the region code."
        },
        {
          "name": "ccode",
          "description": "Destination string buffer to store the code."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "ip",
        "type": "char[]",
        "default": null,
        "description": "Ip to determine the region code."
      },
      {
        "name": "ccode",
        "type": "char",
        "default": null,
        "description": "Destination string buffer to store the code."
      }
    ],
    "full_declaration": "native bool GeoipRegionCode(const char[] ip, char ccode[12]);"
  },
  {
    "name": "GeoipContinentCode",
    "type": "native",
    "source_file": "geoip.inc",
    "return_type": "Continent",
    "comment": "Gets the two character continent code from an IP address. (EU, AS, etc)",
    "tags": {
      "param": [
        {
          "name": "ip",
          "description": "Ip to determine the continent code."
        },
        {
          "name": "ccode",
          "description": "Destination string buffer to store the code."
        }
      ],
      "error": [],
      "note": [],
      "return": "The continent id on success, 0 otherwise."
    },
    "params": [
      {
        "name": "ip",
        "type": "char[]",
        "default": null,
        "description": "Ip to determine the continent code."
      },
      {
        "name": "ccode",
        "type": "char",
        "default": null,
        "description": "Destination string buffer to store the code."
      }
    ],
    "full_declaration": "native Continent GeoipContinentCode(const char[] ip, char ccode[3]);"
  },
  {
    "name": "GeoipCountry",
    "type": "native",
    "source_file": "geoip.inc",
    "return_type": "bool",
    "comment": "Gets the full country name.",
    "tags": {
      "param": [
        {
          "name": "ip",
          "description": "Ip to determine the country code."
        },
        {
          "name": "name",
          "description": "Destination string buffer to store the country name."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of output string buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "ip",
        "type": "char[]",
        "default": null,
        "description": "Ip to determine the country code."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Destination string buffer to store the country name."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of output string buffer."
      }
    ],
    "full_declaration": "native bool GeoipCountry(const char[] ip, char[] name, int maxlength);"
  },
  {
    "name": "GeoipCountryEx",
    "type": "native",
    "source_file": "geoip.inc",
    "return_type": "bool",
    "comment": "Gets the full country name.",
    "tags": {
      "param": [
        {
          "name": "ip",
          "description": "Ip to determine the country code."
        },
        {
          "name": "name",
          "description": "Destination string buffer to store the country name."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of output string buffer."
        },
        {
          "name": "client",
          "description": "Client index in order to return the result in the player's language -1: the default language, which is english. 0: the server language. You can use LANG_SERVER define. >=1: the player's language."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "ip",
        "type": "char[]",
        "default": null,
        "description": "Ip to determine the country code."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Destination string buffer to store the country name."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of output string buffer."
      },
      {
        "name": "client",
        "type": "int",
        "default": "",
        "description": "Client index in order to return the result in the player's language -1: the default language, which is english. 0: the server language. You can use LANG_SERVER define. >=1: the player's language."
      }
    ],
    "full_declaration": "native bool GeoipCountryEx(const char[] ip, char[] name, int maxlength, int client = -1);"
  },
  {
    "name": "GeoipContinent",
    "type": "native",
    "source_file": "geoip.inc",
    "return_type": "bool",
    "comment": "Gets the full continent name.",
    "tags": {
      "param": [
        {
          "name": "ip",
          "description": "Ip to determine the continent code."
        },
        {
          "name": "name",
          "description": "Destination string buffer to store the continent name."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of output string buffer."
        },
        {
          "name": "client",
          "description": "Client index in order to return the result in the player's language -1: the default language, which is english. 0: the server language. You can use LANG_SERVER define. >=1: the player's language."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "ip",
        "type": "char[]",
        "default": null,
        "description": "Ip to determine the continent code."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Destination string buffer to store the continent name."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of output string buffer."
      },
      {
        "name": "client",
        "type": "int",
        "default": "",
        "description": "Client index in order to return the result in the player's language -1: the default language, which is english. 0: the server language. You can use LANG_SERVER define. >=1: the player's language."
      }
    ],
    "full_declaration": "native bool GeoipContinent(const char[] ip, char[] name, int maxlength, int client = -1);"
  },
  {
    "name": "GeoipRegion",
    "type": "native",
    "source_file": "geoip.inc",
    "return_type": "bool",
    "comment": "Gets the full region name.",
    "tags": {
      "param": [
        {
          "name": "ip",
          "description": "Ip to determine the region code."
        },
        {
          "name": "name",
          "description": "Destination string buffer to store the region name."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of output string buffer."
        },
        {
          "name": "client",
          "description": "Client index in order to return the result in the player's language -1: the default language, which is english. 0: the server language. You can use LANG_SERVER define. >=1: the player's language."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "ip",
        "type": "char[]",
        "default": null,
        "description": "Ip to determine the region code."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Destination string buffer to store the region name."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of output string buffer."
      },
      {
        "name": "client",
        "type": "int",
        "default": "",
        "description": "Client index in order to return the result in the player's language -1: the default language, which is english. 0: the server language. You can use LANG_SERVER define. >=1: the player's language."
      }
    ],
    "full_declaration": "native bool GeoipRegion(const char[] ip, char[] name, int maxlength, int client = -1);"
  },
  {
    "name": "GeoipCity",
    "type": "native",
    "source_file": "geoip.inc",
    "return_type": "bool",
    "comment": "Gets the city name.",
    "tags": {
      "param": [
        {
          "name": "ip",
          "description": "Ip to determine the city code."
        },
        {
          "name": "name",
          "description": "Destination string buffer to store the city name."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of output string buffer."
        },
        {
          "name": "client",
          "description": "Client index in order to return the result in the player's language -1: the default language, which is english. 0: the server language. You can use LANG_SERVER define. >=1: the player's language."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "ip",
        "type": "char[]",
        "default": null,
        "description": "Ip to determine the city code."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Destination string buffer to store the city name."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of output string buffer."
      },
      {
        "name": "client",
        "type": "int",
        "default": "",
        "description": "Client index in order to return the result in the player's language -1: the default language, which is english. 0: the server language. You can use LANG_SERVER define. >=1: the player's language."
      }
    ],
    "full_declaration": "native bool GeoipCity(const char[] ip, char[] name, int maxlength, int client = -1);"
  },
  {
    "name": "GeoipTimezone",
    "type": "native",
    "source_file": "geoip.inc",
    "return_type": "bool",
    "comment": "Gets the timezone.",
    "tags": {
      "param": [
        {
          "name": "ip",
          "description": "Ip to determine the timezone."
        },
        {
          "name": "name",
          "description": "Destination string buffer to store the timezone."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of output string buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "ip",
        "type": "char[]",
        "default": null,
        "description": "Ip to determine the timezone."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Destination string buffer to store the timezone."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of output string buffer."
      }
    ],
    "full_declaration": "native bool GeoipTimezone(const char[] ip, char[] name, int maxlength);"
  },
  {
    "name": "GeoipLatitude",
    "type": "native",
    "source_file": "geoip.inc",
    "return_type": "float",
    "comment": "Gets the city's latitude",
    "tags": {
      "param": [
        {
          "name": "ip",
          "description": "Ip to determine the city latitude."
        }
      ],
      "error": [],
      "note": [],
      "return": "The result of the latitude, 0 if latitude is not found"
    },
    "params": [
      {
        "name": "ip",
        "type": "char[]",
        "default": null,
        "description": "Ip to determine the city latitude."
      }
    ],
    "full_declaration": "native float GeoipLatitude(const char[] ip);"
  },
  {
    "name": "GeoipLongitude",
    "type": "native",
    "source_file": "geoip.inc",
    "return_type": "float",
    "comment": "Gets the city's longitude",
    "tags": {
      "param": [
        {
          "name": "ip",
          "description": "Ip to determine the city longitude."
        }
      ],
      "error": [],
      "note": [],
      "return": "The result of the longitude, 0 if longitude is not found"
    },
    "params": [
      {
        "name": "ip",
        "type": "char[]",
        "default": null,
        "description": "Ip to determine the city longitude."
      }
    ],
    "full_declaration": "native float GeoipLongitude(const char[] ip);"
  },
  {
    "name": "__ext_geoip_SetNTVOptional",
    "type": "public",
    "source_file": "geoip.inc",
    "return_type": "void",
    "comment": "Do not edit below this line!",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [],
    "full_declaration": "public void __ext_geoip_SetNTVOptional() { \tMarkNativeAsOptional(\"GeoipCode2\");"
  },
  {
    "name": "LogToGame",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "void",
    "comment": "Logs a generic message to the HL2 logs.",
    "tags": {
      "param": [
        {
          "name": "format",
          "description": "String format."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "String format."
      }
    ],
    "full_declaration": "native void LogToGame(const char[] format, any ...);"
  },
  {
    "name": "SetRandomSeed",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "void",
    "comment": "Sets the seed value for the global Half-Life 2 Random Stream.",
    "tags": {
      "param": [
        {
          "name": "seed",
          "description": "Seed value."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "seed",
        "type": "int",
        "default": null,
        "description": "Seed value."
      }
    ],
    "full_declaration": "native void SetRandomSeed(int seed);"
  },
  {
    "name": "GetRandomFloat",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "float",
    "comment": "Returns a random floating point number from the Half-Life 2 Random Stream.",
    "tags": {
      "param": [
        {
          "name": "fMin",
          "description": "Minimum random bound."
        },
        {
          "name": "fMax",
          "description": "Maximum random bound."
        }
      ],
      "error": [],
      "note": [],
      "return": "A random number between (inclusive) fMin and fMax."
    },
    "params": [
      {
        "name": "fMin",
        "type": "float",
        "default": "",
        "description": "Minimum random bound."
      },
      {
        "name": "fMax",
        "type": "float",
        "default": "",
        "description": "Maximum random bound."
      }
    ],
    "full_declaration": "native float GetRandomFloat(float fMin=0.0, float fMax=1.0);"
  },
  {
    "name": "GetRandomInt",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "int",
    "comment": "Returns a random number from the Half-Life 2 Random Stream.",
    "tags": {
      "param": [
        {
          "name": "nmin",
          "description": "Minimum random bound."
        },
        {
          "name": "nmax",
          "description": "Maximum random bound."
        }
      ],
      "error": [],
      "note": [],
      "return": "A random number between (inclusive) nmin and nmax."
    },
    "params": [
      {
        "name": "nmin",
        "type": "int",
        "default": null,
        "description": "Minimum random bound."
      },
      {
        "name": "nmax",
        "type": "int",
        "default": null,
        "description": "Maximum random bound."
      }
    ],
    "full_declaration": "native int GetRandomInt(int nmin, int nmax);"
  },
  {
    "name": "IsMapValid",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "bool",
    "comment": "Returns whether a map is valid or not.",
    "tags": {
      "param": [
        {
          "name": "map",
          "description": "Map name, excluding .bsp extension."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if valid, false otherwise."
    },
    "params": [
      {
        "name": "map",
        "type": "char[]",
        "default": null,
        "description": "Map name, excluding .bsp extension."
      }
    ],
    "full_declaration": "native bool IsMapValid(const char[] map);"
  },
  {
    "name": "FindMap",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "FindMapResult",
    "comment": "Returns whether a full or partial map name is found or can be resolved",
    "tags": {
      "param": [
        {
          "name": "map",
          "description": "Map name (usually same as map path relative to maps/ dir, excluding .bsp extension)."
        },
        {
          "name": "foundmap",
          "description": "Resolved map name. If the return is FindMap_FuzzyMatch or FindMap_NonCanonical the buffer will be the full path."
        },
        {
          "name": "maxlen",
          "description": "Maximum length to write to map var."
        }
      ],
      "error": [],
      "note": [],
      "return": "Result of the find operation. Not all result types are supported on all games."
    },
    "params": [
      {
        "name": "map",
        "type": "char[]",
        "default": null,
        "description": "Map name (usually same as map path relative to maps/ dir, excluding .bsp extension)."
      },
      {
        "name": "foundmap",
        "type": "char[]",
        "default": null,
        "description": "Resolved map name. If the return is FindMap_FuzzyMatch or FindMap_NonCanonical the buffer will be the full path."
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "Maximum length to write to map var."
      }
    ],
    "full_declaration": "native FindMapResult FindMap(const char[] map, char[] foundmap, int maxlen);"
  },
  {
    "name": "GetMapDisplayName",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "bool",
    "comment": "Get the display name of a workshop map.\n\nNote: You do not need to call FindMap first.  This native will call FindMap internally.",
    "tags": {
      "param": [
        {
          "name": "map",
          "description": "Map name (usually same as map path relative to maps/ dir, excluding .bsp extension)."
        },
        {
          "name": "displayName",
          "description": "Map's display name, i.e. cp_mymapname or de_mymapname. If FindMap returns FindMap_PossiblyAvailable or FindMap_NotFound, the map cannot be resolved and this native will return false, but displayName will be a copy of map."
        },
        {
          "name": "maxlen",
          "description": "Maximum length to write to displayName var."
        }
      ],
      "error": [],
      "note": [],
      "return": "true if FindMap returns FindMap_Found, FindMap_FuzzyMatch, or FindMap_NonCanonical. false if FindMap returns FindMap_PossiblyAvailable or FindMap_NotFound."
    },
    "params": [
      {
        "name": "map",
        "type": "char[]",
        "default": null,
        "description": "Map name (usually same as map path relative to maps/ dir, excluding .bsp extension)."
      },
      {
        "name": "displayName",
        "type": "char[]",
        "default": null,
        "description": "Map's display name, i.e. cp_mymapname or de_mymapname. If FindMap returns FindMap_PossiblyAvailable or FindMap_NotFound, the map cannot be resolved and this native will return false, but displayName will be a copy of map."
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "Maximum length to write to displayName var."
      }
    ],
    "full_declaration": "native bool GetMapDisplayName(const char[] map, char[] displayName, int maxlen);"
  },
  {
    "name": "IsDedicatedServer",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "bool",
    "comment": "Returns whether the server is dedicated.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "True if dedicated, false otherwise."
    },
    "params": [],
    "full_declaration": "native bool IsDedicatedServer();"
  },
  {
    "name": "GetEngineTime",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "float",
    "comment": "Returns a high-precision time value for profiling the engine.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "A floating point time value."
    },
    "params": [],
    "full_declaration": "native float GetEngineTime();"
  },
  {
    "name": "GetGameTime",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "float",
    "comment": "Returns the game time based on the game tick.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "Game tick time."
    },
    "params": [],
    "full_declaration": "native float GetGameTime();"
  },
  {
    "name": "GetGameTickCount",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "int",
    "comment": "Returns the game's internal tick count.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "Game tick count."
    },
    "params": [],
    "full_declaration": "native int GetGameTickCount();"
  },
  {
    "name": "GetGameFrameTime",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "float",
    "comment": "Returns the time the Game took processing the last frame.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "Game frame time."
    },
    "params": [],
    "full_declaration": "native float GetGameFrameTime();"
  },
  {
    "name": "GetGameDescription",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "int",
    "comment": "Returns the game description from the mod.",
    "tags": {
      "param": [
        {
          "name": "buffer",
          "description": "Buffer to store the description."
        },
        {
          "name": "maxlength",
          "description": "Maximum size of the buffer."
        },
        {
          "name": "original",
          "description": "If true, retrieves the original game description, ignoring any potential hooks from plugins."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of bytes written to the buffer (UTF-8 safe)."
    },
    "params": [
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the description."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum size of the buffer."
      },
      {
        "name": "original",
        "type": "bool",
        "default": "",
        "description": "If true, retrieves the original game description, ignoring any potential hooks from plugins."
      }
    ],
    "full_declaration": "native int GetGameDescription(char[] buffer, int maxlength, bool original=false);"
  },
  {
    "name": "GetGameFolderName",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "int",
    "comment": "Returns the name of the game's directory.",
    "tags": {
      "param": [
        {
          "name": "buffer",
          "description": "Buffer to store the directory name."
        },
        {
          "name": "maxlength",
          "description": "Maximum size of the buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of bytes written to the buffer (UTF-8 safe)."
    },
    "params": [
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the directory name."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum size of the buffer."
      }
    ],
    "full_declaration": "native int GetGameFolderName(char[] buffer, int maxlength);"
  },
  {
    "name": "GetCurrentMap",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "int",
    "comment": "Returns the current map name.",
    "tags": {
      "param": [
        {
          "name": "buffer",
          "description": "Buffer to store map name."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of bytes written (UTF-8 safe)."
    },
    "params": [
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store map name."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of buffer."
      }
    ],
    "full_declaration": "native int GetCurrentMap(char[] buffer, int maxlength);"
  },
  {
    "name": "PrecacheModel",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "int",
    "comment": "Precaches a given model.",
    "tags": {
      "param": [
        {
          "name": "model",
          "description": "Name of the model to precache."
        },
        {
          "name": "preload",
          "description": "If preload is true the file will be precached before level startup."
        }
      ],
      "error": [],
      "note": [],
      "return": "Returns the model index, 0 for error."
    },
    "params": [
      {
        "name": "model",
        "type": "char[]",
        "default": null,
        "description": "Name of the model to precache."
      },
      {
        "name": "preload",
        "type": "bool",
        "default": "",
        "description": "If preload is true the file will be precached before level startup."
      }
    ],
    "full_declaration": "native int PrecacheModel(const char[] model, bool preload=false);"
  },
  {
    "name": "PrecacheSentenceFile",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "int",
    "comment": "Precaches a given sentence file.",
    "tags": {
      "param": [
        {
          "name": "file",
          "description": "Name of the sentence file to precache."
        },
        {
          "name": "preload",
          "description": "If preload is true the file will be precached before level startup."
        }
      ],
      "error": [],
      "note": [],
      "return": "Returns a sentence file index."
    },
    "params": [
      {
        "name": "file",
        "type": "char[]",
        "default": null,
        "description": "Name of the sentence file to precache."
      },
      {
        "name": "preload",
        "type": "bool",
        "default": "",
        "description": "If preload is true the file will be precached before level startup."
      }
    ],
    "full_declaration": "native int PrecacheSentenceFile(const char[] file, bool preload=false);"
  },
  {
    "name": "PrecacheDecal",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "int",
    "comment": "Precaches a given decal.",
    "tags": {
      "param": [
        {
          "name": "decal",
          "description": "Name of the decal to precache."
        },
        {
          "name": "preload",
          "description": "If preload is true the file will be precached before level startup."
        }
      ],
      "error": [],
      "note": [],
      "return": "Returns a decal index."
    },
    "params": [
      {
        "name": "decal",
        "type": "char[]",
        "default": null,
        "description": "Name of the decal to precache."
      },
      {
        "name": "preload",
        "type": "bool",
        "default": "",
        "description": "If preload is true the file will be precached before level startup."
      }
    ],
    "full_declaration": "native int PrecacheDecal(const char[] decal, bool preload=false);"
  },
  {
    "name": "PrecacheGeneric",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "int",
    "comment": "Precaches a given generic file.",
    "tags": {
      "param": [
        {
          "name": "generic",
          "description": "Name of the generic file to precache."
        },
        {
          "name": "preload",
          "description": "If preload is true the file will be precached before level startup."
        }
      ],
      "error": [],
      "note": [],
      "return": "Returns a generic file index."
    },
    "params": [
      {
        "name": "generic",
        "type": "char[]",
        "default": null,
        "description": "Name of the generic file to precache."
      },
      {
        "name": "preload",
        "type": "bool",
        "default": "",
        "description": "If preload is true the file will be precached before level startup."
      }
    ],
    "full_declaration": "native int PrecacheGeneric(const char[] generic, bool preload=false);"
  },
  {
    "name": "IsModelPrecached",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "bool",
    "comment": "Returns if a given model is precached.",
    "tags": {
      "param": [
        {
          "name": "model",
          "description": "Name of the model to check."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if precached, false otherwise."
    },
    "params": [
      {
        "name": "model",
        "type": "char[]",
        "default": null,
        "description": "Name of the model to check."
      }
    ],
    "full_declaration": "native bool IsModelPrecached(const char[] model);"
  },
  {
    "name": "IsDecalPrecached",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "bool",
    "comment": "Returns if a given decal is precached.",
    "tags": {
      "param": [
        {
          "name": "decal",
          "description": "Name of the decal to check."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if precached, false otherwise."
    },
    "params": [
      {
        "name": "decal",
        "type": "char[]",
        "default": null,
        "description": "Name of the decal to check."
      }
    ],
    "full_declaration": "native bool IsDecalPrecached(const char[] decal);"
  },
  {
    "name": "IsGenericPrecached",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "bool",
    "comment": "Returns if a given generic file is precached.",
    "tags": {
      "param": [
        {
          "name": "generic",
          "description": "Name of the generic file to check."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if precached, false otherwise."
    },
    "params": [
      {
        "name": "generic",
        "type": "char[]",
        "default": null,
        "description": "Name of the generic file to check."
      }
    ],
    "full_declaration": "native bool IsGenericPrecached(const char[] generic);"
  },
  {
    "name": "PrecacheSound",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "bool",
    "comment": "Precaches a given sound.",
    "tags": {
      "param": [
        {
          "name": "sound",
          "description": "Name of the sound to precache."
        },
        {
          "name": "preload",
          "description": "If preload is true the file will be precached before level startup."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if successfully precached, false otherwise."
    },
    "params": [
      {
        "name": "sound",
        "type": "char[]",
        "default": null,
        "description": "Name of the sound to precache."
      },
      {
        "name": "preload",
        "type": "bool",
        "default": "",
        "description": "If preload is true the file will be precached before level startup."
      }
    ],
    "full_declaration": "native bool PrecacheSound(const char[] sound, bool preload=false);"
  },
  {
    "name": "IsSoundPrecached",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "bool",
    "comment": "Returns if a given sound is precached.",
    "tags": {
      "param": [
        {
          "name": "sound",
          "description": "Name of the sound to check."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if precached, false otherwise.",
      "deprecated": [
        "Doesn't work correctly, always returns true."
      ]
    },
    "params": [
      {
        "name": "sound",
        "type": "char[]",
        "default": null,
        "description": "Name of the sound to check."
      }
    ],
    "full_declaration": "native bool IsSoundPrecached(const char[] sound);"
  },
  {
    "name": "CreateDialog",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "void",
    "comment": "Creates different types of ingame messages.\n\nNote: On many newer games (Left 4 Dead/2008+), the display of this to clients is broken.\nAdditionally, as of 2018, some games also require the client to have cl_showpluginmessages\nset to 1, a non-default value, for this to function.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Index of the client."
        },
        {
          "name": "kv",
          "description": "KeyValues handle to set the menu keys and options. (Check iserverplugin.h for more information)."
        },
        {
          "name": "type",
          "description": "Message type to display ingame."
        }
      ],
      "error": [
        "Invalid client index, or client not in game."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Index of the client."
      },
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues handle to set the menu keys and options. (Check iserverplugin.h for more information)."
      },
      {
        "name": "type",
        "type": "DialogType",
        "default": null,
        "description": "Message type to display ingame."
      }
    ],
    "full_declaration": "native void CreateDialog(int client, Handle kv, DialogType type);"
  },
  {
    "name": "GuessSDKVersion",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "int",
    "comment": "Guesses the SDK version a mod was compiled against.  If nothing\nspecific is known about the game, the engine version is used instead.\n\nThe return values are guaranteed to increase chronologically (that is,\na later release will have a higher value).",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "SOURCE_SDK version code.",
      "deprecated": [
        "See GetEngineVersion()"
      ]
    },
    "params": [],
    "full_declaration": "native int GuessSDKVersion();"
  },
  {
    "name": "GetEngineVersion",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "EngineVersion",
    "comment": "Gets the engine version that the currently-loaded SM core was compiled against.\n\nThe engine version values are not guaranteed to be in any particular order,\nand should only be compared by (in)equality.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "An EngineVersion value."
    },
    "params": [],
    "full_declaration": "native EngineVersion GetEngineVersion();"
  },
  {
    "name": "PrintToChat",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "void",
    "comment": "Prints a message to a specific client in the chat area.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "format",
          "description": "Formatting rules."
        }
      ],
      "error": [
        "Invalid client index, or client not in game."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "Formatting rules."
      }
    ],
    "full_declaration": "native void PrintToChat(int client, const char[] format, any ...);"
  },
  {
    "name": "PrintToChatAll",
    "type": "stock",
    "source_file": "halflife.inc",
    "return_type": "void",
    "comment": "Prints a message to all clients in the chat area.",
    "tags": {
      "param": [
        {
          "name": "format",
          "description": "Formatting rules."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "Formatting rules."
      }
    ],
    "full_declaration": "stock void PrintToChatAll(const char[] format, any ...) { \tchar buffer[254];  \tfor (int i = 1; i <= MaxClients; i++) \t{ \t\tif (IsClientInGame(i)) \t\t{ \t\t\tSetGlobalTransTarget(i);"
  },
  {
    "name": "PrintCenterText",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "void",
    "comment": "Prints a message to a specific client in the center of the screen.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "format",
          "description": "Formatting rules."
        }
      ],
      "error": [
        "Invalid client index, or client not in game."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "Formatting rules."
      }
    ],
    "full_declaration": "native void PrintCenterText(int client, const char[] format, any ...);"
  },
  {
    "name": "PrintCenterTextAll",
    "type": "stock",
    "source_file": "halflife.inc",
    "return_type": "void",
    "comment": "Prints a message to all clients in the center of the screen.",
    "tags": {
      "param": [
        {
          "name": "format",
          "description": "Formatting rules."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "Formatting rules."
      }
    ],
    "full_declaration": "stock void PrintCenterTextAll(const char[] format, any ...) { \tchar buffer[254];  \tfor (int i = 1; i <= MaxClients; i++) \t{ \t\tif (IsClientInGame(i)) \t\t{ \t\t\tSetGlobalTransTarget(i);"
  },
  {
    "name": "PrintHintText",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "void",
    "comment": "Prints a message to a specific client with a hint box.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "format",
          "description": "Formatting rules."
        }
      ],
      "error": [
        "Invalid client index, or client not in game."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "Formatting rules."
      }
    ],
    "full_declaration": "native void PrintHintText(int client, const char[] format, any ...);"
  },
  {
    "name": "PrintHintTextToAll",
    "type": "stock",
    "source_file": "halflife.inc",
    "return_type": "void",
    "comment": "Prints a message to all clients with a hint box.",
    "tags": {
      "param": [
        {
          "name": "format",
          "description": "Formatting rules."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "Formatting rules."
      }
    ],
    "full_declaration": "stock void PrintHintTextToAll(const char[] format, any ...) { \tchar buffer[254];  \tfor (int i = 1; i <= MaxClients; i++) \t{ \t\tif (IsClientInGame(i)) \t\t{ \t\t\tSetGlobalTransTarget(i);"
  },
  {
    "name": "ShowVGUIPanel",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "void",
    "comment": "Shows a VGUI panel to a specific client.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "name",
          "description": "Panel type name (Check viewport_panel_names.h to see a list of some panel names)."
        },
        {
          "name": "Kv",
          "description": "KeyValues handle with all the data for the panel setup (Depends on the panel type and may be unused)."
        },
        {
          "name": "show",
          "description": "True to show the panel, or false to remove it from the client screen."
        }
      ],
      "error": [
        "Invalid client index, or client not in game."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Panel type name (Check viewport_panel_names.h to see a list of some panel names)."
      },
      {
        "name": "Kv",
        "type": "Handle",
        "default": "",
        "description": "KeyValues handle with all the data for the panel setup (Depends on the panel type and may be unused)."
      },
      {
        "name": "show",
        "type": "bool",
        "default": "",
        "description": "True to show the panel, or false to remove it from the client screen."
      }
    ],
    "full_declaration": "native void ShowVGUIPanel(int client, const char[] name, Handle Kv=INVALID_HANDLE, bool show=true);"
  },
  {
    "name": "CreateHudSynchronizer",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "Handle",
    "comment": "Creates a HUD synchronization object.  This object is used to automatically assign and\nre-use channels for a set of messages.\n\nThe HUD has a hardcoded number of channels (usually 6) for displaying\ntext.  You can use any channel for any area of the screen.  Text on\ndifferent channels can overlap, but text on the same channel will\nerase the old text first.  This overlapping and overwriting gets problematic.\n\nA HUD synchronization object automatically selects channels for you based on\nthe following heuristics:\n- If channel X was last used by the object, and hasn't been modified again,\nchannel X gets re-used.\n- Otherwise, a new channel is chosen based on the least-recently-used channel.\n\nThis ensures that if you display text on a sync object, that the previous text\ndisplayed on it will always be cleared first.  This is because your new text\nwill either overwrite the old text on the same channel, or because another\nchannel has already erased your text.\n\nNote that messages can still overlap if they are on different synchronization\nobjects, or they are displayed to manual channels.\n\nThese are particularly useful for displaying repeating or refreshing HUD text, in\naddition to displaying multiple message sets in one area of the screen (for example,\ncenter-say messages that may pop up randomly that you don't want to overlap each\nother).",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "New HUD synchronization object. The Handle can be closed with CloseHandle(). If HUD text is not supported on this mod, then INVALID_HANDLE is returned."
    },
    "params": [],
    "full_declaration": "native Handle CreateHudSynchronizer();"
  },
  {
    "name": "SetHudTextParams",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "void",
    "comment": "Sets the HUD parameters for drawing text.  These parameters are stored\nglobally, although nothing other than this function and SetHudTextParamsEx\nmodify them.\n\nYou must call this function before drawing text.  If you are drawing\ntext to multiple clients, you can set the parameters once, since\nthey won't be modified.  However, as soon as you pass control back\nto other plugins, you must reset the parameters next time you draw.",
    "tags": {
      "param": [
        {
          "name": "x",
          "description": "x coordinate, from 0 to 1.  -1.0 is the center."
        },
        {
          "name": "y",
          "description": "y coordinate, from 0 to 1.  -1.0 is the center."
        },
        {
          "name": "holdTime",
          "description": "Number of seconds to hold the text."
        },
        {
          "name": "r",
          "description": "Red color value."
        },
        {
          "name": "g",
          "description": "Green color value."
        },
        {
          "name": "b",
          "description": "Blue color value."
        },
        {
          "name": "a",
          "description": "Alpha transparency value."
        },
        {
          "name": "effect",
          "description": "0/1 causes the text to fade in and fade out. 2 causes the text to flash[?]."
        },
        {
          "name": "fxTime",
          "description": "Duration of chosen effect (may not apply to all effects)."
        },
        {
          "name": "fadeIn",
          "description": "Number of seconds to spend fading in."
        },
        {
          "name": "fadeOut",
          "description": "Number of seconds to spend fading out."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "x",
        "type": "float",
        "default": null,
        "description": "x coordinate, from 0 to 1.  -1.0 is the center."
      },
      {
        "name": "y",
        "type": "float",
        "default": null,
        "description": "y coordinate, from 0 to 1.  -1.0 is the center."
      },
      {
        "name": "holdTime",
        "type": "float",
        "default": null,
        "description": "Number of seconds to hold the text."
      },
      {
        "name": "r",
        "type": "int",
        "default": null,
        "description": "Red color value."
      },
      {
        "name": "g",
        "type": "int",
        "default": null,
        "description": "Green color value."
      },
      {
        "name": "b",
        "type": "int",
        "default": null,
        "description": "Blue color value."
      },
      {
        "name": "a",
        "type": "int",
        "default": null,
        "description": "Alpha transparency value."
      },
      {
        "name": "effect",
        "type": "int",
        "default": "",
        "description": "0/1 causes the text to fade in and fade out. 2 causes the text to flash[?]."
      },
      {
        "name": "fxTime",
        "type": "float",
        "default": "",
        "description": "Duration of chosen effect (may not apply to all effects)."
      },
      {
        "name": "fadeIn",
        "type": "float",
        "default": "",
        "description": "Number of seconds to spend fading in."
      },
      {
        "name": "fadeOut",
        "type": "float",
        "default": "",
        "description": "Number of seconds to spend fading out."
      }
    ],
    "full_declaration": "native void SetHudTextParams(float x, float y, float holdTime, int r, int g, int b, int a, int effect = 0, \t\t\t\t\t\tfloat fxTime=6.0, float fadeIn=0.1, float fadeOut=0.2);"
  },
  {
    "name": "SetHudTextParamsEx",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "void",
    "comment": "Sets the HUD parameters for drawing text.  These parameters are stored\nglobally, although nothing other than this function and SetHudTextParams\nmodify them.\n\nThis is the same as SetHudTextParams(), except it lets you set the alternate\ncolor for when effects require it.",
    "tags": {
      "param": [
        {
          "name": "x",
          "description": "x coordinate, from 0 to 1.  -1.0 is the center."
        },
        {
          "name": "y",
          "description": "y coordinate, from 0 to 1.  -1.0 is the center."
        },
        {
          "name": "holdTime",
          "description": "Number of seconds to hold the text."
        },
        {
          "name": "color1",
          "description": "First color set, array values being [red, green, blue, alpha]"
        },
        {
          "name": "color2",
          "description": "Second color set, array values being [red, green, blue, alpha]"
        },
        {
          "name": "effect",
          "description": "0/1 causes the text to fade in and fade out. 2 causes the text to flash[?]."
        },
        {
          "name": "fxTime",
          "description": "Duration of chosen effect (may not apply to all effects)."
        },
        {
          "name": "fadeIn",
          "description": "Number of seconds to spend fading in."
        },
        {
          "name": "fadeOut",
          "description": "Number of seconds to spend fading out."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "x",
        "type": "float",
        "default": null,
        "description": "x coordinate, from 0 to 1.  -1.0 is the center."
      },
      {
        "name": "y",
        "type": "float",
        "default": null,
        "description": "y coordinate, from 0 to 1.  -1.0 is the center."
      },
      {
        "name": "holdTime",
        "type": "float",
        "default": null,
        "description": "Number of seconds to hold the text."
      },
      {
        "name": "color1",
        "type": "int",
        "default": null,
        "description": "First color set, array values being [red, green, blue, alpha]"
      },
      {
        "name": "color2",
        "type": "int",
        "default": null,
        "description": "Second color set, array values being [red, green, blue, alpha]"
      },
      {
        "name": "effect",
        "type": "int",
        "default": "",
        "description": "0/1 causes the text to fade in and fade out. 2 causes the text to flash[?]."
      },
      {
        "name": "fxTime",
        "type": "float",
        "default": "",
        "description": "Duration of chosen effect (may not apply to all effects)."
      },
      {
        "name": "fadeIn",
        "type": "float",
        "default": "",
        "description": "Number of seconds to spend fading in."
      },
      {
        "name": "fadeOut",
        "type": "float",
        "default": "",
        "description": "Number of seconds to spend fading out."
      }
    ],
    "full_declaration": "native void SetHudTextParamsEx(float x, float y, float holdTime, int color1[4], \t\t\t\t\t\t  int color2[4]={255,255,255,0}, int effect = 0, float fxTime=6.0, \t\t\t\t\t\t  float fadeIn=0.1, float fadeOut=0.2);"
  },
  {
    "name": "ShowSyncHudText",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "int",
    "comment": "Shows a synchronized HUD message to a client.\n\nAs of this writing, only TF, HL2MP, and SourceForts support HUD Text.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index to send the message to."
        },
        {
          "name": "sync",
          "description": "Synchronization object."
        },
        {
          "name": "message",
          "description": "Message text or formatting rules."
        }
      ],
      "error": [
        "Invalid client index, client not in game, or sync object not valid."
      ],
      "note": [],
      "return": "-1 on failure, anything else on success. This function fails if the mod does not support it."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index to send the message to."
      },
      {
        "name": "sync",
        "type": "Handle",
        "default": null,
        "description": "Synchronization object."
      },
      {
        "name": "message",
        "type": "char[]",
        "default": null,
        "description": "Message text or formatting rules."
      }
    ],
    "full_declaration": "native int ShowSyncHudText(int client, Handle sync, const char[] message, any ...);"
  },
  {
    "name": "ClearSyncHud",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "void",
    "comment": "Clears the text on a synchronized HUD channel.\n\nThis is not the same as sending \"\" because it guarantees that it won't\noverwrite text on another channel.  For example, consider the scenario:\n\n1. Your synchronized message goes to channel 3.\n2. Someone else's non-synchronized message goes to channel 3.\n\nIf you were to simply send \"\" on your synchronized message,\nthen someone else's text could be overwritten.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index to send the message to."
        },
        {
          "name": "sync",
          "description": "Synchronization object."
        }
      ],
      "error": [
        "Invalid client index, client not in game, or sync object not valid."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index to send the message to."
      },
      {
        "name": "sync",
        "type": "Handle",
        "default": null,
        "description": "Synchronization object."
      }
    ],
    "full_declaration": "native void ClearSyncHud(int client, Handle sync);"
  },
  {
    "name": "ShowHudText",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "int",
    "comment": "Shows a HUD message to a client on the given channel.\n\nNote: while many games support HUD Text, not all do.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index to send the message to."
        },
        {
          "name": "channel",
          "description": "A channel number. If -1, then a channel will automatically be selected based on the least-recently-used channel.  If the channel is any other number, it will be modulo'd with the channel count to get a final channel number."
        },
        {
          "name": "message",
          "description": "Message text or formatting rules."
        }
      ],
      "error": [
        "Invalid client index, or client not in game."
      ],
      "note": [],
      "return": "-1 on failure (lack of mod support). Any other return value is the channel number that was used to render the text."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index to send the message to."
      },
      {
        "name": "channel",
        "type": "int",
        "default": null,
        "description": "A channel number. If -1, then a channel will automatically be selected based on the least-recently-used channel.  If the channel is any other number, it will be modulo'd with the channel count to get a final channel number."
      },
      {
        "name": "message",
        "type": "char[]",
        "default": null,
        "description": "Message text or formatting rules."
      }
    ],
    "full_declaration": "native int ShowHudText(int client, int channel, const char[] message, any ...);"
  },
  {
    "name": "ShowMOTDPanel",
    "type": "stock",
    "source_file": "halflife.inc",
    "return_type": "void",
    "comment": "Shows a MOTD panel to a specific client.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "title",
          "description": "Title of the panel (printed on the top border of the window)."
        },
        {
          "name": "msg",
          "description": "Contents of the panel, it can be treated as an url, filename or plain text depending on the type parameter (WARNING: msg has to be 192 bytes maximum!)"
        },
        {
          "name": "type",
          "description": "Determines the way to treat the message body of the panel."
        }
      ],
      "error": [
        "Invalid client index, or client not in game."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "title",
        "type": "char[]",
        "default": null,
        "description": "Title of the panel (printed on the top border of the window)."
      },
      {
        "name": "msg",
        "type": "char[]",
        "default": null,
        "description": "Contents of the panel, it can be treated as an url, filename or plain text depending on the type parameter (WARNING: msg has to be 192 bytes maximum!)"
      },
      {
        "name": "type",
        "type": "int",
        "default": "",
        "description": "Determines the way to treat the message body of the panel."
      }
    ],
    "full_declaration": "stock void ShowMOTDPanel(int client, const char[] title, const char[] msg, int type=MOTDPANEL_TYPE_INDEX) { \tchar num[3]; \tIntToString(type, num, sizeof(num));"
  },
  {
    "name": "DisplayAskConnectBox",
    "type": "stock",
    "source_file": "halflife.inc",
    "return_type": "void",
    "comment": "Displays a panel asking the client to connect to a specified IP.\n\nNote: On many newer games (Left 4 Dead/2008+), the display of this to clients is broken.\nAdditionally, as of 2018, some games also require the client to have cl_showpluginmessages\nset to 1, a non-default value, for this to function.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "time",
          "description": "Duration to hold the panel on the client's screen."
        },
        {
          "name": "ip",
          "description": "Destination IP."
        },
        {
          "name": "password",
          "description": "Password to connect to the destination IP. The client will be able to see this."
        }
      ],
      "error": [
        "Invalid client index, or client not in game."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "time",
        "type": "float",
        "default": null,
        "description": "Duration to hold the panel on the client's screen."
      },
      {
        "name": "ip",
        "type": "char[]",
        "default": null,
        "description": "Destination IP."
      },
      {
        "name": "password",
        "type": "char[]",
        "default": "",
        "description": "Password to connect to the destination IP. The client will be able to see this."
      }
    ],
    "full_declaration": "stock void DisplayAskConnectBox(int client, float time, const char[] ip, const char[] password = \"\") { \tchar destination[288]; \tFormatEx(destination, sizeof(destination), \"%s/%s\", ip, password);"
  },
  {
    "name": "EntIndexToEntRef",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "int",
    "comment": "Converts an entity index into a serial encoded entity reference.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index."
        }
      ],
      "error": [
        "Entity index >= GetMaxEntities() or < 0"
      ],
      "note": [],
      "return": "Entity reference or -1 on invalid entity."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      }
    ],
    "full_declaration": "native int EntIndexToEntRef(int entity);"
  },
  {
    "name": "EntRefToEntIndex",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "int",
    "comment": "Retrieves the entity index from a reference or validates an entity index.\nThe input ref is checked that it is still valid and refers to the same entity.",
    "tags": {
      "param": [
        {
          "name": "ref",
          "description": "Entity reference or index."
        }
      ],
      "error": [],
      "note": [],
      "return": "Entity index or returns INVALID_ENT_REFERENCE if ref is invalid."
    },
    "params": [
      {
        "name": "ref",
        "type": "int",
        "default": null,
        "description": "Entity reference or index."
      }
    ],
    "full_declaration": "native int EntRefToEntIndex(int ref);"
  },
  {
    "name": "MakeCompatEntRef",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "int",
    "comment": "Converts a reference into a backwards compatible version.",
    "tags": {
      "param": [
        {
          "name": "ref",
          "description": "Entity reference."
        }
      ],
      "error": [],
      "note": [],
      "return": "Bcompat reference."
    },
    "params": [
      {
        "name": "ref",
        "type": "int",
        "default": null,
        "description": "Entity reference."
      }
    ],
    "full_declaration": "native int MakeCompatEntRef(int ref);"
  },
  {
    "name": "GetClientsInRange",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "int",
    "comment": "Find clients that are potentially in range of a position.",
    "tags": {
      "param": [
        {
          "name": "origin",
          "description": "Coordinates from which to test range."
        },
        {
          "name": "rangeType",
          "description": "Range type to use for filtering clients."
        },
        {
          "name": "clients",
          "description": "Array to which found client indexes will be written."
        },
        {
          "name": "size",
          "description": "Maximum size of clients array."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of client indexes written to clients array."
    },
    "params": [
      {
        "name": "origin",
        "type": "float",
        "default": null,
        "description": "Coordinates from which to test range."
      },
      {
        "name": "rangeType",
        "type": "ClientRangeType",
        "default": null,
        "description": "Range type to use for filtering clients."
      },
      {
        "name": "clients",
        "type": "int[]",
        "default": null,
        "description": "Array to which found client indexes will be written."
      },
      {
        "name": "size",
        "type": "int",
        "default": null,
        "description": "Maximum size of clients array."
      }
    ],
    "full_declaration": "native int GetClientsInRange(const float origin[3], ClientRangeType rangeType, int[] clients, int size);"
  },
  {
    "name": "GetServerAuthId",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "void",
    "comment": "Retrieves the server's authentication string (SteamID).\n\nNote: If called before server is connected to Steam, auth id\nwill be invalid ([I:0:1], 1, etc.)",
    "tags": {
      "param": [
        {
          "name": "authType",
          "description": "Auth id type and format to use. (Only AuthId_Steam3 and AuthId_SteamID64 are supported)"
        },
        {
          "name": "auth",
          "description": "Buffer to store the server's auth id."
        },
        {
          "name": "maxlen",
          "description": "Maximum length of string buffer (includes NULL terminator)."
        }
      ],
      "error": [
        "Invalid AuthIdType given."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "authType",
        "type": "AuthIdType",
        "default": null,
        "description": "Auth id type and format to use. (Only AuthId_Steam3 and AuthId_SteamID64 are supported)"
      },
      {
        "name": "auth",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the server's auth id."
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "Maximum length of string buffer (includes NULL terminator)."
      }
    ],
    "full_declaration": "native void GetServerAuthId(AuthIdType authType, char[] auth, int maxlen);"
  },
  {
    "name": "GetServerSteamAccountId",
    "type": "native",
    "source_file": "halflife.inc",
    "return_type": "int",
    "comment": "Returns the server's Steam account ID.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "Steam account ID or 0 if not available."
    },
    "params": [],
    "full_declaration": "native int GetServerSteamAccountId();"
  },
  {
    "name": "CloseHandle",
    "type": "native",
    "source_file": "handles.inc",
    "return_type": "void",
    "comment": "Closes a Handle.  If the handle has multiple copies open,\nit is not destroyed unless all copies are closed.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "Handle to close."
        }
      ],
      "error": [
        "Invalid handles will cause a run time error."
      ],
      "note": [
        "Closing a Handle has a different meaning for each Handle type.  Make sure you read the documentation on whatever provided the Handle."
      ],
      "return": ""
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": null,
        "description": "Handle to close."
      }
    ],
    "full_declaration": "native void CloseHandle(Handle hndl);"
  },
  {
    "name": "CloneHandle",
    "type": "native",
    "source_file": "handles.inc",
    "return_type": "Handle",
    "comment": "Clones a Handle.  When passing handles in between plugins, caching handles\ncan result in accidental invalidation when one plugin releases the Handle, or is its owner\nis unloaded from memory.  To prevent this, the Handle may be \"cloned\" with a new owner.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "Handle to clone/duplicate."
        },
        {
          "name": "plugin",
          "description": "Optional Handle to another plugin to mark as the new owner. If no owner is passed, the owner becomes the calling plugin."
        }
      ],
      "error": [
        "Invalid handles will cause a run time error."
      ],
      "note": [
        "Usually, you will be cloning Handles for other plugins.  This means that if you clone the Handle without specifying the new owner, it will assume the identity of your original calling plugin, which is not very useful.  You should either specify that the receiving plugin should clone the handle on its own, or you should explicitly clone the Handle using the receiving plugin's identity Handle."
      ],
      "return": "Handle on success, INVALID_HANDLE if not cloneable."
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": null,
        "description": "Handle to clone/duplicate."
      },
      {
        "name": "plugin",
        "type": "Handle",
        "default": "",
        "description": "Optional Handle to another plugin to mark as the new owner. If no owner is passed, the owner becomes the calling plugin."
      }
    ],
    "full_declaration": "native Handle CloneHandle(Handle hndl, Handle plugin=INVALID_HANDLE);"
  },
  {
    "name": "IsValidHandle",
    "type": "native",
    "source_file": "handles.inc",
    "return_type": "bool",
    "comment": "Do not use this function.  Returns if a Handle and its contents\nare readable, whereas INVALID_HANDLE only checks for the absence\nof a Handle.\n\nThis function is intended only for tests where the validity of a\nHandle can absolutely not be known.\n\nDo not use this to check the return values of functions, or to\ncheck if timers should be closed (except in very rare cases).\nThis function is for very specific usage and using it for general\npurpose routines can and will hide very subtle bugs.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "Handle to test for validity."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if handle is valid, false otherwise.",
      "deprecated": [
        "Do not use this function."
      ]
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": null,
        "description": "Handle to test for validity."
      }
    ],
    "full_declaration": "native bool IsValidHandle(Handle hndl);"
  },
  {
    "name": "FormatUserLogText",
    "type": "stock",
    "source_file": "helpers.inc",
    "return_type": "void",
    "comment": "This function is deprecated. Use the %L format specifier instead.\n\nFormats a user's info as log text.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "buffer",
          "description": "Buffer for text."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of text."
        }
      ],
      "error": [],
      "note": [],
      "return": "",
      "deprecated": [
        "Use the %L format specifier instead."
      ]
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Buffer for text."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of text."
      }
    ],
    "full_declaration": "stock void FormatUserLogText(int client, char[] buffer, int maxlength) { \tFormatEx(buffer, maxlength, \"\\\"%L\\\"\", client);"
  },
  {
    "name": "FindPluginByFile",
    "type": "stock",
    "source_file": "helpers.inc",
    "return_type": "Handle",
    "comment": "Returns plugin handle from plugin filename.",
    "tags": {
      "param": [
        {
          "name": "filename",
          "description": "Filename of the plugin to search for."
        }
      ],
      "error": [],
      "note": [],
      "return": "Handle to plugin if found, INVALID_HANDLE otherwise."
    },
    "params": [
      {
        "name": "filename",
        "type": "char[]",
        "default": null,
        "description": "Filename of the plugin to search for."
      }
    ],
    "full_declaration": "stock Handle FindPluginByFile(const char[] filename) { \tchar buffer[256]; \t \tHandle iter = GetPluginIterator();"
  },
  {
    "name": "SearchForClients",
    "type": "stock",
    "source_file": "helpers.inc",
    "return_type": "int",
    "comment": "@deprecated          Use FindTarget() or ProcessTargetString().",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pattern",
        "type": "char[]",
        "default": null,
        "description": ""
      },
      {
        "name": "clients",
        "type": "int[]",
        "default": null,
        "description": ""
      },
      {
        "name": "maxClients",
        "type": "int",
        "default": null,
        "description": ""
      }
    ],
    "full_declaration": "stock int SearchForClients(const char[] pattern, int[] clients, int maxClients) { \tint total = 0; \t \tif (maxClients == 0) \t{ \t\treturn 0; \t} \t \tif (pattern[0] == '#') \t{ \t\tint input = StringToInt(pattern[1]);"
  },
  {
    "name": "FindTarget",
    "type": "stock",
    "source_file": "helpers.inc",
    "return_type": "int",
    "comment": "Wraps ProcessTargetString() and handles producing error messages for\nbad targets.\n\nNote that you should use LoadTranslations(\"common.phrases\") in OnPluginStart().\n\"common.phrases\" contains all of the translatable phrases that FindTarget() will\nreply with in the event a target is not found (error).",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client who issued command"
        },
        {
          "name": "target",
          "description": "Client's target argument"
        },
        {
          "name": "nobots",
          "description": "Optional. Set to true if bots should NOT be targetted"
        },
        {
          "name": "immunity",
          "description": "Optional. Set to false to ignore target immunity."
        }
      ],
      "error": [],
      "note": [],
      "return": "Index of target client, or -1 on error."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client who issued command"
      },
      {
        "name": "target",
        "type": "char[]",
        "default": null,
        "description": "Client's target argument"
      },
      {
        "name": "nobots",
        "type": "bool",
        "default": "",
        "description": "Optional. Set to true if bots should NOT be targetted"
      },
      {
        "name": "immunity",
        "type": "bool",
        "default": "",
        "description": "Optional. Set to false to ignore target immunity."
      }
    ],
    "full_declaration": "stock int FindTarget(int client, const char[] target, bool nobots = false, bool immunity = true) { \tchar target_name[MAX_TARGET_LENGTH]; \tint target_list[1], target_count; \tbool tn_is_ml; \t \tint flags = COMMAND_FILTER_NO_MULTI; \tif (nobots) \t{ \t\tflags |= COMMAND_FILTER_NO_BOTS; \t} \t \tif (!immunity) \t{ \t\tflags |= COMMAND_FILTER_NO_IMMUNITY; \t} \t \tif ((target_count = ProcessTargetString( \t\t\ttarget, \t\t\tclient,  \t\t\ttarget_list,  \t\t\t1,  \t\t\tflags, \t\t\ttarget_name, \t\t\tsizeof(target_name), \t\t\ttn_is_ml)) > 0) \t{ \t\treturn target_list[0]; \t}  \tReplyToTargetError(client, target_count);"
  },
  {
    "name": "LoadMaps",
    "type": "stock",
    "source_file": "helpers.inc",
    "return_type": "int",
    "comment": "This function is no longer supported.  It has been replaced with ReadMapList(),\nwhich uses a more unified caching and configuration mechanism.  This function also\nhas a bug where if the cvar contents changes, the fileTime change won't be recognized.\n\nLoads a specified array with maps. The maps will be either loaded from mapcyclefile, or if supplied\na cvar containing a file name. If the file in the cvar is bad, it will use mapcyclefile. The fileTime\nparameter is used to store a timestamp of the file. If specified, the file will only be reloaded if it\nhas changed.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Valid array handle, should be created with CreateArray(33) or larger."
        },
        {
          "name": "fileTime",
          "description": "Variable containing the \"last changed\" time of the file. Used to avoid needless reloading."
        },
        {
          "name": "fileCvar",
          "description": "CVAR set to the file to be loaded. Optional."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of maps loaded or 0 if in error.",
      "deprecated": [
        "Use ReadMapList() instead."
      ]
    },
    "params": [
      {
        "name": "array",
        "type": "Handle",
        "default": null,
        "description": "Valid array handle, should be created with CreateArray(33) or larger."
      },
      {
        "name": "fileTime",
        "type": "int",
        "default": "",
        "description": "Variable containing the \"last changed\" time of the file. Used to avoid needless reloading."
      },
      {
        "name": "fileCvar",
        "type": "Handle",
        "default": "",
        "description": "CVAR set to the file to be loaded. Optional."
      }
    ],
    "full_declaration": "stock int LoadMaps(Handle array, int &fileTime = 0, Handle fileCvar = INVALID_HANDLE) {  \tchar mapPath[256], mapFile[64]; \tbool fileFound = false; \t \tif (fileCvar != INVALID_HANDLE) \t{ \t\tGetConVarString(fileCvar, mapFile, 64);"
  },
  {
    "name": "CreateKeyValues",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "KeyValues",
    "comment": "Creates a new KeyValues structure.  The Handle must always be closed.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Name of the root section."
        },
        {
          "name": "firstKey",
          "description": "If non-empty, specifies the first key value."
        },
        {
          "name": "firstValue",
          "description": "If firstKey is non-empty, specifies the first key's value."
        }
      ],
      "error": [],
      "note": [],
      "return": "A Handle to a new KeyValues structure."
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Name of the root section."
      },
      {
        "name": "firstKey",
        "type": "char[]",
        "default": "",
        "description": "If non-empty, specifies the first key value."
      },
      {
        "name": "firstValue",
        "type": "char[]",
        "default": "",
        "description": "If firstKey is non-empty, specifies the first key's value."
      }
    ],
    "full_declaration": "native KeyValues CreateKeyValues(const char[] name, const char[] firstKey=\"\", const char[] firstValue=\"\");"
  },
  {
    "name": "KvSetString",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "void",
    "comment": "Sets a string value of a KeyValues key.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "key",
          "description": "Name of the key, or NULL_STRING."
        },
        {
          "name": "value",
          "description": "String value."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Name of the key, or NULL_STRING."
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "String value."
      }
    ],
    "full_declaration": "native void KvSetString(Handle kv, const char[] key, const char[] value);"
  },
  {
    "name": "KvSetNum",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "void",
    "comment": "Sets an integer value of a KeyValues key.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "key",
          "description": "Name of the key, or NULL_STRING."
        },
        {
          "name": "value",
          "description": "Value number."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Name of the key, or NULL_STRING."
      },
      {
        "name": "value",
        "type": "int",
        "default": null,
        "description": "Value number."
      }
    ],
    "full_declaration": "native void KvSetNum(Handle kv, const char[] key, int value);"
  },
  {
    "name": "KvSetUInt64",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "void",
    "comment": "Sets a large integer value of a KeyValues key.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "key",
          "description": "Name of the key, or NULL_STRING."
        },
        {
          "name": "value",
          "description": "Large integer value (0=High bits, 1=Low bits)"
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Name of the key, or NULL_STRING."
      },
      {
        "name": "value",
        "type": "int",
        "default": null,
        "description": "Large integer value (0=High bits, 1=Low bits)"
      }
    ],
    "full_declaration": "native void KvSetUInt64(Handle kv, const char[] key, const int value[2]);"
  },
  {
    "name": "KvSetFloat",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "void",
    "comment": "Sets a floating point value of a KeyValues key.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "key",
          "description": "Name of the key, or NULL_STRING."
        },
        {
          "name": "value",
          "description": "Floating point value."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Name of the key, or NULL_STRING."
      },
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Floating point value."
      }
    ],
    "full_declaration": "native void KvSetFloat(Handle kv, const char[] key, float value);"
  },
  {
    "name": "KvSetColor",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "void",
    "comment": "Sets a set of color values of a KeyValues key.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "key",
          "description": "Name of the key, or NULL_STRING."
        },
        {
          "name": "r",
          "description": "Red value."
        },
        {
          "name": "g",
          "description": "Green value."
        },
        {
          "name": "b",
          "description": "Blue value."
        },
        {
          "name": "a",
          "description": "Alpha value."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Name of the key, or NULL_STRING."
      },
      {
        "name": "r",
        "type": "int",
        "default": null,
        "description": "Red value."
      },
      {
        "name": "g",
        "type": "int",
        "default": null,
        "description": "Green value."
      },
      {
        "name": "b",
        "type": "int",
        "default": null,
        "description": "Blue value."
      },
      {
        "name": "a",
        "type": "int",
        "default": "",
        "description": "Alpha value."
      }
    ],
    "full_declaration": "native void KvSetColor(Handle kv, const char[] key, int r, int g, int b, int a=0);"
  },
  {
    "name": "KvSetVector",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "void",
    "comment": "Sets a vector value of a KeyValues key.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "key",
          "description": "Name of the key, or NULL_STRING."
        },
        {
          "name": "vec",
          "description": "Vector value."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Name of the key, or NULL_STRING."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Vector value."
      }
    ],
    "full_declaration": "native void KvSetVector(Handle kv, const char[] key, const float vec[3]);"
  },
  {
    "name": "KvGetString",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "void",
    "comment": "Retrieves a string value from a KeyValues key.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "key",
          "description": "Name of the key, or NULL_STRING."
        },
        {
          "name": "value",
          "description": "Buffer to store key value in."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of the value buffer."
        },
        {
          "name": "defvalue",
          "description": "Optional default value to use if the key is not found."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Name of the key, or NULL_STRING."
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store key value in."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the value buffer."
      },
      {
        "name": "defvalue",
        "type": "char[]",
        "default": "",
        "description": "Optional default value to use if the key is not found."
      }
    ],
    "full_declaration": "native void KvGetString(Handle kv, const char[] key, char[] value, int maxlength, const char[] defvalue=\"\");"
  },
  {
    "name": "KvGetNum",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "int",
    "comment": "Retrieves an integer value from a KeyValues key.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "key",
          "description": "Name of the key, or NULL_STRING."
        },
        {
          "name": "defvalue",
          "description": "Optional default value to use if the key is not found."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Integer value of the key."
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Name of the key, or NULL_STRING."
      },
      {
        "name": "defvalue",
        "type": "int",
        "default": "",
        "description": "Optional default value to use if the key is not found."
      }
    ],
    "full_declaration": "native int KvGetNum(Handle kv, const char[] key, int defvalue=0);"
  },
  {
    "name": "KvGetFloat",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "float",
    "comment": "Retrieves a floating point value from a KeyValues key.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "key",
          "description": "Name of the key, or NULL_STRING."
        },
        {
          "name": "defvalue",
          "description": "Optional default value to use if the key is not found."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Floating point value of the key."
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Name of the key, or NULL_STRING."
      },
      {
        "name": "defvalue",
        "type": "float",
        "default": "",
        "description": "Optional default value to use if the key is not found."
      }
    ],
    "full_declaration": "native float KvGetFloat(Handle kv, const char[] key, float defvalue=0.0);"
  },
  {
    "name": "KvGetColor",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "void",
    "comment": "Retrieves a set of color values from a KeyValues key.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "key",
          "description": "Name of the key, or NULL_STRING."
        },
        {
          "name": "r",
          "description": "Red value, set by reference."
        },
        {
          "name": "g",
          "description": "Green value, set by reference."
        },
        {
          "name": "b",
          "description": "Blue value, set by reference."
        },
        {
          "name": "a",
          "description": "Alpha value, set by reference."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Name of the key, or NULL_STRING."
      },
      {
        "name": "r",
        "type": "int",
        "default": null,
        "description": "Red value, set by reference."
      },
      {
        "name": "g",
        "type": "int",
        "default": null,
        "description": "Green value, set by reference."
      },
      {
        "name": "b",
        "type": "int",
        "default": null,
        "description": "Blue value, set by reference."
      },
      {
        "name": "a",
        "type": "int",
        "default": null,
        "description": "Alpha value, set by reference."
      }
    ],
    "full_declaration": "native void KvGetColor(Handle kv, const char[] key, int &r, int &g, int &b, int &a);"
  },
  {
    "name": "KvGetUInt64",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "void",
    "comment": "Retrieves a large integer value from a KeyValues key.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "key",
          "description": "Name of the key, or NULL_STRING."
        },
        {
          "name": "value",
          "description": "Array to represent the large integer."
        },
        {
          "name": "defvalue",
          "description": "Optional default value to use if the key is not found."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Name of the key, or NULL_STRING."
      },
      {
        "name": "value",
        "type": "int",
        "default": null,
        "description": "Array to represent the large integer."
      },
      {
        "name": "defvalue",
        "type": "int",
        "default": null,
        "description": "Optional default value to use if the key is not found."
      }
    ],
    "full_declaration": "native void KvGetUInt64(Handle kv, const char[] key, int value[2], int defvalue[2]={0,0});"
  },
  {
    "name": "KvGetVector",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "void",
    "comment": "Retrieves a vector value from a KeyValues key.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "key",
          "description": "Name of the key, or NULL_STRING."
        },
        {
          "name": "vec",
          "description": "Destination vector to store the value in."
        },
        {
          "name": "defvalue",
          "description": "Optional default value to use if the key is not found."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Name of the key, or NULL_STRING."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Destination vector to store the value in."
      },
      {
        "name": "defvalue",
        "type": "float",
        "default": null,
        "description": "Optional default value to use if the key is not found."
      }
    ],
    "full_declaration": "native void KvGetVector(Handle kv, const char[] key, float vec[3], const float defvalue[3]={0.0, 0.0, 0.0});"
  },
  {
    "name": "KvJumpToKey",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "bool",
    "comment": "Sets the current position in the KeyValues tree to the given key.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "key",
          "description": "Name of the key."
        },
        {
          "name": "create",
          "description": "If true, and the key does not exist, it will be created."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if the key exists, false if it does not and was not created."
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Name of the key."
      },
      {
        "name": "create",
        "type": "bool",
        "default": "",
        "description": "If true, and the key does not exist, it will be created."
      }
    ],
    "full_declaration": "native bool KvJumpToKey(Handle kv, const char[] key, bool create=false);"
  },
  {
    "name": "KvJumpToKeySymbol",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "bool",
    "comment": "Sets the current position in the KeyValues tree to the given key.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "id",
          "description": "KeyValues id."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if the key exists, false if it does not."
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "id",
        "type": "int",
        "default": null,
        "description": "KeyValues id."
      }
    ],
    "full_declaration": "native bool KvJumpToKeySymbol(Handle kv, int id);"
  },
  {
    "name": "KvGotoFirstSubKey",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "bool",
    "comment": "Sets the current position in the KeyValues tree to the first sub key.\nThis native adds to the internal traversal stack.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "keyOnly",
          "description": "If false, non-keys will be traversed (values)."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false if there was no first sub key."
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "keyOnly",
        "type": "bool",
        "default": "",
        "description": "If false, non-keys will be traversed (values)."
      }
    ],
    "full_declaration": "native bool KvGotoFirstSubKey(Handle kv, bool keyOnly=true);"
  },
  {
    "name": "KvGotoNextKey",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "bool",
    "comment": "Sets the current position in the KeyValues tree to the next sub key.\nThis native does NOT add to the internal traversal stack, and thus\nKvGoBack() is not needed for each successive call to this function.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "keyOnly",
          "description": "If false, non-keys will be traversed (values)."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false if there was no next sub key."
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "keyOnly",
        "type": "bool",
        "default": "",
        "description": "If false, non-keys will be traversed (values)."
      }
    ],
    "full_declaration": "native bool KvGotoNextKey(Handle kv, bool keyOnly=true);"
  },
  {
    "name": "KvSavePosition",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "bool",
    "comment": "Saves the current position in the traversal stack onto the traversal\nstack.  This can be useful if you wish to use KvGotoNextKey() and\nhave the previous key saved for backwards traversal.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false if there is no higher node."
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      }
    ],
    "full_declaration": "native bool KvSavePosition(Handle kv);"
  },
  {
    "name": "KvDeleteKey",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "bool",
    "comment": "Removes the given key from the current position.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "key",
          "description": "Name of the key."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false if key did not exist."
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Name of the key."
      }
    ],
    "full_declaration": "native bool KvDeleteKey(Handle kv, const char[] key);"
  },
  {
    "name": "KvDeleteThis",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "int",
    "comment": "Removes the current sub-key and attempts to set the position\nto the sub-key after the removed one.  If no such sub-key exists,\nthe position will be the parent key in the traversal stack.\nGiven the sub-key having position \"N\" in the traversal stack, the\nremoval will always take place from position \"N-1.\"",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "1 if removal succeeded and there was another key. 0 if the current node was not contained in the previous node, or no previous node exists. -1 if removal succeeded and there were no more keys, thus the state is as if KvGoBack() was called."
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      }
    ],
    "full_declaration": "native int KvDeleteThis(Handle kv);"
  },
  {
    "name": "KvGoBack",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "bool",
    "comment": "Jumps back to the previous position.  Returns false if there are no\nprevious positions (i.e., at the root node with an empty traversal stack).\nThis should be called once for each successful Jump call, in order to return\nto the top node.  This function pops one node off the internal traversal stack.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false if there is no higher node."
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      }
    ],
    "full_declaration": "native bool KvGoBack(Handle kv);"
  },
  {
    "name": "KvRewind",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "void",
    "comment": "Sets the position back to the top node, emptying the entire node\ntraversal history.  This can be used instead of looping KvGoBack()\nif recursive iteration is not important.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      }
    ],
    "full_declaration": "native void KvRewind(Handle kv);"
  },
  {
    "name": "KvGetSectionName",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "bool",
    "comment": "Retrieves the current section name.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "section",
          "description": "Buffer to store the section name."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of the name buffer."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false on failure."
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "section",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the section name."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the name buffer."
      }
    ],
    "full_declaration": "native bool KvGetSectionName(Handle kv, char[] section, int maxlength);"
  },
  {
    "name": "KvSetSectionName",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "void",
    "comment": "Sets the current section name.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "section",
          "description": "Section name."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "section",
        "type": "char[]",
        "default": null,
        "description": "Section name."
      }
    ],
    "full_declaration": "native void KvSetSectionName(Handle kv, const char[] section);"
  },
  {
    "name": "KvGetDataType",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "KvDataTypes",
    "comment": "Returns the data type at a key.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "key",
          "description": "Key name."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "KvDataType value of the key."
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Key name."
      }
    ],
    "full_declaration": "native KvDataTypes KvGetDataType(Handle kv, const char[] key);"
  },
  {
    "name": "KeyValuesToFile",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "bool",
    "comment": "Converts a KeyValues tree to a file.  The tree is dumped\nfrom the current position.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "file",
          "description": "File to dump write to."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "file",
        "type": "char[]",
        "default": null,
        "description": "File to dump write to."
      }
    ],
    "full_declaration": "native bool KeyValuesToFile(Handle kv, const char[] file);"
  },
  {
    "name": "FileToKeyValues",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "bool",
    "comment": "Converts a file to a KeyValues tree.  The file is read into\nthe current position of the tree.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "file",
          "description": "File to read from."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "file",
        "type": "char[]",
        "default": null,
        "description": "File to read from."
      }
    ],
    "full_declaration": "native bool FileToKeyValues(Handle kv, const char[] file);"
  },
  {
    "name": "StringToKeyValues",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "bool",
    "comment": "Converts a given string to a KeyValues tree.  The string is read into\nthe current postion of the tree.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "buffer",
          "description": "String buffer to load into the KeyValues."
        },
        {
          "name": "resourceName",
          "description": "The resource name of the KeyValues, used for error tracking purposes."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "String buffer to load into the KeyValues."
      },
      {
        "name": "resourceName",
        "type": "char[]",
        "default": "",
        "description": "The resource name of the KeyValues, used for error tracking purposes."
      }
    ],
    "full_declaration": "native bool StringToKeyValues(Handle kv, const char[] buffer, const char[] resourceName=\"StringToKeyValues\");"
  },
  {
    "name": "KvSetEscapeSequences",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "void",
    "comment": "Sets whether or not the KeyValues parser will read escape sequences.\nFor example, \\n would be read as a literal newline.  This defaults\nto false for new KeyValues structures.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "useEscapes",
          "description": "Whether or not to read escape sequences."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "useEscapes",
        "type": "bool",
        "default": null,
        "description": "Whether or not to read escape sequences."
      }
    ],
    "full_declaration": "native void KvSetEscapeSequences(Handle kv, bool useEscapes);"
  },
  {
    "name": "KvNodesInStack",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "int",
    "comment": "Returns the position in the jump stack; I.e. the number of calls\nrequired for KvGoBack to return to the root node.  If at the root node,\n0 is returned.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Number of non-root nodes in the jump stack."
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      }
    ],
    "full_declaration": "native int KvNodesInStack(Handle kv);"
  },
  {
    "name": "KvCopySubkeys",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "void",
    "comment": "Makes a new copy of all subkeys in the origin KeyValues to\nthe destination KeyValues.\nNOTE: All KeyValues are processed from the current location not the root one.",
    "tags": {
      "param": [
        {
          "name": "origin",
          "description": "Origin KeyValues Handle."
        },
        {
          "name": "dest",
          "description": "Destination KeyValues Handle."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "origin",
        "type": "Handle",
        "default": null,
        "description": "Origin KeyValues Handle."
      },
      {
        "name": "dest",
        "type": "Handle",
        "default": null,
        "description": "Destination KeyValues Handle."
      }
    ],
    "full_declaration": "native void KvCopySubkeys(Handle origin, Handle dest);"
  },
  {
    "name": "KvFindKeyById",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "bool",
    "comment": "Finds a KeyValues name by id.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "id",
          "description": "KeyValues id."
        },
        {
          "name": "name",
          "description": "Buffer to store the name."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of the value buffer."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false if id not found."
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "id",
        "type": "int",
        "default": null,
        "description": "KeyValues id."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the name."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the value buffer."
      }
    ],
    "full_declaration": "native bool KvFindKeyById(Handle kv, int id, char[] name, int maxlength);"
  },
  {
    "name": "KvGetNameSymbol",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "bool",
    "comment": "Finds a KeyValues id inside a KeyValues tree.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "key",
          "description": "Key name."
        },
        {
          "name": "id",
          "description": "Id of the found KeyValue."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false if key not found."
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Key name."
      },
      {
        "name": "id",
        "type": "int",
        "default": null,
        "description": "Id of the found KeyValue."
      }
    ],
    "full_declaration": "native bool KvGetNameSymbol(Handle kv, const char[] key, int &id);"
  },
  {
    "name": "KvGetSectionSymbol",
    "type": "native",
    "source_file": "keyvalues.inc",
    "return_type": "bool",
    "comment": "Retrieves the current section id.",
    "tags": {
      "param": [
        {
          "name": "kv",
          "description": "KeyValues Handle."
        },
        {
          "name": "id",
          "description": "Id of the current section."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false on failure."
    },
    "params": [
      {
        "name": "kv",
        "type": "Handle",
        "default": null,
        "description": "KeyValues Handle."
      },
      {
        "name": "id",
        "type": "int",
        "default": null,
        "description": "Id of the current section."
      }
    ],
    "full_declaration": "native bool KvGetSectionSymbol(Handle kv, int &id);"
  },
  {
    "name": "LoadTranslations",
    "type": "native",
    "source_file": "lang.inc",
    "return_type": "void",
    "comment": "Loads a translation file for the plugin calling this native.\nIf no extension is specified, .txt is assumed.",
    "tags": {
      "param": [
        {
          "name": "file",
          "description": "Translation file."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "file",
        "type": "char[]",
        "default": null,
        "description": "Translation file."
      }
    ],
    "full_declaration": "native void LoadTranslations(const char[] file);"
  },
  {
    "name": "SetGlobalTransTarget",
    "type": "native",
    "source_file": "lang.inc",
    "return_type": "void",
    "comment": "Sets the global language target.  This is useful for creating functions\nthat will be compatible with the %t format specifier.  Note that invalid\nindexes can be specified but the error will occur during translation,\nnot during this function call.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index or LANG_SERVER."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index or LANG_SERVER."
      }
    ],
    "full_declaration": "native void SetGlobalTransTarget(int client);"
  },
  {
    "name": "GetClientLanguage",
    "type": "native",
    "source_file": "lang.inc",
    "return_type": "int",
    "comment": "Retrieves the language number of a client.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        }
      ],
      "error": [
        "Invalid client index or client not connected."
      ],
      "note": [],
      "return": "Language number client is using."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      }
    ],
    "full_declaration": "native int GetClientLanguage(int client);"
  },
  {
    "name": "GetServerLanguage",
    "type": "native",
    "source_file": "lang.inc",
    "return_type": "int",
    "comment": "Retrieves the server's language.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "Language number server is using."
    },
    "params": [],
    "full_declaration": "native int GetServerLanguage();"
  },
  {
    "name": "GetLanguageCount",
    "type": "native",
    "source_file": "lang.inc",
    "return_type": "int",
    "comment": "Returns the number of languages known in languages.cfg.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "Language count."
    },
    "params": [],
    "full_declaration": "native int GetLanguageCount();"
  },
  {
    "name": "GetLanguageInfo",
    "type": "native",
    "source_file": "lang.inc",
    "return_type": "void",
    "comment": "Retrieves info about a given language number.",
    "tags": {
      "param": [
        {
          "name": "language",
          "description": "Language number."
        },
        {
          "name": "code",
          "description": "Language code buffer (2-3 characters usually)."
        },
        {
          "name": "codeLen",
          "description": "Maximum length of the language code buffer."
        },
        {
          "name": "name",
          "description": "Language name buffer."
        },
        {
          "name": "nameLen",
          "description": "Maximum length of the language name buffer."
        }
      ],
      "error": [
        "Invalid language number."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "language",
        "type": "int",
        "default": null,
        "description": "Language number."
      },
      {
        "name": "code",
        "type": "char[]",
        "default": "",
        "description": "Language code buffer (2-3 characters usually)."
      },
      {
        "name": "codeLen",
        "type": "int",
        "default": "",
        "description": "Maximum length of the language code buffer."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": "",
        "description": "Language name buffer."
      },
      {
        "name": "nameLen",
        "type": "int",
        "default": "",
        "description": "Maximum length of the language name buffer."
      }
    ],
    "full_declaration": "native void GetLanguageInfo(int language, char[] code=\"\", int codeLen=0, char[] name=\"\", int nameLen=0);"
  },
  {
    "name": "SetClientLanguage",
    "type": "native",
    "source_file": "lang.inc",
    "return_type": "void",
    "comment": "Sets the language number of a client.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "language",
          "description": "Language number."
        }
      ],
      "error": [
        "Invalid client index or client not connected."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "language",
        "type": "int",
        "default": null,
        "description": "Language number."
      }
    ],
    "full_declaration": "native void SetClientLanguage(int client, int language);"
  },
  {
    "name": "GetClientOriginalLanguage",
    "type": "native",
    "source_file": "lang.inc",
    "return_type": "int",
    "comment": "Retrieves the language number a client had when they connected.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        }
      ],
      "error": [
        "Invalid client index or client not connected."
      ],
      "note": [],
      "return": "Language number client originally had."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      }
    ],
    "full_declaration": "native int GetClientOriginalLanguage(int client);"
  },
  {
    "name": "GetLanguageByCode",
    "type": "native",
    "source_file": "lang.inc",
    "return_type": "int",
    "comment": "Retrieves the language number from a language code.",
    "tags": {
      "param": [
        {
          "name": "code",
          "description": "Language code (2-3 characters usually)."
        }
      ],
      "error": [],
      "note": [],
      "return": "Language number. -1 if not found."
    },
    "params": [
      {
        "name": "code",
        "type": "char[]",
        "default": null,
        "description": "Language code (2-3 characters usually)."
      }
    ],
    "full_declaration": "native int GetLanguageByCode(const char[] code);"
  },
  {
    "name": "GetLanguageByName",
    "type": "native",
    "source_file": "lang.inc",
    "return_type": "int",
    "comment": "Retrieves the language number from a language name.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Language name (case insensitive)."
        }
      ],
      "error": [],
      "note": [],
      "return": "Language number. -1 if not found."
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Language name (case insensitive)."
      }
    ],
    "full_declaration": "native int GetLanguageByName(const char[] name);"
  },
  {
    "name": "TranslationPhraseExists",
    "type": "native",
    "source_file": "lang.inc",
    "return_type": "bool",
    "comment": "Determines if the specified phrase exists within the plugin's\ntranslation cache.",
    "tags": {
      "param": [
        {
          "name": "phrase",
          "description": "Phrase to look for."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if phrase exists."
    },
    "params": [
      {
        "name": "phrase",
        "type": "char[]",
        "default": null,
        "description": "Phrase to look for."
      }
    ],
    "full_declaration": "native bool TranslationPhraseExists(const char[] phrase);"
  },
  {
    "name": "IsTranslatedForLanguage",
    "type": "native",
    "source_file": "lang.inc",
    "return_type": "bool",
    "comment": "Determines if there is a translation for the specified language.",
    "tags": {
      "param": [
        {
          "name": "phrase",
          "description": "Phrase to check."
        },
        {
          "name": "language",
          "description": "Language number."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if translation exists."
    },
    "params": [
      {
        "name": "phrase",
        "type": "char[]",
        "default": null,
        "description": "Phrase to check."
      },
      {
        "name": "language",
        "type": "int",
        "default": null,
        "description": "Language number."
      }
    ],
    "full_declaration": "native bool IsTranslatedForLanguage(const char[] phrase, int language);"
  },
  {
    "name": "LogMessage",
    "type": "native",
    "source_file": "logging.inc",
    "return_type": "void",
    "comment": "Logs a plugin message to the SourceMod logs.  The log message will be\nprefixed by the plugin's logtag (filename).",
    "tags": {
      "param": [
        {
          "name": "format",
          "description": "String format."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "String format."
      }
    ],
    "full_declaration": "native void LogMessage(const char[] format, any ...);"
  },
  {
    "name": "LogToFile",
    "type": "native",
    "source_file": "logging.inc",
    "return_type": "void",
    "comment": "Logs a message to any file.  The log message will be in the normal\nSourceMod format, with the plugin logtag prepended.",
    "tags": {
      "param": [
        {
          "name": "file",
          "description": "File to write the log message in."
        },
        {
          "name": "format",
          "description": "String format."
        }
      ],
      "error": [
        "File could not be opened/written."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "file",
        "type": "char[]",
        "default": null,
        "description": "File to write the log message in."
      },
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "String format."
      }
    ],
    "full_declaration": "native void LogToFile(const char[] file, const char[] format, any ...);"
  },
  {
    "name": "LogToFileEx",
    "type": "native",
    "source_file": "logging.inc",
    "return_type": "void",
    "comment": "Same as LogToFile(), except no plugin logtag is prepended.",
    "tags": {
      "param": [
        {
          "name": "file",
          "description": "File to write the log message in."
        },
        {
          "name": "format",
          "description": "String format."
        }
      ],
      "error": [
        "File could not be opened/written."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "file",
        "type": "char[]",
        "default": null,
        "description": "File to write the log message in."
      },
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "String format."
      }
    ],
    "full_declaration": "native void LogToFileEx(const char[] file, const char[] format, any ...);"
  },
  {
    "name": "LogAction",
    "type": "native",
    "source_file": "logging.inc",
    "return_type": "void",
    "comment": "Logs an action from a command or event whereby interception and routing may\nbe important.  This is intended to be a logging version of ShowActivity().",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client performing the action, 0 for server, or -1 if not applicable."
        },
        {
          "name": "target",
          "description": "Client being targetted, or -1 if not applicable."
        },
        {
          "name": "message",
          "description": "Message format."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client performing the action, 0 for server, or -1 if not applicable."
      },
      {
        "name": "target",
        "type": "int",
        "default": null,
        "description": "Client being targetted, or -1 if not applicable."
      },
      {
        "name": "message",
        "type": "char[]",
        "default": null,
        "description": "Message format."
      }
    ],
    "full_declaration": "native void LogAction(int client, int target, const char[] message, any ...);"
  },
  {
    "name": "LogError",
    "type": "native",
    "source_file": "logging.inc",
    "return_type": "void",
    "comment": "Logs a plugin error message to the SourceMod logs.",
    "tags": {
      "param": [
        {
          "name": "format",
          "description": "String format."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "String format."
      }
    ],
    "full_declaration": "native void LogError(const char[] format, any ...);"
  },
  {
    "name": "OnLogAction",
    "type": "forward",
    "source_file": "logging.inc",
    "return_type": "Action",
    "comment": "Called when an action is going to be logged.",
    "tags": {
      "param": [
        {
          "name": "source",
          "description": "Handle to the object logging the action, or INVALID_HANDLE if Core is logging the action."
        },
        {
          "name": "ident",
          "description": "Type of object logging the action (plugin, ext, or core)."
        },
        {
          "name": "client",
          "description": "Client the action is from; 0 for server, -1 if not applicable."
        },
        {
          "name": "target",
          "description": "Client the action is targetting, or -1 if not applicable."
        },
        {
          "name": "message",
          "description": "Message that is being logged."
        }
      ],
      "error": [],
      "note": [],
      "return": "Plugin_Continue will perform the default logging behavior. Plugin_Handled will stop Core from logging the message. Plugin_Stop is the same as Handled, but prevents any other plugins from handling the message."
    },
    "params": [
      {
        "name": "source",
        "type": "Handle",
        "default": null,
        "description": "Handle to the object logging the action, or INVALID_HANDLE if Core is logging the action."
      },
      {
        "name": "ident",
        "type": "Identity",
        "default": null,
        "description": "Type of object logging the action (plugin, ext, or core)."
      },
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client the action is from; 0 for server, -1 if not applicable."
      },
      {
        "name": "target",
        "type": "int",
        "default": null,
        "description": "Client the action is targetting, or -1 if not applicable."
      },
      {
        "name": "message",
        "type": "char[]",
        "default": null,
        "description": "Message that is being logged."
      }
    ],
    "full_declaration": "forward Action OnLogAction(Handle source, \t\t\t\t\t\t   Identity ident, \t\t\t\t\t\t   int client, \t\t\t\t\t\t   int target, \t\t\t\t\t\t   const char[] message);"
  },
  {
    "name": "GameLogHook",
    "type": "typedef",
    "source_file": "logging.inc",
    "return_type": "Action",
    "comment": "Called when a game log message is received.\n\nAny Log*() functions called within this callback will not recursively\npass through.  That is, they will log directly, bypassing this callback.\n\nNote that this does not capture log messages from the engine.  It only\ncaptures log messages being sent from the game/mod itself.",
    "tags": {
      "param": [
        {
          "name": "message",
          "description": "Message contents."
        }
      ],
      "error": [],
      "note": [],
      "return": "Plugin_Handled or Plugin_Stop will prevent the message from being written to the log file."
    },
    "params": [
      {
        "name": "message",
        "type": "char[]",
        "default": null,
        "description": "Message contents."
      }
    ],
    "full_declaration": "typedef GameLogHook = function Action (const char[] message);"
  },
  {
    "name": "AddGameLogHook",
    "type": "native",
    "source_file": "logging.inc",
    "return_type": "void",
    "comment": "Adds a game log hook.",
    "tags": {
      "param": [
        {
          "name": "hook",
          "description": "Hook function."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hook",
        "type": "GameLogHook",
        "default": null,
        "description": "Hook function."
      }
    ],
    "full_declaration": "native void AddGameLogHook(GameLogHook hook);"
  },
  {
    "name": "RemoveGameLogHook",
    "type": "native",
    "source_file": "logging.inc",
    "return_type": "void",
    "comment": "Removes a game log hook.",
    "tags": {
      "param": [
        {
          "name": "hook",
          "description": "Hook function."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hook",
        "type": "GameLogHook",
        "default": null,
        "description": "Hook function."
      }
    ],
    "full_declaration": "native void RemoveGameLogHook(GameLogHook hook);"
  },
  {
    "name": "NominateMap",
    "type": "native",
    "source_file": "mapchooser.inc",
    "return_type": "NominateResult",
    "comment": "Attempt to add a map to the mapchooser map list.",
    "tags": {
      "param": [
        {
          "name": "map",
          "description": "Map to add."
        },
        {
          "name": "force",
          "description": "Should we force the map in even if it requires overwriting an existing nomination?"
        },
        {
          "name": "owner",
          "description": "Client index of the nominator. If the client disconnects the nomination will be removed. Use 0 for constant nominations"
        }
      ],
      "error": [],
      "note": [],
      "return": "Nominate Result of the outcome"
    },
    "params": [
      {
        "name": "map",
        "type": "char[]",
        "default": null,
        "description": "Map to add."
      },
      {
        "name": "force",
        "type": "bool",
        "default": null,
        "description": "Should we force the map in even if it requires overwriting an existing nomination?"
      },
      {
        "name": "owner",
        "type": "int",
        "default": null,
        "description": "Client index of the nominator. If the client disconnects the nomination will be removed. Use 0 for constant nominations"
      }
    ],
    "full_declaration": "native NominateResult NominateMap(const char[] map, bool force, int owner);"
  },
  {
    "name": "RemoveNominationByMap",
    "type": "native",
    "source_file": "mapchooser.inc",
    "return_type": "bool",
    "comment": "Attempt to remove a map from the mapchooser map list.",
    "tags": {
      "param": [
        {
          "name": "map",
          "description": "Map to remove."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if the nomination was found and removed, or false if the nomination was not found."
    },
    "params": [
      {
        "name": "map",
        "type": "char[]",
        "default": null,
        "description": "Map to remove."
      }
    ],
    "full_declaration": "native bool RemoveNominationByMap(const char[] map);"
  },
  {
    "name": "RemoveNominationByOwner",
    "type": "native",
    "source_file": "mapchooser.inc",
    "return_type": "bool",
    "comment": "Attempt to remove a map from the mapchooser map list.",
    "tags": {
      "param": [
        {
          "name": "owner",
          "description": "Client index of the nominator."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if the nomination was found and removed, or false if the nomination was not found."
    },
    "params": [
      {
        "name": "owner",
        "type": "int",
        "default": null,
        "description": "Client index of the nominator."
      }
    ],
    "full_declaration": "native bool RemoveNominationByOwner(int owner);"
  },
  {
    "name": "GetExcludeMapList",
    "type": "native",
    "source_file": "mapchooser.inc",
    "return_type": "void",
    "comment": "Gets the current list of excluded maps.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "An ADT array handle to add the map strings to."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "array",
        "type": "ArrayList",
        "default": null,
        "description": "An ADT array handle to add the map strings to."
      }
    ],
    "full_declaration": "native void GetExcludeMapList(ArrayList array);"
  },
  {
    "name": "GetNominatedMapList",
    "type": "native",
    "source_file": "mapchooser.inc",
    "return_type": "void",
    "comment": "Gets the current list of nominated maps.",
    "tags": {
      "param": [
        {
          "name": "maparray",
          "description": "An ADT array handle to add the map strings to."
        },
        {
          "name": "ownerarray",
          "description": "An optional ADT array handle to add the nominator client indexes to."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "maparray",
        "type": "ArrayList",
        "default": null,
        "description": "An ADT array handle to add the map strings to."
      },
      {
        "name": "ownerarray",
        "type": "ArrayList",
        "default": "",
        "description": "An optional ADT array handle to add the nominator client indexes to."
      }
    ],
    "full_declaration": "native void GetNominatedMapList(ArrayList maparray, ArrayList ownerarray = null);"
  },
  {
    "name": "CanMapChooserStartVote",
    "type": "native",
    "source_file": "mapchooser.inc",
    "return_type": "bool",
    "comment": "Checks if MapChooser will allow a vote",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "True if a vote can be held, or false if mapchooser is already holding a vote."
    },
    "params": [],
    "full_declaration": "native bool CanMapChooserStartVote();"
  },
  {
    "name": "InitiateMapChooserVote",
    "type": "native",
    "source_file": "mapchooser.inc",
    "return_type": "void",
    "comment": "Initiates a MapChooser map vote\n\nNote: If no input array is specified mapchooser will use its internal list. This includes\nany nominations and excluded maps (as per mapchoosers convars).",
    "tags": {
      "param": [
        {
          "name": "when",
          "description": "MapChange consant of when the resulting mapchange should occur."
        },
        {
          "name": "inputarray",
          "description": "ADT array list of maps to add to the vote."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "when",
        "type": "MapChange",
        "default": null,
        "description": "MapChange consant of when the resulting mapchange should occur."
      },
      {
        "name": "inputarray",
        "type": "ArrayList",
        "default": "",
        "description": "ADT array list of maps to add to the vote."
      }
    ],
    "full_declaration": "native void InitiateMapChooserVote(MapChange when, ArrayList inputarray=null);"
  },
  {
    "name": "HasEndOfMapVoteFinished",
    "type": "native",
    "source_file": "mapchooser.inc",
    "return_type": "bool",
    "comment": "Checks if MapChooser's end of map vote has completed.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "True if complete, false otherwise."
    },
    "params": [],
    "full_declaration": "native bool HasEndOfMapVoteFinished();"
  },
  {
    "name": "EndOfMapVoteEnabled",
    "type": "native",
    "source_file": "mapchooser.inc",
    "return_type": "bool",
    "comment": "Checks if MapChooser is set to run an end of map vote.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "True if enabled, false otherwise."
    },
    "params": [],
    "full_declaration": "native bool EndOfMapVoteEnabled();"
  },
  {
    "name": "OnNominationRemoved",
    "type": "forward",
    "source_file": "mapchooser.inc",
    "return_type": "void",
    "comment": "Called when mapchooser removes a nomination from its list.\nNominations cleared on map start will not trigger this forward",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "map",
        "type": "char[]",
        "default": null,
        "description": ""
      },
      {
        "name": "owner",
        "type": "int",
        "default": null,
        "description": ""
      }
    ],
    "full_declaration": "forward void OnNominationRemoved(const char[] map, int owner);"
  },
  {
    "name": "OnMapVoteStarted",
    "type": "forward",
    "source_file": "mapchooser.inc",
    "return_type": "void",
    "comment": "Called when mapchooser starts a Map Vote.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [],
    "full_declaration": "forward void OnMapVoteStarted();"
  },
  {
    "name": "CreateMenu",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "Menu",
    "comment": "Creates a new, empty menu using the default style.",
    "tags": {
      "param": [
        {
          "name": "handler",
          "description": "Function which will receive menu actions."
        },
        {
          "name": "actions",
          "description": "Optionally set which actions to receive.  Select, Cancel, and End will always be received regardless of whether they are set or not.  They are also the only default actions."
        }
      ],
      "error": [],
      "note": [],
      "return": "A new menu Handle."
    },
    "params": [
      {
        "name": "handler",
        "type": "MenuHandler",
        "default": null,
        "description": "Function which will receive menu actions."
      },
      {
        "name": "actions",
        "type": "MenuAction",
        "default": "",
        "description": "Optionally set which actions to receive.  Select, Cancel, and End will always be received regardless of whether they are set or not.  They are also the only default actions."
      }
    ],
    "full_declaration": "native Menu CreateMenu(MenuHandler handler, MenuAction actions=MENU_ACTIONS_DEFAULT);"
  },
  {
    "name": "DisplayMenu",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "bool",
    "comment": "Displays a menu to a client.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        },
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "time",
          "description": "Maximum time to leave menu on the screen."
        }
      ],
      "error": [
        "Invalid Handle or client not in game."
      ],
      "note": [],
      "return": "True on success, false on failure."
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      },
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "time",
        "type": "int",
        "default": null,
        "description": "Maximum time to leave menu on the screen."
      }
    ],
    "full_declaration": "native bool DisplayMenu(Handle menu, int client, int time);"
  },
  {
    "name": "DisplayMenuAtItem",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "bool",
    "comment": "Displays a menu to a client, starting from the given item.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        },
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "first_item",
          "description": "First item to begin drawing from."
        },
        {
          "name": "time",
          "description": "Maximum time to leave menu on the screen."
        }
      ],
      "error": [
        "Invalid Handle or client not in game."
      ],
      "note": [],
      "return": "True on success, false on failure."
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      },
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "first_item",
        "type": "int",
        "default": null,
        "description": "First item to begin drawing from."
      },
      {
        "name": "time",
        "type": "int",
        "default": null,
        "description": "Maximum time to leave menu on the screen."
      }
    ],
    "full_declaration": "native bool DisplayMenuAtItem(Handle menu, int client, int first_item, int time);"
  },
  {
    "name": "AddMenuItem",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "bool",
    "comment": "Appends a new item to the end of a menu.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        },
        {
          "name": "info",
          "description": "Item information string."
        },
        {
          "name": "display",
          "description": "Default item display string."
        },
        {
          "name": "style",
          "description": "Drawing style flags.  Anything other than DEFAULT or DISABLED will be completely ignored when paginating."
        }
      ],
      "error": [
        "Invalid Handle or item limit reached."
      ],
      "note": [],
      "return": "True on success, false on failure."
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      },
      {
        "name": "info",
        "type": "char[]",
        "default": null,
        "description": "Item information string."
      },
      {
        "name": "display",
        "type": "char[]",
        "default": null,
        "description": "Default item display string."
      },
      {
        "name": "style",
        "type": "int",
        "default": "",
        "description": "Drawing style flags.  Anything other than DEFAULT or DISABLED will be completely ignored when paginating."
      }
    ],
    "full_declaration": "native bool AddMenuItem(Handle menu, \t\t\t\t\t\tconst char[] info, \t\t\t\t\t\tconst char[] display, \t\t\t\t\t\tint style=ITEMDRAW_DEFAULT);"
  },
  {
    "name": "InsertMenuItem",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "bool",
    "comment": "Inserts an item into the menu before a certain position; the new item will\nbe at the given position and all next items pushed forward.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        },
        {
          "name": "position",
          "description": "Position, starting from 0."
        },
        {
          "name": "info",
          "description": "Item information string."
        },
        {
          "name": "display",
          "description": "Default item display string."
        },
        {
          "name": "style",
          "description": "Drawing style flags.  Anything other than DEFAULT or DISABLED will be completely ignored when paginating."
        }
      ],
      "error": [
        "Invalid Handle or menu position."
      ],
      "note": [],
      "return": "True on success, false on failure."
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      },
      {
        "name": "position",
        "type": "int",
        "default": null,
        "description": "Position, starting from 0."
      },
      {
        "name": "info",
        "type": "char[]",
        "default": null,
        "description": "Item information string."
      },
      {
        "name": "display",
        "type": "char[]",
        "default": null,
        "description": "Default item display string."
      },
      {
        "name": "style",
        "type": "int",
        "default": "",
        "description": "Drawing style flags.  Anything other than DEFAULT or DISABLED will be completely ignored when paginating."
      }
    ],
    "full_declaration": "native bool InsertMenuItem(Handle menu, \t\t\t\t\t\tint position, \t\t\t\t\t\tconst char[] info, \t\t\t\t\t\tconst char[] display, \t\t\t\t\t\tint style=ITEMDRAW_DEFAULT);"
  },
  {
    "name": "RemoveMenuItem",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "bool",
    "comment": "Removes an item from the menu.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        },
        {
          "name": "position",
          "description": "Position, starting from 0."
        }
      ],
      "error": [
        "Invalid Handle or menu position."
      ],
      "note": [],
      "return": "True on success, false on failure."
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      },
      {
        "name": "position",
        "type": "int",
        "default": null,
        "description": "Position, starting from 0."
      }
    ],
    "full_declaration": "native bool RemoveMenuItem(Handle menu, int position);"
  },
  {
    "name": "RemoveAllMenuItems",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "void",
    "comment": "Removes all items from a menu.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        }
      ],
      "error": [
        "Invalid Handle or menu position."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      }
    ],
    "full_declaration": "native void RemoveAllMenuItems(Handle menu);"
  },
  {
    "name": "GetMenuItem",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "bool",
    "comment": "Retrieves information about a menu item.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        },
        {
          "name": "position",
          "description": "Position, starting from 0."
        },
        {
          "name": "infoBuf",
          "description": "Info buffer."
        },
        {
          "name": "infoBufLen",
          "description": "Maximum length of the info buffer."
        },
        {
          "name": "style",
          "description": "By-reference variable to store drawing flags."
        },
        {
          "name": "dispBuf",
          "description": "Display buffer."
        },
        {
          "name": "dispBufLen",
          "description": "Maximum length of the display buffer."
        },
        {
          "name": "client",
          "description": "Client index. Must be specified if menu is per-client random shuffled, -1 to ignore."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false if position is invalid."
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      },
      {
        "name": "position",
        "type": "int",
        "default": null,
        "description": "Position, starting from 0."
      },
      {
        "name": "infoBuf",
        "type": "char[]",
        "default": null,
        "description": "Info buffer."
      },
      {
        "name": "infoBufLen",
        "type": "int",
        "default": null,
        "description": "Maximum length of the info buffer."
      },
      {
        "name": "style",
        "type": "int",
        "default": "",
        "description": "By-reference variable to store drawing flags."
      },
      {
        "name": "dispBuf",
        "type": "char[]",
        "default": "",
        "description": "Display buffer."
      },
      {
        "name": "dispBufLen",
        "type": "int",
        "default": "",
        "description": "Maximum length of the display buffer."
      },
      {
        "name": "client",
        "type": "int",
        "default": "",
        "description": "Client index. Must be specified if menu is per-client random shuffled, -1 to ignore."
      }
    ],
    "full_declaration": "native bool GetMenuItem(Handle menu, \t\t\t\t\t\tint position, \t\t\t\t\t\tchar[] infoBuf, \t\t\t\t\t\tint infoBufLen, \t\t\t\t\t\tint &style=0, \t\t\t\t\t\tchar[] dispBuf=\"\", \t\t\t\t\t\tint dispBufLen=0, \t\t\t\t\t\tint client=0);"
  },
  {
    "name": "MenuShufflePerClient",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "void",
    "comment": "Generates a per-client random mapping for the current vote options.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        },
        {
          "name": "start",
          "description": "Menu item index to start randomizing from."
        },
        {
          "name": "stop",
          "description": "Menu item index to stop randomizing at. -1 = infinite"
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      },
      {
        "name": "start",
        "type": "int",
        "default": "",
        "description": "Menu item index to start randomizing from."
      },
      {
        "name": "stop",
        "type": "int",
        "default": "",
        "description": "Menu item index to stop randomizing at. -1 = infinite"
      }
    ],
    "full_declaration": "native void MenuShufflePerClient(Handle menu, int start=0, int stop=-1);"
  },
  {
    "name": "GetMenuSelectionPosition",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "int",
    "comment": "Returns the first item on the page of a currently selected menu.\n\nThis is only valid inside a MenuAction_Select callback.",
    "tags": {
      "param": [],
      "error": [
        "Not called from inside a MenuAction_Select callback."
      ],
      "note": [],
      "return": "First item number on the page the client was viewing before selecting the item in the callback.  This can be used to re-display the menu from the original position."
    },
    "params": [],
    "full_declaration": "native int GetMenuSelectionPosition();"
  },
  {
    "name": "GetMenuItemCount",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "int",
    "comment": "Returns the number of items in a menu.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Number of items in the menu."
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      }
    ],
    "full_declaration": "native int GetMenuItemCount(Handle menu);"
  },
  {
    "name": "SetMenuPagination",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "bool",
    "comment": "Sets whether the menu should be paginated or not.\n\nIf itemsPerPage is MENU_NO_PAGINATION, and the exit button flag is set,\nthen the exit button flag is removed.  It can be re-applied if desired.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Handle to the menu."
        },
        {
          "name": "itemsPerPage",
          "description": "Number of items per page, or MENU_NO_PAGINATION."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false if pagination is too high or low."
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Handle to the menu."
      },
      {
        "name": "itemsPerPage",
        "type": "int",
        "default": null,
        "description": "Number of items per page, or MENU_NO_PAGINATION."
      }
    ],
    "full_declaration": "native bool SetMenuPagination(Handle menu, int itemsPerPage);"
  },
  {
    "name": "GetMenuPagination",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "int",
    "comment": "Returns a menu's pagination setting.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Handle to the menu."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Pagination setting."
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Handle to the menu."
      }
    ],
    "full_declaration": "native int GetMenuPagination(Handle menu);"
  },
  {
    "name": "GetMenuStyle",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "Handle",
    "comment": "Returns a menu's MenuStyle Handle.  The Handle\nis global and cannot be freed.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Handle to the menu."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Handle to the menu's draw style."
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Handle to the menu."
      }
    ],
    "full_declaration": "native Handle GetMenuStyle(Handle menu);"
  },
  {
    "name": "SetMenuTitle",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "void",
    "comment": "Sets the menu's default title/instruction message.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        },
        {
          "name": "fmt",
          "description": "Message string format"
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      },
      {
        "name": "fmt",
        "type": "char[]",
        "default": null,
        "description": "Message string format"
      }
    ],
    "full_declaration": "native void SetMenuTitle(Handle menu, const char[] fmt, any ...);"
  },
  {
    "name": "GetMenuTitle",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "int",
    "comment": "Returns the text of a menu's title.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        },
        {
          "name": "buffer",
          "description": "Buffer to store title."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of the buffer."
        }
      ],
      "error": [
        "Invalid Handle/"
      ],
      "note": [],
      "return": "Number of bytes written."
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store title."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the buffer."
      }
    ],
    "full_declaration": "native int GetMenuTitle(Handle menu, char[] buffer, int maxlength);"
  },
  {
    "name": "CreatePanelFromMenu",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "Panel",
    "comment": "Creates a raw MenuPanel based off the menu's style.\nThe Handle must be freed with CloseHandle().",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "A new MenuPanel Handle."
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      }
    ],
    "full_declaration": "native Panel CreatePanelFromMenu(Handle menu);"
  },
  {
    "name": "GetMenuExitButton",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "bool",
    "comment": "Returns whether or not the menu has an exit button.\nBy default, menus have an exit button.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True if the menu has an exit button; false otherwise."
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      }
    ],
    "full_declaration": "native bool GetMenuExitButton(Handle menu);"
  },
  {
    "name": "SetMenuExitButton",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "bool",
    "comment": "Sets whether or not the menu has an exit button.  By default, paginated menus\nhave an exit button.\n\nIf a menu's pagination is changed to MENU_NO_PAGINATION, and the pagination\nwas previously a different value, then the Exit button status is changed to\nfalse.  It must be explicitly re-enabled afterwards.\n\nIf a non-paginated menu has an exit button, then at most 9 items will be\ndisplayed.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        },
        {
          "name": "button",
          "description": "True to enable the button, false to remove it."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True if allowed; false on failure."
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      },
      {
        "name": "button",
        "type": "bool",
        "default": null,
        "description": "True to enable the button, false to remove it."
      }
    ],
    "full_declaration": "native bool SetMenuExitButton(Handle menu, bool button);"
  },
  {
    "name": "GetMenuExitBackButton",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "bool",
    "comment": "Returns whether or not the menu has an \"exit back\" button.  By default,\nmenus do not have an exit back button.\n\nExit Back buttons appear as \"Back\" on page 1 of paginated menus and have\nfunctionality defined by the user in MenuEnd_ExitBack.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True if the menu has an exit back button; false otherwise."
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      }
    ],
    "full_declaration": "native bool GetMenuExitBackButton(Handle menu);"
  },
  {
    "name": "SetMenuExitBackButton",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "void",
    "comment": "Sets whether or not the menu has an \"exit back\" button. By default, menus\ndo not have an exit back button.\n\nExit Back buttons appear as \"Back\" on page 1 of paginated menus and have\nfunctionality defined by the user in MenuEnd_ExitBack.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        },
        {
          "name": "button",
          "description": "True to enable the button, false to remove it."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      },
      {
        "name": "button",
        "type": "bool",
        "default": null,
        "description": "True to enable the button, false to remove it."
      }
    ],
    "full_declaration": "native void SetMenuExitBackButton(Handle menu, bool button);"
  },
  {
    "name": "SetMenuNoVoteButton",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "bool",
    "comment": "Sets whether or not the menu has a \"no vote\" button in slot 1.\nBy default, menus do not have a no vote button.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        },
        {
          "name": "button",
          "description": "True to enable the button, false to remove it."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True if allowed; false on failure."
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      },
      {
        "name": "button",
        "type": "bool",
        "default": null,
        "description": "True to enable the button, false to remove it."
      }
    ],
    "full_declaration": "native bool SetMenuNoVoteButton(Handle menu, bool button);"
  },
  {
    "name": "CancelMenu",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "void",
    "comment": "Cancels a menu from displaying on all clients.  While the\ncancellation is in progress, this menu cannot be re-displayed\nto any clients.\n\nThe menu may still exist on the client's screen after this command.\nThis simply verifies that the menu is not being used anywhere.\n\nIf any vote is in progress on a menu, it will be cancelled.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      }
    ],
    "full_declaration": "native void CancelMenu(Handle menu);"
  },
  {
    "name": "GetMenuOptionFlags",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "int",
    "comment": "Retrieves a menu's option flags.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "A bitstring of MENUFLAG bits."
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      }
    ],
    "full_declaration": "native int GetMenuOptionFlags(Handle menu);"
  },
  {
    "name": "SetMenuOptionFlags",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "void",
    "comment": "Sets a menu's option flags.\n\nIf a certain bit is not supported, it will be stripped before being set.\nSee SetMenuExitButton() for information on Exit buttons.\nSee SetMenuExitBackButton() for information on Exit Back buttons.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        },
        {
          "name": "flags",
          "description": "A new bitstring of MENUFLAG bits."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "A new bitstring of MENUFLAG bits."
      }
    ],
    "full_declaration": "native void SetMenuOptionFlags(Handle menu, int flags);"
  },
  {
    "name": "IsVoteInProgress",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "bool",
    "comment": "Returns whether a vote is in progress.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Deprecated; no longer used."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if a vote is in progress, false otherwise."
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": "",
        "description": "Deprecated; no longer used."
      }
    ],
    "full_declaration": "native bool IsVoteInProgress(Handle menu=INVALID_HANDLE);"
  },
  {
    "name": "CancelVote",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "void",
    "comment": "Cancels the vote in progress.",
    "tags": {
      "param": [],
      "error": [
        "If no vote is in progress."
      ],
      "note": [],
      "return": ""
    },
    "params": [],
    "full_declaration": "native void CancelVote();"
  },
  {
    "name": "VoteMenu",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "bool",
    "comment": "Broadcasts a menu to a list of clients.  The most selected item will be\nreturned through MenuAction_End.  On a tie, a random item will be returned\nfrom a list of the tied items.\n\nNote that MenuAction_VoteEnd and MenuAction_VoteStart are both\ndefault callbacks and do not need to be enabled.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        },
        {
          "name": "clients",
          "description": "Array of clients to broadcast to."
        },
        {
          "name": "numClients",
          "description": "Number of clients in the array."
        },
        {
          "name": "time",
          "description": "Maximum time to leave menu on the screen."
        },
        {
          "name": "flags",
          "description": "Optional voting flags."
        }
      ],
      "error": [
        "Invalid Handle, or a vote is already in progress."
      ],
      "note": [],
      "return": "True on success, false if this menu already has a vote session in progress."
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      },
      {
        "name": "clients",
        "type": "int[]",
        "default": null,
        "description": "Array of clients to broadcast to."
      },
      {
        "name": "numClients",
        "type": "int",
        "default": null,
        "description": "Number of clients in the array."
      },
      {
        "name": "time",
        "type": "int",
        "default": null,
        "description": "Maximum time to leave menu on the screen."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Optional voting flags."
      }
    ],
    "full_declaration": "native bool VoteMenu(Handle menu, int[] clients, int numClients, int time, int flags=0);"
  },
  {
    "name": "VoteMenuToAll",
    "type": "stock",
    "source_file": "menus.inc",
    "return_type": "bool",
    "comment": "Sends a vote menu to all clients.  See VoteMenu() for more information.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        },
        {
          "name": "time",
          "description": "Maximum time to leave menu on the screen."
        },
        {
          "name": "flags",
          "description": "Optional voting flags."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false if this menu already has a vote session in progress."
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      },
      {
        "name": "time",
        "type": "int",
        "default": null,
        "description": "Maximum time to leave menu on the screen."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Optional voting flags."
      }
    ],
    "full_declaration": "stock bool VoteMenuToAll(Handle menu, int time, int flags=0) { \tint total; \tint[] players = new int[MaxClients];  \tfor (int i=1; i<=MaxClients; i++) \t{ \t\tif (!IsClientInGame(i) || IsFakeClient(i)) \t\t{ \t\t\tcontinue; \t\t} \t\tplayers[total++] = i; \t}  \treturn VoteMenu(menu, players, total, time, flags);"
  },
  {
    "name": "SetVoteResultCallback",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "void",
    "comment": "Sets an advanced vote handling callback.  If this callback is set,\nMenuAction_VoteEnd will not be called.",
    "tags": {
      "param": [
        {
          "name": "menu",
          "description": "Menu Handle."
        },
        {
          "name": "callback",
          "description": "Callback function."
        }
      ],
      "error": [
        "Invalid Handle or callback."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "menu",
        "type": "Handle",
        "default": null,
        "description": "Menu Handle."
      },
      {
        "name": "callback",
        "type": "VoteHandler",
        "default": null,
        "description": "Callback function."
      }
    ],
    "full_declaration": "native void SetVoteResultCallback(Handle menu, VoteHandler callback);"
  },
  {
    "name": "CheckVoteDelay",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "int",
    "comment": "Returns the number of seconds you should \"wait\" before displaying\na publicly invocable menu.  This number is the time remaining until\n(last_vote + sm_vote_delay).",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "Number of seconds to wait, or 0 for none."
    },
    "params": [],
    "full_declaration": "native int CheckVoteDelay();"
  },
  {
    "name": "IsClientInVotePool",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "bool",
    "comment": "Returns whether a client is in the pool of clients allowed\nto participate in the current vote.  This is determined by\nthe client list passed to VoteMenu().",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        }
      ],
      "error": [
        "If no vote is in progress or client index is invalid."
      ],
      "note": [],
      "return": "True if client is allowed to vote, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      }
    ],
    "full_declaration": "native bool IsClientInVotePool(int client);"
  },
  {
    "name": "RedrawClientVoteMenu",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "bool",
    "comment": "Redraws the current vote menu to a client in the voting pool.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "revotes",
          "description": "True to allow revotes, false otherwise."
        }
      ],
      "error": [
        "No vote in progress, int client is not in the voting pool, or client index is invalid."
      ],
      "note": [],
      "return": "True on success, false if the client is in the vote pool but cannot vote again."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "revotes",
        "type": "bool",
        "default": "",
        "description": "True to allow revotes, false otherwise."
      }
    ],
    "full_declaration": "native bool RedrawClientVoteMenu(int client, bool revotes=true);"
  },
  {
    "name": "GetMenuStyleHandle",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "Handle",
    "comment": "Returns a style's global Handle.",
    "tags": {
      "param": [
        {
          "name": "style",
          "description": "Menu Style."
        }
      ],
      "error": [],
      "note": [],
      "return": "A Handle, or INVALID_HANDLE if not found or unusable."
    },
    "params": [
      {
        "name": "style",
        "type": "MenuStyle",
        "default": null,
        "description": "Menu Style."
      }
    ],
    "full_declaration": "native Handle GetMenuStyleHandle(MenuStyle style);"
  },
  {
    "name": "CreatePanel",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "Panel",
    "comment": "Creates a MenuPanel from a MenuStyle.  Panels are used for drawing raw\nmenus without any extra helper functions.  The Handle must be closed\nwith CloseHandle().",
    "tags": {
      "param": [
        {
          "name": "hStyle",
          "description": "MenuStyle Handle, or INVALID_HANDLE to use the default style."
        }
      ],
      "error": [
        "Invalid Handle other than INVALID_HANDLE."
      ],
      "note": [],
      "return": "A new MenuPanel Handle."
    },
    "params": [
      {
        "name": "hStyle",
        "type": "Handle",
        "default": "",
        "description": "MenuStyle Handle, or INVALID_HANDLE to use the default style."
      }
    ],
    "full_declaration": "native Panel CreatePanel(Handle hStyle=INVALID_HANDLE);"
  },
  {
    "name": "CreateMenuEx",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "Menu",
    "comment": "Creates a Menu from a MenuStyle.  The Handle must be closed with\nCloseHandle().",
    "tags": {
      "param": [
        {
          "name": "hStyle",
          "description": "MenuStyle Handle, or INVALID_HANDLE to use the default style."
        },
        {
          "name": "handler",
          "description": "Function which will receive menu actions."
        },
        {
          "name": "actions",
          "description": "Optionally set which actions to receive.  Select, Cancel, and End will always be received regardless of whether they are set or not.  They are also the only default actions."
        }
      ],
      "error": [
        "Invalid Handle other than INVALID_HANDLE."
      ],
      "note": [],
      "return": "A new menu Handle."
    },
    "params": [
      {
        "name": "hStyle",
        "type": "Handle",
        "default": "",
        "description": "MenuStyle Handle, or INVALID_HANDLE to use the default style."
      },
      {
        "name": "handler",
        "type": "MenuHandler",
        "default": null,
        "description": "Function which will receive menu actions."
      },
      {
        "name": "actions",
        "type": "MenuAction",
        "default": "",
        "description": "Optionally set which actions to receive.  Select, Cancel, and End will always be received regardless of whether they are set or not.  They are also the only default actions."
      }
    ],
    "full_declaration": "native Menu CreateMenuEx(Handle hStyle=INVALID_HANDLE, MenuHandler handler, MenuAction actions=MENU_ACTIONS_DEFAULT);"
  },
  {
    "name": "GetClientMenu",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "MenuSource",
    "comment": "Returns whether a client is viewing a menu.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "hStyle",
          "description": "MenuStyle Handle, or INVALID_HANDLE to use the default style."
        }
      ],
      "error": [
        "Invalid Handle other than null."
      ],
      "note": [],
      "return": "A MenuSource value."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "hStyle",
        "type": "Handle",
        "default": "",
        "description": "MenuStyle Handle, or INVALID_HANDLE to use the default style."
      }
    ],
    "full_declaration": "native MenuSource GetClientMenu(int client, Handle hStyle=null);"
  },
  {
    "name": "CancelClientMenu",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "bool",
    "comment": "Cancels a menu on a client.  This will only affect non-external menus.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "autoIgnore",
          "description": "If true, no menus can be re-drawn on the client during the cancellation process."
        },
        {
          "name": "hStyle",
          "description": "MenuStyle Handle, or INVALID_HANDLE to use the default style."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if a menu was cancelled, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "autoIgnore",
        "type": "bool",
        "default": "",
        "description": "If true, no menus can be re-drawn on the client during the cancellation process."
      },
      {
        "name": "hStyle",
        "type": "Handle",
        "default": "",
        "description": "MenuStyle Handle, or INVALID_HANDLE to use the default style."
      }
    ],
    "full_declaration": "native bool CancelClientMenu(int client, bool autoIgnore=false, Handle hStyle=INVALID_HANDLE);"
  },
  {
    "name": "GetMaxPageItems",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "int",
    "comment": "Returns a style's maximum items per page.",
    "tags": {
      "param": [
        {
          "name": "hStyle",
          "description": "MenuStyle Handle, or INVALID_HANDLE to use the default style."
        }
      ],
      "error": [
        "Invalid Handle other than INVALID_HANDLE."
      ],
      "note": [],
      "return": "Maximum items per page."
    },
    "params": [
      {
        "name": "hStyle",
        "type": "Handle",
        "default": "",
        "description": "MenuStyle Handle, or INVALID_HANDLE to use the default style."
      }
    ],
    "full_declaration": "native int GetMaxPageItems(Handle hStyle=INVALID_HANDLE);"
  },
  {
    "name": "GetPanelStyle",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "Handle",
    "comment": "Returns a MenuPanel's parent style.",
    "tags": {
      "param": [
        {
          "name": "panel",
          "description": "A MenuPanel Handle."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "The MenuStyle Handle that created the panel."
    },
    "params": [
      {
        "name": "panel",
        "type": "Handle",
        "default": null,
        "description": "A MenuPanel Handle."
      }
    ],
    "full_declaration": "native Handle GetPanelStyle(Handle panel);"
  },
  {
    "name": "SetPanelTitle",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "void",
    "comment": "Sets the panel's title.",
    "tags": {
      "param": [
        {
          "name": "panel",
          "description": "A MenuPanel Handle."
        },
        {
          "name": "text",
          "description": "Text to set as the title."
        },
        {
          "name": "onlyIfEmpty",
          "description": "If true, the title will only be set if no title is set."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "panel",
        "type": "Handle",
        "default": null,
        "description": "A MenuPanel Handle."
      },
      {
        "name": "text",
        "type": "char[]",
        "default": null,
        "description": "Text to set as the title."
      },
      {
        "name": "onlyIfEmpty",
        "type": "bool",
        "default": "",
        "description": "If true, the title will only be set if no title is set."
      }
    ],
    "full_declaration": "native void SetPanelTitle(Handle panel, const char[] text, bool onlyIfEmpty=false);"
  },
  {
    "name": "DrawPanelItem",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "int",
    "comment": "Draws an item on a panel.  If the item takes up a slot, the position\nis returned.",
    "tags": {
      "param": [
        {
          "name": "panel",
          "description": "A MenuPanel Handle."
        },
        {
          "name": "text",
          "description": "Display text to use.  If not a raw line, the style may automatically add color markup. No numbering or newlines are needed."
        },
        {
          "name": "style",
          "description": "ITEMDRAW style flags."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "A slot position, or 0 if item was a rawline or could not be drawn."
    },
    "params": [
      {
        "name": "panel",
        "type": "Handle",
        "default": null,
        "description": "A MenuPanel Handle."
      },
      {
        "name": "text",
        "type": "char[]",
        "default": null,
        "description": "Display text to use.  If not a raw line, the style may automatically add color markup. No numbering or newlines are needed."
      },
      {
        "name": "style",
        "type": "int",
        "default": "",
        "description": "ITEMDRAW style flags."
      }
    ],
    "full_declaration": "native int DrawPanelItem(Handle panel, const char[] text, int style=ITEMDRAW_DEFAULT);"
  },
  {
    "name": "DrawPanelText",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "bool",
    "comment": "Draws a raw line of text on a panel, without any markup other than a newline.",
    "tags": {
      "param": [
        {
          "name": "panel",
          "description": "A MenuPanel Handle, or INVALID_HANDLE if inside a MenuAction_DisplayItem callback."
        },
        {
          "name": "text",
          "description": "Display text to use."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false if raw lines are not supported."
    },
    "params": [
      {
        "name": "panel",
        "type": "Handle",
        "default": null,
        "description": "A MenuPanel Handle, or INVALID_HANDLE if inside a MenuAction_DisplayItem callback."
      },
      {
        "name": "text",
        "type": "char[]",
        "default": null,
        "description": "Display text to use."
      }
    ],
    "full_declaration": "native bool DrawPanelText(Handle panel, const char[] text);"
  },
  {
    "name": "CanPanelDrawFlags",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "bool",
    "comment": "Returns whether or not the given drawing flags are supported by\nthe menu style.",
    "tags": {
      "param": [
        {
          "name": "panel",
          "description": "A MenuPanel Handle."
        },
        {
          "name": "style",
          "description": "ITEMDRAW style flags."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True if item is drawable, false otherwise."
    },
    "params": [
      {
        "name": "panel",
        "type": "Handle",
        "default": null,
        "description": "A MenuPanel Handle."
      },
      {
        "name": "style",
        "type": "int",
        "default": null,
        "description": "ITEMDRAW style flags."
      }
    ],
    "full_declaration": "native bool CanPanelDrawFlags(Handle panel, int style);"
  },
  {
    "name": "SetPanelKeys",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "bool",
    "comment": "Sets the selectable key map of a panel.  This is not supported by\nall styles (only by Radio, as of this writing).",
    "tags": {
      "param": [
        {
          "name": "panel",
          "description": "A MenuPanel Handle."
        },
        {
          "name": "keys",
          "description": "An integer where each bit N allows key N+1 to be selected.  If no keys are selectable, then key 0 (bit 9) is automatically set."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if supported, false otherwise."
    },
    "params": [
      {
        "name": "panel",
        "type": "Handle",
        "default": null,
        "description": "A MenuPanel Handle."
      },
      {
        "name": "keys",
        "type": "int",
        "default": null,
        "description": "An integer where each bit N allows key N+1 to be selected.  If no keys are selectable, then key 0 (bit 9) is automatically set."
      }
    ],
    "full_declaration": "native bool SetPanelKeys(Handle panel, int keys);"
  },
  {
    "name": "SendPanelToClient",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "bool",
    "comment": "Sends a panel to a client.  Unlike full menus, the handler\nfunction will only receive the following actions, both of\nwhich will have INVALID_HANDLE for a menu, and the client\nas param1.\n\nMenuAction_Select (param2 will be the key pressed)\nMenuAction_Cancel (param2 will be the reason)\n\nAlso, if the menu fails to display, no callbacks will be called.",
    "tags": {
      "param": [
        {
          "name": "panel",
          "description": "A MenuPanel Handle."
        },
        {
          "name": "client",
          "description": "A client to draw to."
        },
        {
          "name": "handler",
          "description": "The MenuHandler function to catch actions with."
        },
        {
          "name": "time",
          "description": "Time to hold the menu for."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false on failure."
    },
    "params": [
      {
        "name": "panel",
        "type": "Handle",
        "default": null,
        "description": "A MenuPanel Handle."
      },
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "A client to draw to."
      },
      {
        "name": "handler",
        "type": "MenuHandler",
        "default": null,
        "description": "The MenuHandler function to catch actions with."
      },
      {
        "name": "time",
        "type": "int",
        "default": null,
        "description": "Time to hold the menu for."
      }
    ],
    "full_declaration": "native bool SendPanelToClient(Handle panel, int client, MenuHandler handler, int time);"
  },
  {
    "name": "GetPanelTextRemaining",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "int",
    "comment": "@brief Returns the amount of text the menu can still hold.  If this is\nlimit is reached or overflowed, the text is silently truncated.\n\nRadio menus: Currently 511 characters (512 bytes).\nValve menus: Currently -1 (no meaning).",
    "tags": {
      "param": [
        {
          "name": "panel",
          "description": "A MenuPanel Handle."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Number of characters that the menu can still hold, or -1 if there is no known limit."
    },
    "params": [
      {
        "name": "panel",
        "type": "Handle",
        "default": null,
        "description": "A MenuPanel Handle."
      }
    ],
    "full_declaration": "native int GetPanelTextRemaining(Handle panel);"
  },
  {
    "name": "GetPanelCurrentKey",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "int",
    "comment": "@brief Returns the current key position.",
    "tags": {
      "param": [
        {
          "name": "panel",
          "description": "A MenuPanel Handle."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Current key position starting at 1."
    },
    "params": [
      {
        "name": "panel",
        "type": "Handle",
        "default": null,
        "description": "A MenuPanel Handle."
      }
    ],
    "full_declaration": "native int GetPanelCurrentKey(Handle panel);"
  },
  {
    "name": "SetPanelCurrentKey",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "bool",
    "comment": "@brief Sets the next key position.  This cannot be used\nto traverse backwards.",
    "tags": {
      "param": [
        {
          "name": "panel",
          "description": "A MenuPanel Handle."
        },
        {
          "name": "key",
          "description": "Key that is greater or equal to GetPanelCurrentKey()."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "panel",
        "type": "Handle",
        "default": null,
        "description": "A MenuPanel Handle."
      },
      {
        "name": "key",
        "type": "int",
        "default": null,
        "description": "Key that is greater or equal to GetPanelCurrentKey()."
      }
    ],
    "full_declaration": "native bool SetPanelCurrentKey(Handle panel, int key);"
  },
  {
    "name": "RedrawMenuItem",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "int",
    "comment": "@brief Redraws menu text from inside a MenuAction_DisplayItem callback.",
    "tags": {
      "param": [
        {
          "name": "text",
          "description": "Menu text to draw."
        }
      ],
      "error": [],
      "note": [],
      "return": "Item position; must be returned via the callback."
    },
    "params": [
      {
        "name": "text",
        "type": "char[]",
        "default": null,
        "description": "Menu text to draw."
      }
    ],
    "full_declaration": "native int RedrawMenuItem(const char[] text);"
  },
  {
    "name": "InternalShowMenu",
    "type": "native",
    "source_file": "menus.inc",
    "return_type": "bool",
    "comment": "This function is provided for legacy code only.  Some older plugins may use\nnetwork messages instead of the panel API.  This function wraps the panel\nAPI for eased portability into the SourceMod menu system.\n\nThis function is only usable with the Radio Menu style.  You do not need to\nsplit up your menu into multiple packets; SourceMod will break the string\nup internally.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "str",
          "description": "Full menu string as would be passed over the network."
        },
        {
          "name": "time",
          "description": "Time to hold the menu for."
        },
        {
          "name": "keys",
          "description": "Selectable key bitstring."
        },
        {
          "name": "handler",
          "description": "Optional handler function, with the same rules as SendPanelToClient()."
        }
      ],
      "error": [
        "Invalid client index, or radio menus not supported."
      ],
      "note": [],
      "return": "True on success, false on failure."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "str",
        "type": "char[]",
        "default": null,
        "description": "Full menu string as would be passed over the network."
      },
      {
        "name": "time",
        "type": "int",
        "default": null,
        "description": "Time to hold the menu for."
      },
      {
        "name": "keys",
        "type": "int",
        "default": "",
        "description": "Selectable key bitstring."
      },
      {
        "name": "handler",
        "type": "MenuHandler",
        "default": "",
        "description": "Optional handler function, with the same rules as SendPanelToClient()."
      }
    ],
    "full_declaration": "native bool InternalShowMenu(int client, const char[] str, int time, int keys=-1, MenuHandler handler=INVALID_FUNCTION);"
  },
  {
    "name": "SetNextMap",
    "type": "native",
    "source_file": "nextmap.inc",
    "return_type": "bool",
    "comment": "Sets SourceMod's internal nextmap.\nEquivalent to changing sm_nextmap but with an added validity check.",
    "tags": {
      "param": [
        {
          "name": "map",
          "description": "Next map to set."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if the nextmap was set, false if map was invalid."
    },
    "params": [
      {
        "name": "map",
        "type": "char[]",
        "default": null,
        "description": "Next map to set."
      }
    ],
    "full_declaration": "native bool SetNextMap(const char[] map);"
  },
  {
    "name": "GetNextMap",
    "type": "native",
    "source_file": "nextmap.inc",
    "return_type": "bool",
    "comment": "Returns SourceMod's internal nextmap.",
    "tags": {
      "param": [
        {
          "name": "map",
          "description": "Buffer to store the nextmap name."
        },
        {
          "name": "maxlen",
          "description": "Maximum length of the map buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if a Map was found and copied, false if no nextmap is set (map will be unchanged)."
    },
    "params": [
      {
        "name": "map",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the nextmap name."
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "Maximum length of the map buffer."
      }
    ],
    "full_declaration": "native bool GetNextMap(char[] map, int maxlen);"
  },
  {
    "name": "ForceChangeLevel",
    "type": "native",
    "source_file": "nextmap.inc",
    "return_type": "void",
    "comment": "Changes the current map and records the reason for the change with maphistory",
    "tags": {
      "param": [
        {
          "name": "map",
          "description": "Map to change to."
        },
        {
          "name": "reason",
          "description": "Reason for change."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "map",
        "type": "char[]",
        "default": null,
        "description": "Map to change to."
      },
      {
        "name": "reason",
        "type": "char[]",
        "default": null,
        "description": "Reason for change."
      }
    ],
    "full_declaration": "native void ForceChangeLevel(const char[] map, const char[] reason);"
  },
  {
    "name": "GetMapHistorySize",
    "type": "native",
    "source_file": "nextmap.inc",
    "return_type": "int",
    "comment": "Gets the current number of maps in the map history",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "Number of maps."
    },
    "params": [],
    "full_declaration": "native int GetMapHistorySize();"
  },
  {
    "name": "GetMapHistory",
    "type": "native",
    "source_file": "nextmap.inc",
    "return_type": "void",
    "comment": "Retrieves a map from the map history list.",
    "tags": {
      "param": [
        {
          "name": "item",
          "description": "Item number. Must be 0 or greater and less than GetMapHistorySize()."
        },
        {
          "name": "map",
          "description": "Buffer to store the map name."
        },
        {
          "name": "mapLen",
          "description": "Length of map buffer."
        },
        {
          "name": "reason",
          "description": "Buffer to store the change reason."
        },
        {
          "name": "reasonLen",
          "description": "Length of the reason buffer."
        },
        {
          "name": "startTime",
          "description": "Time the map started."
        }
      ],
      "error": [
        "Invalid item number."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "item",
        "type": "int",
        "default": null,
        "description": "Item number. Must be 0 or greater and less than GetMapHistorySize()."
      },
      {
        "name": "map",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the map name."
      },
      {
        "name": "mapLen",
        "type": "int",
        "default": null,
        "description": "Length of map buffer."
      },
      {
        "name": "reason",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the change reason."
      },
      {
        "name": "reasonLen",
        "type": "int",
        "default": null,
        "description": "Length of the reason buffer."
      },
      {
        "name": "startTime",
        "type": "int",
        "default": null,
        "description": "Time the map started."
      }
    ],
    "full_declaration": "native void GetMapHistory(int item, char[] map, int mapLen, char[] reason, int reasonLen, int &startTime);"
  },
  {
    "name": "Profiler",
    "type": "methodmap",
    "source_file": "profiler.inc",
    "inherits": "Handle",
    "comment": "ONLY AVAILABLE ON WINDOWS RIGHT NOW K.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "methods": [],
    "properties": [],
    "full_declaration": "methodmap Profiler < Handle"
  },
  {
    "name": "CreateProfiler",
    "type": "native",
    "source_file": "profiler.inc",
    "return_type": "Profiler",
    "comment": "Creates a new profile object.  The Handle must be freed\nusing delete or CloseHandle().",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "Handle to the profiler object."
    },
    "params": [],
    "full_declaration": "native Profiler CreateProfiler();"
  },
  {
    "name": "StartProfiling",
    "type": "native",
    "source_file": "profiler.inc",
    "return_type": "void",
    "comment": "Starts profiling.",
    "tags": {
      "param": [
        {
          "name": "prof",
          "description": "Profiling object."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "prof",
        "type": "Handle",
        "default": null,
        "description": "Profiling object."
      }
    ],
    "full_declaration": "native void StartProfiling(Handle prof);"
  },
  {
    "name": "StopProfiling",
    "type": "native",
    "source_file": "profiler.inc",
    "return_type": "void",
    "comment": "Stops profiling.",
    "tags": {
      "param": [
        {
          "name": "prof",
          "description": "Profiling object."
        }
      ],
      "error": [
        "Invalid Handle or profiling was never started."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "prof",
        "type": "Handle",
        "default": null,
        "description": "Profiling object."
      }
    ],
    "full_declaration": "native void StopProfiling(Handle prof);"
  },
  {
    "name": "GetProfilerTime",
    "type": "native",
    "source_file": "profiler.inc",
    "return_type": "float",
    "comment": "Returns the amount of high-precision time in seconds\nthat passed during the profiler's last start/stop\ncycle.",
    "tags": {
      "param": [
        {
          "name": "prof",
          "description": "Profiling object."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Time elapsed in seconds."
    },
    "params": [
      {
        "name": "prof",
        "type": "Handle",
        "default": null,
        "description": "Profiling object."
      }
    ],
    "full_declaration": "native float GetProfilerTime(Handle prof);"
  },
  {
    "name": "EnterProfilingEvent",
    "type": "native",
    "source_file": "profiler.inc",
    "return_type": "void",
    "comment": "Mark the start of a profiling event.",
    "tags": {
      "param": [
        {
          "name": "group",
          "description": "Budget group. This can be \"all\" for a default, or a short description like \"Timers\" or \"Events\"."
        },
        {
          "name": "name",
          "description": "A name to attribute to this profiling event."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "group",
        "type": "char[]",
        "default": null,
        "description": "Budget group. This can be \"all\" for a default, or a short description like \"Timers\" or \"Events\"."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "A name to attribute to this profiling event."
      }
    ],
    "full_declaration": "native void EnterProfilingEvent(const char[] group, const char[] name);"
  },
  {
    "name": "LeaveProfilingEvent",
    "type": "native",
    "source_file": "profiler.inc",
    "return_type": "void",
    "comment": "Mark the end of the last profiling event. This must be called in the same\nstack frame as StartProfilingEvent(). Not doing so, or throwing errors,\nwill make the resulting profile very wrong.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [],
    "full_declaration": "native void LeaveProfilingEvent();"
  },
  {
    "name": "IsProfilingActive",
    "type": "native",
    "source_file": "profiler.inc",
    "return_type": "bool",
    "comment": "Returns true if the global profiler is enabled; false otherwise. It is\nnot necessary to call this before Enter/LeaveProfilingEvent.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [],
    "full_declaration": "native bool IsProfilingActive();"
  },
  {
    "name": "PbReadInt",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "int",
    "comment": "Reads an int32, uint32, sint32, fixed32, sfixed32, or enum value from a protobuf message.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "index",
          "description": "Index into repeated field."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": "Integer value read."
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "index",
        "type": "int",
        "default": "",
        "description": "Index into repeated field."
      }
    ],
    "full_declaration": "native int PbReadInt(Handle pb, const char[] field, int index = PB_FIELD_NOT_REPEATED);"
  },
  {
    "name": "PbReadFloat",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "float",
    "comment": "Reads a float or downcasted double from a protobuf message.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "index",
          "description": "Index into repeated field."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": "Float value read."
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "index",
        "type": "int",
        "default": "",
        "description": "Index into repeated field."
      }
    ],
    "full_declaration": "native float PbReadFloat(Handle pb, const char[] field, int index = PB_FIELD_NOT_REPEATED);"
  },
  {
    "name": "PbReadBool",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "bool",
    "comment": "Reads a bool from a protobuf message.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "index",
          "description": "Index into repeated field."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": "Boolean value read."
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "index",
        "type": "int",
        "default": "",
        "description": "Index into repeated field."
      }
    ],
    "full_declaration": "native bool PbReadBool(Handle pb, const char[] field, int index = PB_FIELD_NOT_REPEATED);"
  },
  {
    "name": "PbReadString",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "void",
    "comment": "Reads a string from a protobuf message.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "buffer",
          "description": "Destination string buffer."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of output string buffer."
        },
        {
          "name": "index",
          "description": "Index into repeated field."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Destination string buffer."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of output string buffer."
      },
      {
        "name": "index",
        "type": "int",
        "default": "",
        "description": "Index into repeated field."
      }
    ],
    "full_declaration": "native void PbReadString(Handle pb, const char[] field, char[] buffer, int maxlength, int index = PB_FIELD_NOT_REPEATED);"
  },
  {
    "name": "PbReadColor",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "void",
    "comment": "Reads an RGBA color value from a protobuf message.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "buffer",
          "description": "Destination color buffer."
        },
        {
          "name": "index",
          "description": "Index into repeated field."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "buffer",
        "type": "int",
        "default": null,
        "description": "Destination color buffer."
      },
      {
        "name": "index",
        "type": "int",
        "default": "",
        "description": "Index into repeated field."
      }
    ],
    "full_declaration": "native void PbReadColor(Handle pb, const char[] field, int buffer[4], int index = PB_FIELD_NOT_REPEATED);"
  },
  {
    "name": "PbReadAngle",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "void",
    "comment": "Reads an XYZ angle value from a protobuf message.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "buffer",
          "description": "Destination angle buffer."
        },
        {
          "name": "index",
          "description": "Index into repeated field."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "buffer",
        "type": "float",
        "default": null,
        "description": "Destination angle buffer."
      },
      {
        "name": "index",
        "type": "int",
        "default": "",
        "description": "Index into repeated field."
      }
    ],
    "full_declaration": "native void PbReadAngle(Handle pb, const char[] field, float buffer[3], int index = PB_FIELD_NOT_REPEATED);"
  },
  {
    "name": "PbReadVector",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "void",
    "comment": "Reads an XYZ vector value from a protobuf message.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "buffer",
          "description": "Destination vector buffer."
        },
        {
          "name": "index",
          "description": "Index into repeated field."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "buffer",
        "type": "float",
        "default": null,
        "description": "Destination vector buffer."
      },
      {
        "name": "index",
        "type": "int",
        "default": "",
        "description": "Index into repeated field."
      }
    ],
    "full_declaration": "native void PbReadVector(Handle pb, const char[] field, float buffer[3], int index = PB_FIELD_NOT_REPEATED);"
  },
  {
    "name": "PbReadVector2D",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "void",
    "comment": "Reads an XY vector value from a protobuf message.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "buffer",
          "description": "Destination vector buffer."
        },
        {
          "name": "index",
          "description": "Index into repeated field."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "buffer",
        "type": "float",
        "default": null,
        "description": "Destination vector buffer."
      },
      {
        "name": "index",
        "type": "int",
        "default": "",
        "description": "Index into repeated field."
      }
    ],
    "full_declaration": "native void PbReadVector2D(Handle pb, const char[] field, float buffer[2], int index = PB_FIELD_NOT_REPEATED);"
  },
  {
    "name": "PbGetRepeatedFieldCount",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "int",
    "comment": "Gets the number of elements in a repeated field of a protobuf message.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": "Number of elements in the field."
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      }
    ],
    "full_declaration": "native int PbGetRepeatedFieldCount(Handle pb, const char[] field);"
  },
  {
    "name": "PbSetInt",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "void",
    "comment": "Sets an int32, uint32, sint32, fixed32, sfixed32, or enum value on a protobuf message.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "value",
          "description": "Integer value to set."
        },
        {
          "name": "index",
          "description": "Index into repeated field."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "value",
        "type": "int",
        "default": null,
        "description": "Integer value to set."
      },
      {
        "name": "index",
        "type": "int",
        "default": "",
        "description": "Index into repeated field."
      }
    ],
    "full_declaration": "native void PbSetInt(Handle pb, const char[] field, int value, int index = PB_FIELD_NOT_REPEATED);"
  },
  {
    "name": "PbSetFloat",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "void",
    "comment": "Sets a float or double on a protobuf message.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "value",
          "description": "Float value to set."
        },
        {
          "name": "index",
          "description": "Index into repeated field."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Float value to set."
      },
      {
        "name": "index",
        "type": "int",
        "default": "",
        "description": "Index into repeated field."
      }
    ],
    "full_declaration": "native void PbSetFloat(Handle pb, const char[] field, float value, int index = PB_FIELD_NOT_REPEATED);"
  },
  {
    "name": "PbSetBool",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "void",
    "comment": "Sets a bool on a protobuf message.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "value",
          "description": "Boolean value to set."
        },
        {
          "name": "index",
          "description": "Index into repeated field."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "value",
        "type": "bool",
        "default": null,
        "description": "Boolean value to set."
      },
      {
        "name": "index",
        "type": "int",
        "default": "",
        "description": "Index into repeated field."
      }
    ],
    "full_declaration": "native void PbSetBool(Handle pb, const char[] field, bool value, int index = PB_FIELD_NOT_REPEATED);"
  },
  {
    "name": "PbSetString",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "void",
    "comment": "Sets a string on a protobuf message.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "value",
          "description": "String value to set."
        },
        {
          "name": "index",
          "description": "Index into repeated field."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "String value to set."
      },
      {
        "name": "index",
        "type": "int",
        "default": "",
        "description": "Index into repeated field."
      }
    ],
    "full_declaration": "native void PbSetString(Handle pb, const char[] field, const char[] value, int index = PB_FIELD_NOT_REPEATED);"
  },
  {
    "name": "PbSetColor",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "void",
    "comment": "Sets an RGBA color on a protobuf message.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "color",
          "description": "Color value to set."
        },
        {
          "name": "index",
          "description": "Index into repeated field."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "color",
        "type": "int",
        "default": null,
        "description": "Color value to set."
      },
      {
        "name": "index",
        "type": "int",
        "default": "",
        "description": "Index into repeated field."
      }
    ],
    "full_declaration": "native void PbSetColor(Handle pb, const char[] field, const int color[4], int index = PB_FIELD_NOT_REPEATED);"
  },
  {
    "name": "PbSetAngle",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "void",
    "comment": "Sets an XYZ angle on a protobuf message.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "angle",
          "description": "Angle value to set."
        },
        {
          "name": "index",
          "description": "Index into repeated field."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "angle",
        "type": "float",
        "default": null,
        "description": "Angle value to set."
      },
      {
        "name": "index",
        "type": "int",
        "default": "",
        "description": "Index into repeated field."
      }
    ],
    "full_declaration": "native void PbSetAngle(Handle pb, const char[] field, const float angle[3], int index = PB_FIELD_NOT_REPEATED);"
  },
  {
    "name": "PbSetVector",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "void",
    "comment": "Sets an XYZ vector on a protobuf message.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "vec",
          "description": "Vector value to set."
        },
        {
          "name": "index",
          "description": "Index into repeated field."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Vector value to set."
      },
      {
        "name": "index",
        "type": "int",
        "default": "",
        "description": "Index into repeated field."
      }
    ],
    "full_declaration": "native void PbSetVector(Handle pb, const char[] field, const float vec[3], int index = PB_FIELD_NOT_REPEATED);"
  },
  {
    "name": "PbSetVector2D",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "void",
    "comment": "Sets an XY vector on a protobuf message.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "vec",
          "description": "Vector value to set."
        },
        {
          "name": "index",
          "description": "Index into repeated field."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Vector value to set."
      },
      {
        "name": "index",
        "type": "int",
        "default": "",
        "description": "Index into repeated field."
      }
    ],
    "full_declaration": "native void PbSetVector2D(Handle pb, const char[] field, const float vec[2], int index = PB_FIELD_NOT_REPEATED);"
  },
  {
    "name": "PbAddInt",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "void",
    "comment": "Add an int32, uint32, sint32, fixed32, sfixed32, or enum value to a protobuf message repeated field.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "value",
          "description": "Integer value to add."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "value",
        "type": "int",
        "default": null,
        "description": "Integer value to add."
      }
    ],
    "full_declaration": "native void PbAddInt(Handle pb, const char[] field, int value);"
  },
  {
    "name": "PbAddFloat",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "void",
    "comment": "Add a float or double to a protobuf message repeated field.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "value",
          "description": "Float value to add."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Float value to add."
      }
    ],
    "full_declaration": "native void PbAddFloat(Handle pb, const char[] field, float value);"
  },
  {
    "name": "PbAddBool",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "void",
    "comment": "Add a bool to a protobuf message repeated field.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "value",
          "description": "Boolean value to add."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "value",
        "type": "bool",
        "default": null,
        "description": "Boolean value to add."
      }
    ],
    "full_declaration": "native void PbAddBool(Handle pb, const char[] field, bool value);"
  },
  {
    "name": "PbAddString",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "void",
    "comment": "Add a string to a protobuf message repeated field.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "value",
          "description": "String value to add."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "String value to add."
      }
    ],
    "full_declaration": "native void PbAddString(Handle pb, const char[] field, const char[] value);"
  },
  {
    "name": "PbAddColor",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "void",
    "comment": "Add an RGBA color to a protobuf message repeated field.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "color",
          "description": "Color value to add."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "color",
        "type": "int",
        "default": null,
        "description": "Color value to add."
      }
    ],
    "full_declaration": "native void PbAddColor(Handle pb, const char[] field, const int color[4]);"
  },
  {
    "name": "PbAddAngle",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "void",
    "comment": "Add an XYZ angle to a protobuf message repeated field.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "angle",
          "description": "Angle value to add."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "angle",
        "type": "float",
        "default": null,
        "description": "Angle value to add."
      }
    ],
    "full_declaration": "native void PbAddAngle(Handle pb, const char[] field, const float angle[3]);"
  },
  {
    "name": "PbAddVector",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "void",
    "comment": "Add an XYZ vector to a protobuf message repeated field.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "vec",
          "description": "Vector value to add."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Vector value to add."
      }
    ],
    "full_declaration": "native void PbAddVector(Handle pb, const char[] field, const float vec[3]);"
  },
  {
    "name": "PbAddVector2D",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "void",
    "comment": "Add an XY vector to a protobuf message repeated field.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "vec",
          "description": "Vector value to add."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Vector value to add."
      }
    ],
    "full_declaration": "native void PbAddVector2D(Handle pb, const char[] field, const float vec[2]);"
  },
  {
    "name": "PbRemoveRepeatedFieldValue",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "void",
    "comment": "Removes a value by index from a protobuf message repeated field.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "index",
          "description": "Index into repeated field."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "index",
        "type": "int",
        "default": null,
        "description": "Index into repeated field."
      }
    ],
    "full_declaration": "native void PbRemoveRepeatedFieldValue(Handle pb, const char[] field, int index);"
  },
  {
    "name": "PbReadMessage",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "Handle",
    "comment": "Retrieve a handle to an embedded protobuf message in a protobuf message.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": "protobuf handle to embedded message."
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      }
    ],
    "full_declaration": "native Handle PbReadMessage(Handle pb, const char[] field);"
  },
  {
    "name": "PbReadRepeatedMessage",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "Handle",
    "comment": "Retrieve a handle to an embedded protobuf message in a protobuf message repeated field.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        },
        {
          "name": "index",
          "description": "Index in the repeated field."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": "protobuf handle to embedded message."
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      },
      {
        "name": "index",
        "type": "int",
        "default": null,
        "description": "Index in the repeated field."
      }
    ],
    "full_declaration": "native Handle PbReadRepeatedMessage(Handle pb, const char[] field, int index);"
  },
  {
    "name": "PbAddMessage",
    "type": "native",
    "source_file": "protobuf.inc",
    "return_type": "Handle",
    "comment": "Adds an embedded protobuf message to a protobuf message repeated field.",
    "tags": {
      "param": [
        {
          "name": "pb",
          "description": "protobuf handle."
        },
        {
          "name": "field",
          "description": "Field name."
        }
      ],
      "error": [
        "Invalid or incorrect Handle, non-existent field, or incorrect field type."
      ],
      "note": [],
      "return": "protobuf handle to added, embedded message."
    },
    "params": [
      {
        "name": "pb",
        "type": "Handle",
        "default": null,
        "description": "protobuf handle."
      },
      {
        "name": "field",
        "type": "char[]",
        "default": null,
        "description": "Field name."
      }
    ],
    "full_declaration": "native Handle PbAddMessage(Handle pb, const char[] field);"
  },
  {
    "name": "CompileRegex",
    "type": "native",
    "source_file": "regex.inc",
    "return_type": "Regex",
    "comment": "Precompile a regular expression.  Use this if you intend on using the\nsame expression multiple times.  Pass the regex handle returned here to\nMatchRegex to check for matches.",
    "tags": {
      "param": [
        {
          "name": "pattern",
          "description": "The regular expression pattern."
        },
        {
          "name": "flags",
          "description": "General flags for the regular expression."
        },
        {
          "name": "error",
          "description": "Error message encountered, if applicable."
        },
        {
          "name": "maxLen",
          "description": "Maximum string length of the error buffer."
        },
        {
          "name": "errcode",
          "description": "Regex type error code encountered, if applicable."
        }
      ],
      "error": [],
      "note": [],
      "return": "Valid regex handle on success, INVALID_HANDLE on failure."
    },
    "params": [
      {
        "name": "pattern",
        "type": "char[]",
        "default": null,
        "description": "The regular expression pattern."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "General flags for the regular expression."
      },
      {
        "name": "error",
        "type": "char[]",
        "default": "",
        "description": "Error message encountered, if applicable."
      },
      {
        "name": "maxLen",
        "type": "int",
        "default": "",
        "description": "Maximum string length of the error buffer."
      },
      {
        "name": "errcode",
        "type": "RegexError",
        "default": "",
        "description": "Regex type error code encountered, if applicable."
      }
    ],
    "full_declaration": "native Regex CompileRegex(const char[] pattern, int flags = 0, char[] error=\"\", int maxLen = 0, RegexError &errcode = REGEX_ERROR_NONE);"
  },
  {
    "name": "MatchRegex",
    "type": "native",
    "source_file": "regex.inc",
    "return_type": "int",
    "comment": "Matches a string against a pre-compiled regular expression pattern.",
    "tags": {
      "param": [
        {
          "name": "regex",
          "description": "Regex Handle from CompileRegex()"
        },
        {
          "name": "str",
          "description": "The string to check."
        },
        {
          "name": "ret",
          "description": "Error code, if applicable."
        },
        {
          "name": "offset",
          "description": "Offset in the string to start searching from."
        }
      ],
      "error": [],
      "note": [
        "Use the regex handle passed to this function to extract matches with GetRegexSubString()."
      ],
      "return": "Number of captures found or -1 on failure."
    },
    "params": [
      {
        "name": "regex",
        "type": "Handle",
        "default": null,
        "description": "Regex Handle from CompileRegex()"
      },
      {
        "name": "str",
        "type": "char[]",
        "default": null,
        "description": "The string to check."
      },
      {
        "name": "ret",
        "type": "RegexError",
        "default": "",
        "description": "Error code, if applicable."
      },
      {
        "name": "offset",
        "type": "int",
        "default": "",
        "description": "Offset in the string to start searching from."
      }
    ],
    "full_declaration": "native int MatchRegex(Handle regex, const char[] str, RegexError &ret = REGEX_ERROR_NONE, int offset = 0);"
  },
  {
    "name": "GetRegexSubString",
    "type": "native",
    "source_file": "regex.inc",
    "return_type": "bool",
    "comment": "Returns a matched substring from a regex handle.\nSubstring ids start at 0 and end at captures-1, where captures is the number returned\nby MatchRegex.",
    "tags": {
      "param": [
        {
          "name": "regex",
          "description": "The regex handle to extract data from."
        },
        {
          "name": "str_id",
          "description": "The index of the expression to get - starts at 0, and ends at captures - 1."
        },
        {
          "name": "buffer",
          "description": "The buffer to set to the matching substring."
        },
        {
          "name": "maxlen",
          "description": "The maximum string length of the buffer."
        }
      ],
      "error": [],
      "note": [
        "str_id = 0 is the full captured string, anything else is the capture group index."
      ],
      "return": "True if a substring was found, False on fail/error"
    },
    "params": [
      {
        "name": "regex",
        "type": "Handle",
        "default": null,
        "description": "The regex handle to extract data from."
      },
      {
        "name": "str_id",
        "type": "int",
        "default": null,
        "description": "The index of the expression to get - starts at 0, and ends at captures - 1."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "The buffer to set to the matching substring."
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "The maximum string length of the buffer."
      }
    ],
    "full_declaration": "native bool GetRegexSubString(Handle regex, int str_id, char[] buffer, int maxlen);"
  },
  {
    "name": "SimpleRegexMatch",
    "type": "stock",
    "source_file": "regex.inc",
    "return_type": "int",
    "comment": "Matches a string against a regular expression pattern.",
    "tags": {
      "param": [
        {
          "name": "str",
          "description": "The string to check."
        },
        {
          "name": "pattern",
          "description": "The regular expression pattern."
        },
        {
          "name": "flags",
          "description": "General flags for the regular expression."
        },
        {
          "name": "error",
          "description": "Error message, if applicable."
        },
        {
          "name": "maxLen",
          "description": "Maximum length of the error buffer."
        }
      ],
      "error": [],
      "note": [
        "If you intend on using the same regular expression pattern multiple times, consider using CompileRegex and MatchRegex instead of making this function reparse the expression each time."
      ],
      "return": "Number of substrings found or -1 on failure."
    },
    "params": [
      {
        "name": "str",
        "type": "char[]",
        "default": null,
        "description": "The string to check."
      },
      {
        "name": "pattern",
        "type": "char[]",
        "default": null,
        "description": "The regular expression pattern."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "General flags for the regular expression."
      },
      {
        "name": "error",
        "type": "char[]",
        "default": "",
        "description": "Error message, if applicable."
      },
      {
        "name": "maxLen",
        "type": "int",
        "default": "",
        "description": "Maximum length of the error buffer."
      }
    ],
    "full_declaration": "stock int SimpleRegexMatch(const char[] str, const char[] pattern, int flags = 0, char[] error=\"\", int maxLen = 0) { \tRegex regex = new Regex(pattern, flags, error, maxLen);"
  },
  {
    "name": "__ext_regex_SetNTVOptional",
    "type": "public",
    "source_file": "regex.inc",
    "return_type": "void",
    "comment": "Do not edit below this line!",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [],
    "full_declaration": "public void __ext_regex_SetNTVOptional() { \tMarkNativeAsOptional(\"CompileRegex\");"
  },
  {
    "name": "OnEntityCreated",
    "type": "forward",
    "source_file": "sdkhooks.inc",
    "return_type": "void",
    "comment": "When an entity is created",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index"
        },
        {
          "name": "classname",
          "description": "Class name"
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index"
      },
      {
        "name": "classname",
        "type": "char[]",
        "default": null,
        "description": "Class name"
      }
    ],
    "full_declaration": "forward void OnEntityCreated(int entity, const char[] classname);"
  },
  {
    "name": "OnEntityDestroyed",
    "type": "forward",
    "source_file": "sdkhooks.inc",
    "return_type": "void",
    "comment": "When an entity is destroyed",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index or edict reference."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index or edict reference."
      }
    ],
    "full_declaration": "forward void OnEntityDestroyed(int entity);"
  },
  {
    "name": "OnGetGameDescription",
    "type": "forward",
    "source_file": "sdkhooks.inc",
    "return_type": "Action",
    "comment": "When the game description is retrieved",
    "tags": {
      "param": [
        {
          "name": "gameDesc",
          "description": "Game description"
        }
      ],
      "error": [],
      "note": [
        "Not supported on ep2v."
      ],
      "return": "Plugin_Changed if gameDesc has been edited, else no change."
    },
    "params": [
      {
        "name": "gameDesc",
        "type": "char",
        "default": null,
        "description": "Game description"
      }
    ],
    "full_declaration": "forward Action OnGetGameDescription(char gameDesc[64]);"
  },
  {
    "name": "OnLevelInit",
    "type": "forward",
    "source_file": "sdkhooks.inc",
    "return_type": "Action",
    "comment": "When the level is initialized",
    "tags": {
      "param": [
        {
          "name": "mapName",
          "description": "Name of the map"
        },
        {
          "name": "mapEntities",
          "description": "Unused, always empty"
        }
      ],
      "error": [],
      "note": [],
      "return": "Unused, return value is ignored"
    },
    "params": [
      {
        "name": "mapName",
        "type": "char[]",
        "default": null,
        "description": "Name of the map"
      },
      {
        "name": "mapEntities",
        "type": "char",
        "default": null,
        "description": "Unused, always empty"
      }
    ],
    "full_declaration": "forward Action OnLevelInit(const char[] mapName, char mapEntities[2097152]);"
  },
  {
    "name": "SDKHook",
    "type": "native",
    "source_file": "sdkhooks.inc",
    "return_type": "void",
    "comment": "Hooks an entity\n\nUnhooked automatically upon destruction/removal of the entity",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index"
        },
        {
          "name": "type",
          "description": "Type of function to hook"
        },
        {
          "name": "callback",
          "description": "Function to call when hook is called"
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index"
      },
      {
        "name": "type",
        "type": "SDKHookType",
        "default": null,
        "description": "Type of function to hook"
      },
      {
        "name": "callback",
        "type": "SDKHookCB",
        "default": null,
        "description": "Function to call when hook is called"
      }
    ],
    "full_declaration": "native void SDKHook(int entity, SDKHookType type, SDKHookCB callback);"
  },
  {
    "name": "SDKHookEx",
    "type": "native",
    "source_file": "sdkhooks.inc",
    "return_type": "bool",
    "comment": "Hooks an entity\n\nUnhooked automatically upon destruction/removal of the entity",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index"
        },
        {
          "name": "type",
          "description": "Type of function to hook"
        },
        {
          "name": "callback",
          "description": "Function to call when hook is called"
        }
      ],
      "error": [],
      "note": [],
      "return": "Hook Successful"
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index"
      },
      {
        "name": "type",
        "type": "SDKHookType",
        "default": null,
        "description": "Type of function to hook"
      },
      {
        "name": "callback",
        "type": "SDKHookCB",
        "default": null,
        "description": "Function to call when hook is called"
      }
    ],
    "full_declaration": "native bool SDKHookEx(int entity, SDKHookType type, SDKHookCB callback);"
  },
  {
    "name": "SDKUnhook",
    "type": "native",
    "source_file": "sdkhooks.inc",
    "return_type": "void",
    "comment": "Unhooks an entity",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index"
        },
        {
          "name": "type",
          "description": "Type of function to unhook"
        },
        {
          "name": "callback",
          "description": "Callback function to unhook"
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index"
      },
      {
        "name": "type",
        "type": "SDKHookType",
        "default": null,
        "description": "Type of function to unhook"
      },
      {
        "name": "callback",
        "type": "SDKHookCB",
        "default": null,
        "description": "Callback function to unhook"
      }
    ],
    "full_declaration": "native void SDKUnhook(int entity, SDKHookType type, SDKHookCB callback);"
  },
  {
    "name": "SDKHooks_TakeDamage",
    "type": "native",
    "source_file": "sdkhooks.inc",
    "return_type": "void",
    "comment": "Applies damage to an entity",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index taking damage"
        },
        {
          "name": "inflictor",
          "description": "Inflictor entity index"
        },
        {
          "name": "attacker",
          "description": "Attacker entity index"
        },
        {
          "name": "damage",
          "description": "Amount of damage"
        },
        {
          "name": "damageType",
          "description": "Bitfield of damage types"
        },
        {
          "name": "weapon",
          "description": "Weapon index (orangebox and later) or -1 for unspecified"
        },
        {
          "name": "damageForce",
          "description": "Velocity of damage force"
        },
        {
          "name": "damagePosition",
          "description": "Origin of damage"
        },
        {
          "name": "bypassHooks",
          "description": "If true, bypass SDK hooks on OnTakeDamage"
        }
      ],
      "error": [
        "Invalid entity, attacker, inflictor, or weapon entity."
      ],
      "note": [
        "Force application is dependent on game and damage type(s)"
      ],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index taking damage"
      },
      {
        "name": "inflictor",
        "type": "int",
        "default": null,
        "description": "Inflictor entity index"
      },
      {
        "name": "attacker",
        "type": "int",
        "default": null,
        "description": "Attacker entity index"
      },
      {
        "name": "damage",
        "type": "float",
        "default": null,
        "description": "Amount of damage"
      },
      {
        "name": "damageType",
        "type": "int",
        "default": "",
        "description": "Bitfield of damage types"
      },
      {
        "name": "weapon",
        "type": "int",
        "default": "",
        "description": "Weapon index (orangebox and later) or -1 for unspecified"
      },
      {
        "name": "damageForce",
        "type": "float",
        "default": null,
        "description": "Velocity of damage force"
      },
      {
        "name": "damagePosition",
        "type": "float",
        "default": null,
        "description": "Origin of damage"
      },
      {
        "name": "bypassHooks",
        "type": "bool",
        "default": "",
        "description": "If true, bypass SDK hooks on OnTakeDamage"
      }
    ],
    "full_declaration": "native void SDKHooks_TakeDamage(int entity, int inflictor, int attacker, \t\tfloat damage, int damageType=DMG_GENERIC, int weapon=-1, \t\tconst float damageForce[3]=NULL_VECTOR, const float damagePosition[3]=NULL_VECTOR, \t\tbool bypassHooks = true);"
  },
  {
    "name": "SDKHooks_DropWeapon",
    "type": "native",
    "source_file": "sdkhooks.inc",
    "return_type": "void",
    "comment": "Forces a client to drop the specified weapon",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "weapon",
          "description": "Weapon entity index."
        },
        {
          "name": "vecTarget",
          "description": "Location to toss weapon to, or NULL_VECTOR for default."
        },
        {
          "name": "vecVelocity",
          "description": "Velocity at which to toss weapon, or NULL_VECTOR for default."
        },
        {
          "name": "bypassHooks",
          "description": "If true, bypass SDK hooks on Weapon Drop"
        }
      ],
      "error": [
        "Invalid client or weapon entity, weapon not owned by client."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "weapon",
        "type": "int",
        "default": null,
        "description": "Weapon entity index."
      },
      {
        "name": "vecTarget",
        "type": "float",
        "default": null,
        "description": "Location to toss weapon to, or NULL_VECTOR for default."
      },
      {
        "name": "vecVelocity",
        "type": "float",
        "default": null,
        "description": "Velocity at which to toss weapon, or NULL_VECTOR for default."
      },
      {
        "name": "bypassHooks",
        "type": "bool",
        "default": "",
        "description": "If true, bypass SDK hooks on Weapon Drop"
      }
    ],
    "full_declaration": "native void SDKHooks_DropWeapon(int client, int weapon, const float vecTarget[3]=NULL_VECTOR, \t\tconst float vecVelocity[3]=NULL_VECTOR, bool bypassHooks = true);"
  },
  {
    "name": "StartPrepSDKCall",
    "type": "native",
    "source_file": "sdktools.inc",
    "return_type": "void",
    "comment": "Starts the preparation of an SDK call.",
    "tags": {
      "param": [
        {
          "name": "type",
          "description": "Type of function call this will be."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "type",
        "type": "SDKCallType",
        "default": null,
        "description": "Type of function call this will be."
      }
    ],
    "full_declaration": "native void StartPrepSDKCall(SDKCallType type);"
  },
  {
    "name": "PrepSDKCall_SetVirtual",
    "type": "native",
    "source_file": "sdktools.inc",
    "return_type": "void",
    "comment": "Sets the virtual index of the SDK call if it is virtual.",
    "tags": {
      "param": [
        {
          "name": "vtblidx",
          "description": "Virtual table index."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "vtblidx",
        "type": "int",
        "default": null,
        "description": "Virtual table index."
      }
    ],
    "full_declaration": "native void PrepSDKCall_SetVirtual(int vtblidx);"
  },
  {
    "name": "PrepSDKCall_SetSignature",
    "type": "native",
    "source_file": "sdktools.inc",
    "return_type": "bool",
    "comment": "Finds an address in a library and sets it as the address to use for the SDK call.",
    "tags": {
      "param": [
        {
          "name": "lib",
          "description": "Library to use."
        },
        {
          "name": "signature",
          "description": "Binary data to search for in the library.  If it starts with '@', the bytes parameter is ignored and the signature is interpreted as a symbol lookup in the library."
        },
        {
          "name": "bytes",
          "description": "Number of bytes in the binary search string."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false if nothing was found."
    },
    "params": [
      {
        "name": "lib",
        "type": "SDKLibrary",
        "default": null,
        "description": "Library to use."
      },
      {
        "name": "signature",
        "type": "char[]",
        "default": null,
        "description": "Binary data to search for in the library.  If it starts with '@', the bytes parameter is ignored and the signature is interpreted as a symbol lookup in the library."
      },
      {
        "name": "bytes",
        "type": "int",
        "default": null,
        "description": "Number of bytes in the binary search string."
      }
    ],
    "full_declaration": "native bool PrepSDKCall_SetSignature(SDKLibrary lib, const char[] signature, int bytes);"
  },
  {
    "name": "PrepSDKCall_SetAddress",
    "type": "native",
    "source_file": "sdktools.inc",
    "return_type": "bool",
    "comment": "Uses the given function address for the SDK call.",
    "tags": {
      "param": [
        {
          "name": "addr",
          "description": "Address of function to use."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false on failure."
    },
    "params": [
      {
        "name": "addr",
        "type": "Address",
        "default": null,
        "description": "Address of function to use."
      }
    ],
    "full_declaration": "native bool PrepSDKCall_SetAddress(Address addr);"
  },
  {
    "name": "PrepSDKCall_SetFromConf",
    "type": "native",
    "source_file": "sdktools.inc",
    "return_type": "bool",
    "comment": "Finds an address or virtual function index in a GameConfig file and sets it as\nthe calling information for the SDK call.",
    "tags": {
      "param": [
        {
          "name": "gameconf",
          "description": "GameConfig Handle, or INVALID_HANDLE to use sdktools.games.txt."
        },
        {
          "name": "source",
          "description": "Whether to look in Offsets or Signatures."
        },
        {
          "name": "name",
          "description": "Name of the property to find."
        }
      ],
      "error": [
        "Invalid game config Handle."
      ],
      "note": [],
      "return": "True on success, false if nothing was found."
    },
    "params": [
      {
        "name": "gameconf",
        "type": "Handle",
        "default": null,
        "description": "GameConfig Handle, or INVALID_HANDLE to use sdktools.games.txt."
      },
      {
        "name": "source",
        "type": "SDKFuncConfSource",
        "default": null,
        "description": "Whether to look in Offsets or Signatures."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Name of the property to find."
      }
    ],
    "full_declaration": "native bool PrepSDKCall_SetFromConf(Handle gameconf, SDKFuncConfSource source, const char[] name);"
  },
  {
    "name": "PrepSDKCall_SetReturnInfo",
    "type": "native",
    "source_file": "sdktools.inc",
    "return_type": "void",
    "comment": "Sets the return information of an SDK call.  Do not call this if there is no return data.\nThis must be called if there is a return value (i.e. it is not necessarily safe to ignore\nthe data).",
    "tags": {
      "param": [
        {
          "name": "type",
          "description": "Data type to convert to/from."
        },
        {
          "name": "pass",
          "description": "How the data is passed in C++."
        },
        {
          "name": "decflags",
          "description": "Flags on decoding from the plugin to C++."
        },
        {
          "name": "encflags",
          "description": "Flags on encoding from C++ to the plugin."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "type",
        "type": "SDKType",
        "default": null,
        "description": "Data type to convert to/from."
      },
      {
        "name": "pass",
        "type": "SDKPassMethod",
        "default": null,
        "description": "How the data is passed in C++."
      },
      {
        "name": "decflags",
        "type": "int",
        "default": "",
        "description": "Flags on decoding from the plugin to C++."
      },
      {
        "name": "encflags",
        "type": "int",
        "default": "",
        "description": "Flags on encoding from C++ to the plugin."
      }
    ],
    "full_declaration": "native void PrepSDKCall_SetReturnInfo(SDKType type, SDKPassMethod pass, int decflags=0, int encflags=0);"
  },
  {
    "name": "PrepSDKCall_AddParameter",
    "type": "native",
    "source_file": "sdktools.inc",
    "return_type": "void",
    "comment": "Adds a parameter to the calling convention.  This should be called in normal ascending order.",
    "tags": {
      "param": [
        {
          "name": "type",
          "description": "Data type to convert to/from."
        },
        {
          "name": "pass",
          "description": "How the data is passed in C++."
        },
        {
          "name": "decflags",
          "description": "Flags on decoding from the plugin to C++."
        },
        {
          "name": "encflags",
          "description": "Flags on encoding from C++ to the plugin."
        }
      ],
      "error": [
        "Parameter limit for SDK calls reached."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "type",
        "type": "SDKType",
        "default": null,
        "description": "Data type to convert to/from."
      },
      {
        "name": "pass",
        "type": "SDKPassMethod",
        "default": null,
        "description": "How the data is passed in C++."
      },
      {
        "name": "decflags",
        "type": "int",
        "default": "",
        "description": "Flags on decoding from the plugin to C++."
      },
      {
        "name": "encflags",
        "type": "int",
        "default": "",
        "description": "Flags on encoding from C++ to the plugin."
      }
    ],
    "full_declaration": "native void PrepSDKCall_AddParameter(SDKType type, SDKPassMethod pass, int decflags=0, int encflags=0);"
  },
  {
    "name": "EndPrepSDKCall",
    "type": "native",
    "source_file": "sdktools.inc",
    "return_type": "Handle",
    "comment": "Finalizes an SDK call preparation and returns the resultant Handle.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "A new SDKCall Handle on success, or INVALID_HANDLE on failure."
    },
    "params": [],
    "full_declaration": "native Handle EndPrepSDKCall();"
  },
  {
    "name": "SDKCall",
    "type": "native",
    "source_file": "sdktools.inc",
    "return_type": "any",
    "comment": "Calls an SDK function with the given parameters.\n\nIf the call type is Entity or Player, the index MUST ALWAYS be the FIRST parameter passed.\nIf the call type is GameRules, then nothing special needs to be passed.\nIf the return value is a Vector or QAngles, the SECOND parameter must be a Float[3].\nIf the return value is a string, the THIRD parameter must be a String buffer, and the\nFOURTH parameter must be the maximum length.\nAll parameters must be passed after the above is followed.  Failure to follow these\nrules will result in crashes or wildly unexpected behavior!\n\nIf the return value is a float or integer, the return value will be this value.\nIf the return value is a string, the value returned by the function will be the number of bytes written, or -1 for NULL.\nIf the return value is a CBaseEntity, CBasePlayer, or edict, the return value will\nalways be the entity index, or -1 for NULL.",
    "tags": {
      "param": [
        {
          "name": "call",
          "description": "SDKCall Handle."
        }
      ],
      "error": [
        "Invalid Handle or internal decoding error."
      ],
      "note": [],
      "return": "Simple return value, if any."
    },
    "params": [
      {
        "name": "call",
        "type": "Handle",
        "default": null,
        "description": "SDKCall Handle."
      }
    ],
    "full_declaration": "native any SDKCall(Handle call, any ...);"
  },
  {
    "name": "GetPlayerResourceEntity",
    "type": "native",
    "source_file": "sdktools.inc",
    "return_type": "int",
    "comment": "Returns the entity index of the player resource/manager entity.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "Index of resource entity or -1 if not found."
    },
    "params": [],
    "full_declaration": "native int GetPlayerResourceEntity();"
  },
  {
    "name": "InactivateClient",
    "type": "native",
    "source_file": "sdktools_client.inc",
    "return_type": "void",
    "comment": "Sets the client to an inactive state waiting for a new map",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "The client index"
        }
      ],
      "error": [
        "Invalid client index."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "The client index"
      }
    ],
    "full_declaration": "native void InactivateClient(int client);"
  },
  {
    "name": "ReconnectClient",
    "type": "native",
    "source_file": "sdktools_client.inc",
    "return_type": "void",
    "comment": "Reconnect a client without dropping the netchannel",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "The client index"
        }
      ],
      "error": [
        "Invalid client index."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "The client index"
      }
    ],
    "full_declaration": "native void ReconnectClient(int client);"
  },
  {
    "name": "SetClientViewEntity",
    "type": "native",
    "source_file": "sdktools_engine.inc",
    "return_type": "void",
    "comment": "Sets a client's \"viewing entity.\"",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "entity",
          "description": "Entity index."
        }
      ],
      "error": [
        "Invalid client or entity, lack of mod support, or client not in game."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      }
    ],
    "full_declaration": "native void SetClientViewEntity(int client, int entity);"
  },
  {
    "name": "SetLightStyle",
    "type": "native",
    "source_file": "sdktools_engine.inc",
    "return_type": "void",
    "comment": "Sets a light style.",
    "tags": {
      "param": [
        {
          "name": "style",
          "description": "Light style (from 0 to MAX_LIGHTSTYLES-1)"
        },
        {
          "name": "value",
          "description": "Light value string (see world.cpp/light.cpp in dlls)"
        }
      ],
      "error": [
        "Light style index is out of range."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "style",
        "type": "int",
        "default": null,
        "description": "Light style (from 0 to MAX_LIGHTSTYLES-1)"
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "Light value string (see world.cpp/light.cpp in dlls)"
      }
    ],
    "full_declaration": "native void SetLightStyle(int style, const char[] value);"
  },
  {
    "name": "GetClientEyePosition",
    "type": "native",
    "source_file": "sdktools_engine.inc",
    "return_type": "void",
    "comment": "Returns the client's eye position.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        },
        {
          "name": "pos",
          "description": "Destination vector to store the client's eye position."
        }
      ],
      "error": [
        "Invalid client index, client not in game, or no mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      },
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Destination vector to store the client's eye position."
      }
    ],
    "full_declaration": "native void GetClientEyePosition(int client, float pos[3]);"
  },
  {
    "name": "AcceptEntityInput",
    "type": "native",
    "source_file": "sdktools_entinput.inc",
    "return_type": "bool",
    "comment": "Invokes a named input method on an entity.\n\nAfter completion (successful or not), the current global variant is re-initialized.",
    "tags": {
      "param": [
        {
          "name": "dest",
          "description": "Destination entity index."
        },
        {
          "name": "input",
          "description": "Input action."
        },
        {
          "name": "activator",
          "description": "Entity index which initiated the sequence of actions (-1 for a NULL entity)."
        },
        {
          "name": "caller",
          "description": "Entity index from which this event is sent (-1 for a NULL entity)."
        },
        {
          "name": "outputid",
          "description": "Unknown."
        }
      ],
      "error": [
        "Invalid entity index or no mod support."
      ],
      "note": [],
      "return": "True if successful otherwise false."
    },
    "params": [
      {
        "name": "dest",
        "type": "int",
        "default": null,
        "description": "Destination entity index."
      },
      {
        "name": "input",
        "type": "char[]",
        "default": null,
        "description": "Input action."
      },
      {
        "name": "activator",
        "type": "int",
        "default": "",
        "description": "Entity index which initiated the sequence of actions (-1 for a NULL entity)."
      },
      {
        "name": "caller",
        "type": "int",
        "default": "",
        "description": "Entity index from which this event is sent (-1 for a NULL entity)."
      },
      {
        "name": "outputid",
        "type": "int",
        "default": "",
        "description": "Unknown."
      }
    ],
    "full_declaration": "native bool AcceptEntityInput(int dest, const char[] input, int activator=-1, int caller=-1, int outputid=0);"
  },
  {
    "name": "HookEntityOutput",
    "type": "native",
    "source_file": "sdktools_entoutput.inc",
    "return_type": "void",
    "comment": "Add an entity output hook on a entity classname",
    "tags": {
      "param": [
        {
          "name": "classname",
          "description": "The classname to hook."
        },
        {
          "name": "output",
          "description": "The output name to hook."
        },
        {
          "name": "callback",
          "description": "An EntityOutput function pointer."
        }
      ],
      "error": [
        "Entity Outputs disabled."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "classname",
        "type": "char[]",
        "default": null,
        "description": "The classname to hook."
      },
      {
        "name": "output",
        "type": "char[]",
        "default": null,
        "description": "The output name to hook."
      },
      {
        "name": "callback",
        "type": "EntityOutput",
        "default": null,
        "description": "An EntityOutput function pointer."
      }
    ],
    "full_declaration": "native void HookEntityOutput(const char[] classname, const char[] output, EntityOutput callback);"
  },
  {
    "name": "UnhookEntityOutput",
    "type": "native",
    "source_file": "sdktools_entoutput.inc",
    "return_type": "bool",
    "comment": "Remove an entity output hook.",
    "tags": {
      "param": [
        {
          "name": "classname",
          "description": "The classname to hook."
        },
        {
          "name": "output",
          "description": "The output name to hook."
        },
        {
          "name": "callback",
          "description": "An EntityOutput function pointer."
        }
      ],
      "error": [
        "Entity Outputs disabled."
      ],
      "note": [],
      "return": "True on success, false if no valid hook was found."
    },
    "params": [
      {
        "name": "classname",
        "type": "char[]",
        "default": null,
        "description": "The classname to hook."
      },
      {
        "name": "output",
        "type": "char[]",
        "default": null,
        "description": "The output name to hook."
      },
      {
        "name": "callback",
        "type": "EntityOutput",
        "default": null,
        "description": "An EntityOutput function pointer."
      }
    ],
    "full_declaration": "native bool UnhookEntityOutput(const char[] classname, const char[] output, EntityOutput callback);"
  },
  {
    "name": "HookSingleEntityOutput",
    "type": "native",
    "source_file": "sdktools_entoutput.inc",
    "return_type": "void",
    "comment": "Add an entity output hook on a single entity instance",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "The entity on which to add a hook."
        },
        {
          "name": "output",
          "description": "The output name to hook."
        },
        {
          "name": "callback",
          "description": "An EntityOutput function pointer."
        },
        {
          "name": "once",
          "description": "Only fire this hook once and then remove itself."
        }
      ],
      "error": [
        "Entity Outputs disabled or Invalid Entity index."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "The entity on which to add a hook."
      },
      {
        "name": "output",
        "type": "char[]",
        "default": null,
        "description": "The output name to hook."
      },
      {
        "name": "callback",
        "type": "EntityOutput",
        "default": null,
        "description": "An EntityOutput function pointer."
      },
      {
        "name": "once",
        "type": "bool",
        "default": "",
        "description": "Only fire this hook once and then remove itself."
      }
    ],
    "full_declaration": "native void HookSingleEntityOutput(int entity, const char[] output, EntityOutput callback, bool once=false);"
  },
  {
    "name": "UnhookSingleEntityOutput",
    "type": "native",
    "source_file": "sdktools_entoutput.inc",
    "return_type": "bool",
    "comment": "Remove a single entity output hook.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "The entity on which to remove the hook."
        },
        {
          "name": "output",
          "description": "The output name to hook."
        },
        {
          "name": "callback",
          "description": "An EntityOutput function pointer."
        }
      ],
      "error": [
        "Entity Outputs disabled or Invalid Entity index."
      ],
      "note": [],
      "return": "True on success, false if no valid hook was found."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "The entity on which to remove the hook."
      },
      {
        "name": "output",
        "type": "char[]",
        "default": null,
        "description": "The output name to hook."
      },
      {
        "name": "callback",
        "type": "EntityOutput",
        "default": null,
        "description": "An EntityOutput function pointer."
      }
    ],
    "full_declaration": "native bool UnhookSingleEntityOutput(int entity, const char[] output, EntityOutput callback);"
  },
  {
    "name": "FireEntityOutput",
    "type": "native",
    "source_file": "sdktools_entoutput.inc",
    "return_type": "void",
    "comment": "Fire a named output on an entity.\n\nAfter completion (successful or not), the current global variant is re-initialized.",
    "tags": {
      "param": [
        {
          "name": "caller",
          "description": "Entity index from where the output is fired."
        },
        {
          "name": "output",
          "description": "Output name."
        },
        {
          "name": "activator",
          "description": "Entity index which initiated the sequence of actions (-1 for a NULL entity)."
        },
        {
          "name": "delay",
          "description": "Delay before firing the output."
        }
      ],
      "error": [
        "Invalid entity index or no mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "caller",
        "type": "int",
        "default": null,
        "description": "Entity index from where the output is fired."
      },
      {
        "name": "output",
        "type": "char[]",
        "default": null,
        "description": "Output name."
      },
      {
        "name": "activator",
        "type": "int",
        "default": "",
        "description": "Entity index which initiated the sequence of actions (-1 for a NULL entity)."
      },
      {
        "name": "delay",
        "type": "float",
        "default": "",
        "description": "Delay before firing the output."
      }
    ],
    "full_declaration": "native void FireEntityOutput(int caller, const char[] output, int activator=-1, float delay=0.0);"
  },
  {
    "name": "RemovePlayerItem",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "bool",
    "comment": "Removes a player's item.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "item",
          "description": "CBaseCombatWeapon entity index."
        }
      ],
      "error": [
        "Invalid client or entity, lack of mod support, or client not in game."
      ],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "item",
        "type": "int",
        "default": null,
        "description": "CBaseCombatWeapon entity index."
      }
    ],
    "full_declaration": "native bool RemovePlayerItem(int client, int item);"
  },
  {
    "name": "GivePlayerItem",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "int",
    "comment": "Gives a named item to a player.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "item",
          "description": "Item classname (such as weapon_ak47)."
        },
        {
          "name": "iSubType",
          "description": "Unknown."
        }
      ],
      "error": [
        "Invalid client or client not in game, or lack of mod support."
      ],
      "note": [],
      "return": "Entity index on success, or -1 on failure."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "item",
        "type": "char[]",
        "default": null,
        "description": "Item classname (such as weapon_ak47)."
      },
      {
        "name": "iSubType",
        "type": "int",
        "default": "",
        "description": "Unknown."
      }
    ],
    "full_declaration": "native int GivePlayerItem(int client, const char[] item, int iSubType=0);"
  },
  {
    "name": "GetPlayerWeaponSlot",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "int",
    "comment": "Returns the weapon in a player's slot.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "slot",
          "description": "Slot index (mod specific)."
        }
      ],
      "error": [
        "Invalid client or client not in game, or lack of mod support."
      ],
      "note": [],
      "return": "Entity index on success, -1 if no weapon existed."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "slot",
        "type": "int",
        "default": null,
        "description": "Slot index (mod specific)."
      }
    ],
    "full_declaration": "native int GetPlayerWeaponSlot(int client, int slot);"
  },
  {
    "name": "IgniteEntity",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "void",
    "comment": "Ignites an entity on fire.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index."
        },
        {
          "name": "time",
          "description": "Number of seconds to set on fire."
        },
        {
          "name": "npc",
          "description": "True to only affect NPCs."
        },
        {
          "name": "size",
          "description": "Unknown."
        },
        {
          "name": "level",
          "description": "Unknown."
        }
      ],
      "error": [
        "Invalid entity or client not in game, or lack of mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      },
      {
        "name": "time",
        "type": "float",
        "default": null,
        "description": "Number of seconds to set on fire."
      },
      {
        "name": "npc",
        "type": "bool",
        "default": "",
        "description": "True to only affect NPCs."
      },
      {
        "name": "size",
        "type": "float",
        "default": "",
        "description": "Unknown."
      },
      {
        "name": "level",
        "type": "bool",
        "default": "",
        "description": "Unknown."
      }
    ],
    "full_declaration": "native void IgniteEntity(int entity, float time, bool npc=false, float size=0.0, bool level=false);"
  },
  {
    "name": "ExtinguishEntity",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "void",
    "comment": "Extinguishes an entity that is on fire.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index."
        }
      ],
      "error": [
        "Invalid entity or client not in game, or lack of mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      }
    ],
    "full_declaration": "native void ExtinguishEntity(int entity);"
  },
  {
    "name": "TeleportEntity",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "void",
    "comment": "Teleports an entity.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Client index."
        },
        {
          "name": "origin",
          "description": "New origin, or NULL_VECTOR for no change."
        },
        {
          "name": "angles",
          "description": "New angles, or NULL_VECTOR for no change."
        },
        {
          "name": "velocity",
          "description": "New velocity, or NULL_VECTOR for no change."
        }
      ],
      "error": [
        "Invalid entity or client not in game, or lack of mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "origin",
        "type": "float",
        "default": null,
        "description": "New origin, or NULL_VECTOR for no change."
      },
      {
        "name": "angles",
        "type": "float",
        "default": null,
        "description": "New angles, or NULL_VECTOR for no change."
      },
      {
        "name": "velocity",
        "type": "float",
        "default": null,
        "description": "New velocity, or NULL_VECTOR for no change."
      }
    ],
    "full_declaration": "native void TeleportEntity(int entity, const float origin[3] = NULL_VECTOR, const float angles[3] = NULL_VECTOR, const float velocity[3] = NULL_VECTOR);"
  },
  {
    "name": "ForcePlayerSuicide",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "void",
    "comment": "Forces a player to commit suicide.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "explode",
          "description": "If true, explode the player."
        }
      ],
      "error": [
        "Invalid client or client not in game, or lack of mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "explode",
        "type": "bool",
        "default": "",
        "description": "If true, explode the player."
      }
    ],
    "full_declaration": "native void ForcePlayerSuicide(int client, bool explode = false);"
  },
  {
    "name": "SlapPlayer",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "void",
    "comment": "Slaps a player in a random direction.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "health",
          "description": "Health to subtract."
        },
        {
          "name": "sound",
          "description": "False to disable the sound effects."
        }
      ],
      "error": [
        "Invalid client or client not in game, or lack of mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "health",
        "type": "int",
        "default": "",
        "description": "Health to subtract."
      },
      {
        "name": "sound",
        "type": "bool",
        "default": "",
        "description": "False to disable the sound effects."
      }
    ],
    "full_declaration": "native void SlapPlayer(int client, int health=5, bool sound=true);"
  },
  {
    "name": "FindEntityByClassname",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "int",
    "comment": "Searches for an entity by classname.",
    "tags": {
      "param": [
        {
          "name": "startEnt",
          "description": "A valid entity's index after which to begin searching from. Use -1 to start from the first entity."
        },
        {
          "name": "classname",
          "description": "Classname of the entity to find."
        }
      ],
      "error": [
        "Invalid start entity or lack of mod support."
      ],
      "note": [],
      "return": "Entity index >= 0 if found, -1 otherwise."
    },
    "params": [
      {
        "name": "startEnt",
        "type": "int",
        "default": null,
        "description": "A valid entity's index after which to begin searching from. Use -1 to start from the first entity."
      },
      {
        "name": "classname",
        "type": "char[]",
        "default": null,
        "description": "Classname of the entity to find."
      }
    ],
    "full_declaration": "native int FindEntityByClassname(int startEnt, const char[] classname);"
  },
  {
    "name": "GetClientEyeAngles",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "bool",
    "comment": "Returns the client's eye angles.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        },
        {
          "name": "ang",
          "description": "Destination vector to store the client's eye angles."
        }
      ],
      "error": [
        "Invalid client index, client not in game, or lack of mod support."
      ],
      "note": [],
      "return": "True on success, false on failure."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      },
      {
        "name": "ang",
        "type": "float",
        "default": null,
        "description": "Destination vector to store the client's eye angles."
      }
    ],
    "full_declaration": "native bool GetClientEyeAngles(int client, float ang[3]);"
  },
  {
    "name": "CreateEntityByName",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "int",
    "comment": "Creates an entity by string name, but does not spawn it (see DispatchSpawn).\nIf ForceEdictIndex is not -1, then it will use the edict by that index. If the index is\ninvalid or there is already an edict using that index, it will error out.",
    "tags": {
      "param": [
        {
          "name": "classname",
          "description": "Entity classname."
        },
        {
          "name": "ForceEdictIndex",
          "description": "Edict index used by the created entity (ignored on Orangebox and above)."
        }
      ],
      "error": [
        "Invalid edict index, no map is running, or lack of mod support."
      ],
      "note": [],
      "return": "Entity index on success, or -1 on failure."
    },
    "params": [
      {
        "name": "classname",
        "type": "char[]",
        "default": null,
        "description": "Entity classname."
      },
      {
        "name": "ForceEdictIndex",
        "type": "int",
        "default": "",
        "description": "Edict index used by the created entity (ignored on Orangebox and above)."
      }
    ],
    "full_declaration": "native int CreateEntityByName(const char[] classname, int ForceEdictIndex=-1);"
  },
  {
    "name": "DispatchSpawn",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "bool",
    "comment": "Spawns an entity into the game.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index of the created entity."
        }
      ],
      "error": [
        "Invalid entity index or lack of mod support."
      ],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index of the created entity."
      }
    ],
    "full_declaration": "native bool DispatchSpawn(int entity);"
  },
  {
    "name": "DispatchKeyValue",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "bool",
    "comment": "Dispatches a KeyValue into given entity using a string value.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Destination entity index."
        },
        {
          "name": "keyName",
          "description": "Name of the key."
        },
        {
          "name": "value",
          "description": "String value."
        }
      ],
      "error": [
        "Invalid entity index or lack of mod support."
      ],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Destination entity index."
      },
      {
        "name": "keyName",
        "type": "char[]",
        "default": null,
        "description": "Name of the key."
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "String value."
      }
    ],
    "full_declaration": "native bool DispatchKeyValue(int entity, const char[] keyName, const char[] value);"
  },
  {
    "name": "DispatchKeyValueInt",
    "type": "stock",
    "source_file": "sdktools_functions.inc",
    "return_type": "bool",
    "comment": "Dispatches a KeyValue into given entity using an integer value.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Destination entity index."
        },
        {
          "name": "keyName",
          "description": "Name of the key."
        },
        {
          "name": "value",
          "description": "Integer value."
        }
      ],
      "error": [
        "Invalid entity index or lack of mod support."
      ],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Destination entity index."
      },
      {
        "name": "keyName",
        "type": "char[]",
        "default": null,
        "description": "Name of the key."
      },
      {
        "name": "value",
        "type": "int",
        "default": null,
        "description": "Integer value."
      }
    ],
    "full_declaration": "stock bool DispatchKeyValueInt(int entity, const char[] keyName, int value) {     char str[12];     FormatEx(str, sizeof(str), \"%d\", value);"
  },
  {
    "name": "DispatchKeyValueFloat",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "bool",
    "comment": "Dispatches a KeyValue into given entity using a floating point value.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Destination entity index."
        },
        {
          "name": "keyName",
          "description": "Name of the key."
        },
        {
          "name": "value",
          "description": "Floating point value."
        }
      ],
      "error": [
        "Invalid entity index or lack of mod support."
      ],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Destination entity index."
      },
      {
        "name": "keyName",
        "type": "char[]",
        "default": null,
        "description": "Name of the key."
      },
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Floating point value."
      }
    ],
    "full_declaration": "native bool DispatchKeyValueFloat(int entity, const char[] keyName, float value);"
  },
  {
    "name": "DispatchKeyValueVector",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "bool",
    "comment": "Dispatches a KeyValue into given entity using a vector value.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Destination entity index."
        },
        {
          "name": "keyName",
          "description": "Name of the key."
        },
        {
          "name": "vec",
          "description": "Vector value."
        }
      ],
      "error": [
        "Invalid entity index or lack of mod support."
      ],
      "note": [],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Destination entity index."
      },
      {
        "name": "keyName",
        "type": "char[]",
        "default": null,
        "description": "Name of the key."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Vector value."
      }
    ],
    "full_declaration": "native bool DispatchKeyValueVector(int entity, const char[] keyName, const float vec[3]);"
  },
  {
    "name": "GetClientAimTarget",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "int",
    "comment": "Returns the entity a client is aiming at.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client performing the aiming."
        },
        {
          "name": "only_clients",
          "description": "True to exclude all entities but clients."
        }
      ],
      "error": [
        "Invalid client index or client not in game."
      ],
      "note": [],
      "return": "Entity index being aimed at. -1 if no entity is being aimed at. -2 if the function is not supported."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client performing the aiming."
      },
      {
        "name": "only_clients",
        "type": "bool",
        "default": "",
        "description": "True to exclude all entities but clients."
      }
    ],
    "full_declaration": "native int GetClientAimTarget(int client, bool only_clients=true);"
  },
  {
    "name": "GetTeamCount",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "int",
    "comment": "Returns the total number of teams in a game.\nNote: This native should not be called before OnMapStart.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "Total number of teams."
    },
    "params": [],
    "full_declaration": "native int GetTeamCount();"
  },
  {
    "name": "GetTeamName",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "void",
    "comment": "Retrieves the team name based on a team index.\nNote: This native should not be called before OnMapStart.",
    "tags": {
      "param": [
        {
          "name": "index",
          "description": "Team index."
        },
        {
          "name": "name",
          "description": "Buffer to store string in."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of string buffer."
        }
      ],
      "error": [
        "Invalid team index."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "index",
        "type": "int",
        "default": null,
        "description": "Team index."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store string in."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of string buffer."
      }
    ],
    "full_declaration": "native void GetTeamName(int index, char[] name, int maxlength);"
  },
  {
    "name": "GetTeamScore",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "int",
    "comment": "Returns the score of a team based on a team index.\nNote: This native should not be called before OnMapStart.",
    "tags": {
      "param": [
        {
          "name": "index",
          "description": "Team index."
        }
      ],
      "error": [
        "Invalid team index."
      ],
      "note": [],
      "return": "Score."
    },
    "params": [
      {
        "name": "index",
        "type": "int",
        "default": null,
        "description": "Team index."
      }
    ],
    "full_declaration": "native int GetTeamScore(int index);"
  },
  {
    "name": "SetTeamScore",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "void",
    "comment": "Sets the score of a team based on a team index.\nNote: This native should not be called before OnMapStart.",
    "tags": {
      "param": [
        {
          "name": "index",
          "description": "Team index."
        },
        {
          "name": "value",
          "description": "New score value."
        }
      ],
      "error": [
        "Invalid team index."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "index",
        "type": "int",
        "default": null,
        "description": "Team index."
      },
      {
        "name": "value",
        "type": "int",
        "default": null,
        "description": "New score value."
      }
    ],
    "full_declaration": "native void SetTeamScore(int index, int value);"
  },
  {
    "name": "GetTeamClientCount",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "int",
    "comment": "Retrieves the number of players in a certain team.\nNote: This native should not be called before OnMapStart.",
    "tags": {
      "param": [
        {
          "name": "index",
          "description": "Team index."
        }
      ],
      "error": [
        "Invalid team index."
      ],
      "note": [],
      "return": "Number of players in the team."
    },
    "params": [
      {
        "name": "index",
        "type": "int",
        "default": null,
        "description": "Team index."
      }
    ],
    "full_declaration": "native int GetTeamClientCount(int index);"
  },
  {
    "name": "GetTeamEntity",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "int",
    "comment": "Returns the entity index of a team.",
    "tags": {
      "param": [
        {
          "name": "teamIndex",
          "description": "Team index."
        }
      ],
      "error": [
        "Invalid team index."
      ],
      "note": [],
      "return": "Entity index of team."
    },
    "params": [
      {
        "name": "teamIndex",
        "type": "int",
        "default": null,
        "description": "Team index."
      }
    ],
    "full_declaration": "native int GetTeamEntity(int teamIndex);"
  },
  {
    "name": "SetEntityModel",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "void",
    "comment": "Sets the model to a given entity.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index."
        },
        {
          "name": "model",
          "description": "Model name."
        }
      ],
      "error": [
        "Invalid entity index or lack of mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      },
      {
        "name": "model",
        "type": "char[]",
        "default": null,
        "description": "Model name."
      }
    ],
    "full_declaration": "native void SetEntityModel(int entity, const char[] model);"
  },
  {
    "name": "GetPlayerDecalFile",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "bool",
    "comment": "Retrieves the decal file name associated with a given client.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        },
        {
          "name": "hex",
          "description": "Buffer to store the logo filename."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of string buffer."
        }
      ],
      "error": [
        "Invalid client or client not in game."
      ],
      "note": [],
      "return": "True on success, otherwise false."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      },
      {
        "name": "hex",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the logo filename."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of string buffer."
      }
    ],
    "full_declaration": "native bool GetPlayerDecalFile(int client, char[] hex, int maxlength);"
  },
  {
    "name": "GetPlayerJingleFile",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "bool",
    "comment": "Retrieves the jingle file name associated with a given client.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        },
        {
          "name": "hex",
          "description": "Buffer to store the jingle filename."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of string buffer."
        }
      ],
      "error": [
        "Invalid client or client not in game."
      ],
      "note": [],
      "return": "True on success, otherwise false."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      },
      {
        "name": "hex",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the jingle filename."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of string buffer."
      }
    ],
    "full_declaration": "native bool GetPlayerJingleFile(int client, char[] hex, int maxlength);"
  },
  {
    "name": "GetServerNetStats",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "void",
    "comment": "Returns the average server network traffic in bytes/sec.",
    "tags": {
      "param": [
        {
          "name": "in",
          "description": "Buffer to store the input traffic velocity."
        },
        {
          "name": "out",
          "description": "Buffer to store the output traffic velocity."
        }
      ],
      "error": [
        "Lack of mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "inAmount",
        "type": "float",
        "default": null,
        "description": ""
      },
      {
        "name": "outAmout",
        "type": "float",
        "default": null,
        "description": ""
      }
    ],
    "full_declaration": "native void GetServerNetStats(float &inAmount, float &outAmout);"
  },
  {
    "name": "EquipPlayerWeapon",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "void",
    "comment": "Equip's a player's weapon.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "weapon",
          "description": "CBaseCombatWeapon entity index."
        }
      ],
      "error": [
        "Invalid client or entity, lack of mod support, or client not in game."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "weapon",
        "type": "int",
        "default": null,
        "description": "CBaseCombatWeapon entity index."
      }
    ],
    "full_declaration": "native void EquipPlayerWeapon(int client, int weapon);"
  },
  {
    "name": "ActivateEntity",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "void",
    "comment": "Activates an entity (CBaseAnimating::Activate)",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index."
        }
      ],
      "error": [
        "Invalid entity or lack of mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      }
    ],
    "full_declaration": "native void ActivateEntity(int entity);"
  },
  {
    "name": "SetClientInfo",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "void",
    "comment": "Sets values to client info buffer keys and notifies the engine of the change.\nThe change does not get propagated to mods until the next frame.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        },
        {
          "name": "key",
          "description": "Key string."
        },
        {
          "name": "value",
          "description": "Value string."
        }
      ],
      "error": [
        "Invalid client index, client not connected, or lack of mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Key string."
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "Value string."
      }
    ],
    "full_declaration": "native void SetClientInfo(int client, const char[] key, const char[] value);"
  },
  {
    "name": "SetClientName",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "void",
    "comment": "Changes a client's name.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Player's index."
        },
        {
          "name": "name",
          "description": "New name."
        }
      ],
      "error": [
        "Invalid client index, client not connected, or lack of mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Player's index."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "New name."
      }
    ],
    "full_declaration": "native void SetClientName(int client, const char[] name);"
  },
  {
    "name": "GivePlayerAmmo",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "int",
    "comment": "Gives ammo of a certain type to a player.\nThis natives obeys the maximum amount of ammo a player can carry per ammo type.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "The client index."
        },
        {
          "name": "amount",
          "description": "Amount of ammo to give. Is capped at ammotype's limit."
        },
        {
          "name": "ammotype",
          "description": "Type of ammo to give to player."
        },
        {
          "name": "suppressSound",
          "description": "If true, don't play the ammo pickup sound."
        }
      ],
      "error": [
        "Lack of mod support."
      ],
      "note": [],
      "return": "Amount of ammo actually given."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "The client index."
      },
      {
        "name": "amount",
        "type": "int",
        "default": null,
        "description": "Amount of ammo to give. Is capped at ammotype's limit."
      },
      {
        "name": "ammotype",
        "type": "int",
        "default": null,
        "description": "Type of ammo to give to player."
      },
      {
        "name": "suppressSound",
        "type": "bool",
        "default": "",
        "description": "If true, don't play the ammo pickup sound."
      }
    ],
    "full_declaration": "native int GivePlayerAmmo(int client, int amount, int ammotype, bool suppressSound=false);"
  },
  {
    "name": "SetEntityCollisionGroup",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "void",
    "comment": "Changes an entity's collision group (CBaseEntity::SetCollisionGroup).",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "The entity index."
        },
        {
          "name": "collisionGroup",
          "description": "Collision group to use."
        }
      ],
      "error": [
        "Invalid entity or lack of mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "The entity index."
      },
      {
        "name": "collisionGroup",
        "type": "int",
        "default": null,
        "description": "Collision group to use."
      }
    ],
    "full_declaration": "native void SetEntityCollisionGroup(int entity, int collisionGroup);"
  },
  {
    "name": "EntityCollisionRulesChanged",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "void",
    "comment": "Recaculates entity collision rules (CBaseEntity::CollisionRulesChanged).",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "The entity index."
        }
      ],
      "error": [
        "Invalid entity or lack of mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "The entity index."
      }
    ],
    "full_declaration": "native void EntityCollisionRulesChanged(int entity);"
  },
  {
    "name": "SetEntityOwner",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "void",
    "comment": "Sets an entity's owner (CBaseEntity::SetEntityOwner).",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "The entity index."
        },
        {
          "name": "owner",
          "description": "The owner entity index, can be invalid."
        }
      ],
      "error": [
        "Invalid entity or lack of mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "The entity index."
      },
      {
        "name": "owner",
        "type": "int",
        "default": "",
        "description": "The owner entity index, can be invalid."
      }
    ],
    "full_declaration": "native void SetEntityOwner(int entity, int owner=INVALID_ENT_REFERENCE);"
  },
  {
    "name": "LookupEntityAttachment",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "int",
    "comment": "Returns the index number of a given named attachment.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "The entity index."
        },
        {
          "name": "name",
          "description": "The attachment name."
        }
      ],
      "error": [
        "Invalid entity or lack of mod support."
      ],
      "note": [],
      "return": "An attachment index, or 0 if the attachment name is invalid or unused."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "The entity index."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "The attachment name."
      }
    ],
    "full_declaration": "native int LookupEntityAttachment(int entity, const char[] name);"
  },
  {
    "name": "GetEntityAttachment",
    "type": "native",
    "source_file": "sdktools_functions.inc",
    "return_type": "bool",
    "comment": "Returns the world location and world angles of an attachment.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "The entity index."
        },
        {
          "name": "attachment",
          "description": "The attachment index."
        },
        {
          "name": "origin",
          "description": "Destination vector to store the attachment's origin vector."
        },
        {
          "name": "angles",
          "description": "Destination vector to store the attachment's position angle."
        }
      ],
      "error": [
        "Invalid entity or lack of mod support."
      ],
      "note": [],
      "return": "True on success, otherwise false."
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "The entity index."
      },
      {
        "name": "attachment",
        "type": "int",
        "default": null,
        "description": "The attachment index."
      },
      {
        "name": "origin",
        "type": "float",
        "default": null,
        "description": "Destination vector to store the attachment's origin vector."
      },
      {
        "name": "angles",
        "type": "float",
        "default": null,
        "description": "Destination vector to store the attachment's position angle."
      }
    ],
    "full_declaration": "native bool GetEntityAttachment(int entity, int attachment, float origin[3], float angles[3]);"
  },
  {
    "name": "GameRules_GetProp",
    "type": "native",
    "source_file": "sdktools_gamerules.inc",
    "return_type": "int",
    "comment": "Retrieves an integer value from a property of the gamerules entity.",
    "tags": {
      "param": [
        {
          "name": "prop",
          "description": "Property name."
        },
        {
          "name": "size",
          "description": "Number of bytes to read (valid values are 1, 2, or 4). This value is auto-detected, and the size parameter is only used as a fallback in case detection fails."
        },
        {
          "name": "element",
          "description": "Element # (starting from 0) if property is an array."
        }
      ],
      "error": [
        "Prop type is not an integer, or lack of mod support."
      ],
      "note": [],
      "return": "Value at the given property offset."
    },
    "params": [
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property name."
      },
      {
        "name": "size",
        "type": "int",
        "default": "",
        "description": "Number of bytes to read (valid values are 1, 2, or 4). This value is auto-detected, and the size parameter is only used as a fallback in case detection fails."
      },
      {
        "name": "element",
        "type": "int",
        "default": "",
        "description": "Element # (starting from 0) if property is an array."
      }
    ],
    "full_declaration": "native int GameRules_GetProp(const char[] prop, int size=4, int element=0);"
  },
  {
    "name": "GameRules_SetProp",
    "type": "native",
    "source_file": "sdktools_gamerules.inc",
    "return_type": "void",
    "comment": "Sets an integer value for a property of the gamerules entity.",
    "tags": {
      "param": [
        {
          "name": "prop",
          "description": "Property name."
        },
        {
          "name": "value",
          "description": "Value to set."
        },
        {
          "name": "size",
          "description": "Number of bytes to write (valid values are 1, 2, or 4). This value is auto-detected, and the size parameter is only used as a fallback in case detection fails."
        },
        {
          "name": "element",
          "description": "Element # (starting from 0) if property is an array."
        },
        {
          "name": "changeState",
          "description": "This parameter is ignored."
        }
      ],
      "error": [
        "Prop type is not an integer, or lack of mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property name."
      },
      {
        "name": "value",
        "type": "any",
        "default": null,
        "description": "Value to set."
      },
      {
        "name": "size",
        "type": "int",
        "default": "",
        "description": "Number of bytes to write (valid values are 1, 2, or 4). This value is auto-detected, and the size parameter is only used as a fallback in case detection fails."
      },
      {
        "name": "element",
        "type": "int",
        "default": "",
        "description": "Element # (starting from 0) if property is an array."
      },
      {
        "name": "changeState",
        "type": "bool",
        "default": "",
        "description": "This parameter is ignored."
      }
    ],
    "full_declaration": "native void GameRules_SetProp(const char[] prop, any value, int size=4, int element=0, bool changeState=false);"
  },
  {
    "name": "GameRules_GetPropFloat",
    "type": "native",
    "source_file": "sdktools_gamerules.inc",
    "return_type": "float",
    "comment": "Retrieves a float value from a property of the gamerules entity.",
    "tags": {
      "param": [
        {
          "name": "prop",
          "description": "Property name."
        },
        {
          "name": "element",
          "description": "Element # (starting from 0) if property is an array."
        }
      ],
      "error": [
        "Prop type is not a float, or lack of mod support."
      ],
      "note": [],
      "return": "Value at the given property offset."
    },
    "params": [
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property name."
      },
      {
        "name": "element",
        "type": "int",
        "default": "",
        "description": "Element # (starting from 0) if property is an array."
      }
    ],
    "full_declaration": "native float GameRules_GetPropFloat(const char[] prop, int element=0);"
  },
  {
    "name": "GameRules_SetPropFloat",
    "type": "native",
    "source_file": "sdktools_gamerules.inc",
    "return_type": "void",
    "comment": "Sets a float value for a property of the gamerules entity.",
    "tags": {
      "param": [
        {
          "name": "prop",
          "description": "Property name."
        },
        {
          "name": "value",
          "description": "Value to set."
        },
        {
          "name": "element",
          "description": "Element # (starting from 0) if property is an array."
        },
        {
          "name": "changeState",
          "description": "This parameter is ignored."
        }
      ],
      "error": [
        "Prop type is not a float, or lack of mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property name."
      },
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Value to set."
      },
      {
        "name": "element",
        "type": "int",
        "default": "",
        "description": "Element # (starting from 0) if property is an array."
      },
      {
        "name": "changeState",
        "type": "bool",
        "default": "",
        "description": "This parameter is ignored."
      }
    ],
    "full_declaration": "native void GameRules_SetPropFloat(const char[] prop, float value, int element=0, bool changeState=false);"
  },
  {
    "name": "GameRules_GetPropEnt",
    "type": "native",
    "source_file": "sdktools_gamerules.inc",
    "return_type": "int",
    "comment": "Retrieves a entity index from a property of the gamerules entity.",
    "tags": {
      "param": [
        {
          "name": "prop",
          "description": "Property name."
        },
        {
          "name": "element",
          "description": "Element # (starting from 0) if property is an array."
        }
      ],
      "error": [
        "Prop type is not an entity, or lack of mod support."
      ],
      "note": [],
      "return": "Entity index at the given property. If there is no entity, or the entity is not valid, then -1 is returned."
    },
    "params": [
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property name."
      },
      {
        "name": "element",
        "type": "int",
        "default": "",
        "description": "Element # (starting from 0) if property is an array."
      }
    ],
    "full_declaration": "native int GameRules_GetPropEnt(const char[] prop, int element=0);"
  },
  {
    "name": "GameRules_SetPropEnt",
    "type": "native",
    "source_file": "sdktools_gamerules.inc",
    "return_type": "void",
    "comment": "Sets an entity index for a property of the gamerules entity.",
    "tags": {
      "param": [
        {
          "name": "prop",
          "description": "Property name."
        },
        {
          "name": "other",
          "description": "Entity index to set, or -1 to unset."
        },
        {
          "name": "element",
          "description": "Element # (starting from 0) if property is an array."
        },
        {
          "name": "changeState",
          "description": "This parameter is ignored."
        }
      ],
      "error": [
        "Prop type is not an entity, invalid entity, or lack of mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property name."
      },
      {
        "name": "other",
        "type": "int",
        "default": null,
        "description": "Entity index to set, or -1 to unset."
      },
      {
        "name": "element",
        "type": "int",
        "default": "",
        "description": "Element # (starting from 0) if property is an array."
      },
      {
        "name": "changeState",
        "type": "bool",
        "default": "",
        "description": "This parameter is ignored."
      }
    ],
    "full_declaration": "native void GameRules_SetPropEnt(const char[] prop, int other, int element=0, bool changeState=false);"
  },
  {
    "name": "GameRules_GetPropVector",
    "type": "native",
    "source_file": "sdktools_gamerules.inc",
    "return_type": "void",
    "comment": "Retrieves a vector of floats from the gamerules entity, given a named network property.",
    "tags": {
      "param": [
        {
          "name": "prop",
          "description": "Property name."
        },
        {
          "name": "vec",
          "description": "Vector buffer to store data in."
        },
        {
          "name": "element",
          "description": "Element # (starting from 0) if property is an array."
        }
      ],
      "error": [
        "Prop type is not a vector, or lack of mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property name."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Vector buffer to store data in."
      },
      {
        "name": "element",
        "type": "int",
        "default": "",
        "description": "Element # (starting from 0) if property is an array."
      }
    ],
    "full_declaration": "native void GameRules_GetPropVector(const char[] prop, float vec[3], int element=0);"
  },
  {
    "name": "GameRules_SetPropVector",
    "type": "native",
    "source_file": "sdktools_gamerules.inc",
    "return_type": "void",
    "comment": "Sets a vector of floats in the gamerules entity, given a named network property.",
    "tags": {
      "param": [
        {
          "name": "prop",
          "description": "Property name."
        },
        {
          "name": "vec",
          "description": "Vector to set."
        },
        {
          "name": "element",
          "description": "Element # (starting from 0) if property is an array."
        },
        {
          "name": "changeState",
          "description": "This parameter is ignored."
        }
      ],
      "error": [
        "Prop type is not a vector, or lack of mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property name."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Vector to set."
      },
      {
        "name": "element",
        "type": "int",
        "default": "",
        "description": "Element # (starting from 0) if property is an array."
      },
      {
        "name": "changeState",
        "type": "bool",
        "default": "",
        "description": "This parameter is ignored."
      }
    ],
    "full_declaration": "native void GameRules_SetPropVector(const char[] prop, const float vec[3], int element=0, bool changeState=false);"
  },
  {
    "name": "GameRules_GetPropString",
    "type": "native",
    "source_file": "sdktools_gamerules.inc",
    "return_type": "int",
    "comment": "Gets a gamerules property as a string.",
    "tags": {
      "param": [
        {
          "name": "prop",
          "description": "Property to use."
        },
        {
          "name": "buffer",
          "description": "Destination string buffer."
        },
        {
          "name": "maxlen",
          "description": "Maximum length of output string buffer."
        },
        {
          "name": "element",
          "description": "Element # (starting from 0) if property is an array."
        }
      ],
      "error": [
        "Prop type is not a string, or lack of mod support."
      ],
      "note": [],
      "return": "Number of non-null bytes written."
    },
    "params": [
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property to use."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Destination string buffer."
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "Maximum length of output string buffer."
      },
      {
        "name": "element",
        "type": "int",
        "default": "",
        "description": "Element # (starting from 0) if property is an array."
      }
    ],
    "full_declaration": "native int GameRules_GetPropString(const char[] prop, char[] buffer, int maxlen, int element=0);"
  },
  {
    "name": "GameRules_SetPropString",
    "type": "native",
    "source_file": "sdktools_gamerules.inc",
    "return_type": "int",
    "comment": "Sets a gamerules property as a string.",
    "tags": {
      "param": [
        {
          "name": "prop",
          "description": "Property to use."
        },
        {
          "name": "buffer",
          "description": "String to set."
        },
        {
          "name": "changeState",
          "description": "This parameter is ignored."
        },
        {
          "name": "element",
          "description": "Element # (starting from 0) if property is an array."
        }
      ],
      "error": [
        "Prop type is not a string, or lack of mod support."
      ],
      "note": [],
      "return": "Number of non-null bytes written."
    },
    "params": [
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property to use."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "String to set."
      },
      {
        "name": "changeState",
        "type": "bool",
        "default": "",
        "description": "This parameter is ignored."
      },
      {
        "name": "element",
        "type": "int",
        "default": "",
        "description": "Element # (starting from 0) if property is an array."
      }
    ],
    "full_declaration": "native int GameRules_SetPropString(const char[] prop, const char[] buffer, bool changeState=false, int element=0);"
  },
  {
    "name": "GameRules_GetRoundState",
    "type": "stock",
    "source_file": "sdktools_gamerules.inc",
    "return_type": "RoundState",
    "comment": "Gets the current round state.",
    "tags": {
      "param": [],
      "error": [
        "Game doesn't support round state."
      ],
      "note": [],
      "return": "Round state."
    },
    "params": [],
    "full_declaration": "stock RoundState GameRules_GetRoundState() { \treturn view_as<RoundState>(GameRules_GetProp(\"m_iRoundState\"));"
  },
  {
    "name": "OnPlayerRunCmdPre",
    "type": "forward",
    "source_file": "sdktools_hooks.inc",
    "return_type": "void",
    "comment": "Called when a clients movement buttons are being processed (Read Only)",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Index of the client."
        },
        {
          "name": "buttons",
          "description": "Current commands (as bitflags - see entity_prop_stocks.inc)."
        },
        {
          "name": "impulse",
          "description": "Current impulse command."
        },
        {
          "name": "vel",
          "description": "Players desired velocity."
        },
        {
          "name": "angles",
          "description": "Players desired view angles."
        },
        {
          "name": "weapon",
          "description": "Entity index of the new weapon if player switches weapon, 0 otherwise."
        },
        {
          "name": "subtype",
          "description": "Weapon subtype when selected from a menu."
        },
        {
          "name": "cmdnum",
          "description": "Command number. Increments from the first command sent."
        },
        {
          "name": "tickcount",
          "description": "Tick count. A client's prediction based on the server's GetGameTickCount value."
        },
        {
          "name": "seed",
          "description": "Random seed. Used to determine weapon recoil, spread, and other predicted elements."
        },
        {
          "name": "mouse",
          "description": "Mouse direction (x, y)."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Index of the client."
      },
      {
        "name": "buttons",
        "type": "int",
        "default": null,
        "description": "Current commands (as bitflags - see entity_prop_stocks.inc)."
      },
      {
        "name": "impulse",
        "type": "int",
        "default": null,
        "description": "Current impulse command."
      },
      {
        "name": "vel",
        "type": "float",
        "default": null,
        "description": "Players desired velocity."
      },
      {
        "name": "angles",
        "type": "float",
        "default": null,
        "description": "Players desired view angles."
      },
      {
        "name": "weapon",
        "type": "int",
        "default": null,
        "description": "Entity index of the new weapon if player switches weapon, 0 otherwise."
      },
      {
        "name": "subtype",
        "type": "int",
        "default": null,
        "description": "Weapon subtype when selected from a menu."
      },
      {
        "name": "cmdnum",
        "type": "int",
        "default": null,
        "description": "Command number. Increments from the first command sent."
      },
      {
        "name": "tickcount",
        "type": "int",
        "default": null,
        "description": "Tick count. A client's prediction based on the server's GetGameTickCount value."
      },
      {
        "name": "seed",
        "type": "int",
        "default": null,
        "description": "Random seed. Used to determine weapon recoil, spread, and other predicted elements."
      },
      {
        "name": "mouse",
        "type": "int",
        "default": null,
        "description": "Mouse direction (x, y)."
      }
    ],
    "full_declaration": "forward void OnPlayerRunCmdPre(int client, int buttons, int impulse, const float vel[3], const float angles[3], int weapon, int subtype, int cmdnum, int tickcount, int seed, const int mouse[2]);"
  },
  {
    "name": "OnPlayerRunCmd",
    "type": "forward",
    "source_file": "sdktools_hooks.inc",
    "return_type": "Action",
    "comment": "Called when a clients movement buttons are being processed",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Index of the client."
        },
        {
          "name": "buttons",
          "description": "Copyback buffer containing the current commands (as bitflags - see entity_prop_stocks.inc)."
        },
        {
          "name": "impulse",
          "description": "Copyback buffer containing the current impulse command."
        },
        {
          "name": "vel",
          "description": "Players desired velocity."
        },
        {
          "name": "angles",
          "description": "Players desired view angles."
        },
        {
          "name": "weapon",
          "description": "Entity index of the new weapon if player switches weapon, 0 otherwise."
        },
        {
          "name": "subtype",
          "description": "Weapon subtype when selected from a menu."
        },
        {
          "name": "cmdnum",
          "description": "Command number. Increments from the first command sent."
        },
        {
          "name": "tickcount",
          "description": "Tick count. A client's prediction based on the server's GetGameTickCount value."
        },
        {
          "name": "seed",
          "description": "Random seed. Used to determine weapon recoil, spread, and other predicted elements."
        },
        {
          "name": "mouse",
          "description": "Mouse direction (x, y)."
        }
      ],
      "error": [],
      "note": [
        "To see if all 11 params are available, use FeatureType_Capability and FEATURECAP_PLAYERRUNCMD_11PARAMS."
      ],
      "return": "Plugin_Handled to block the commands from being processed, Plugin_Continue otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Index of the client."
      },
      {
        "name": "buttons",
        "type": "int",
        "default": null,
        "description": "Copyback buffer containing the current commands (as bitflags - see entity_prop_stocks.inc)."
      },
      {
        "name": "impulse",
        "type": "int",
        "default": null,
        "description": "Copyback buffer containing the current impulse command."
      },
      {
        "name": "vel",
        "type": "float",
        "default": null,
        "description": "Players desired velocity."
      },
      {
        "name": "angles",
        "type": "float",
        "default": null,
        "description": "Players desired view angles."
      },
      {
        "name": "weapon",
        "type": "int",
        "default": null,
        "description": "Entity index of the new weapon if player switches weapon, 0 otherwise."
      },
      {
        "name": "subtype",
        "type": "int",
        "default": null,
        "description": "Weapon subtype when selected from a menu."
      },
      {
        "name": "cmdnum",
        "type": "int",
        "default": null,
        "description": "Command number. Increments from the first command sent."
      },
      {
        "name": "tickcount",
        "type": "int",
        "default": null,
        "description": "Tick count. A client's prediction based on the server's GetGameTickCount value."
      },
      {
        "name": "seed",
        "type": "int",
        "default": null,
        "description": "Random seed. Used to determine weapon recoil, spread, and other predicted elements."
      },
      {
        "name": "mouse",
        "type": "int",
        "default": null,
        "description": "Mouse direction (x, y)."
      }
    ],
    "full_declaration": "forward Action OnPlayerRunCmd(int client, int &buttons, int &impulse, float vel[3], float angles[3], int &weapon, int &subtype, int &cmdnum, int &tickcount, int &seed, int mouse[2]);"
  },
  {
    "name": "OnPlayerRunCmdPost",
    "type": "forward",
    "source_file": "sdktools_hooks.inc",
    "return_type": "void",
    "comment": "Called after a clients movement buttons were processed.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Index of the client."
        },
        {
          "name": "buttons",
          "description": "The current commands (as bitflags - see entity_prop_stocks.inc)."
        },
        {
          "name": "impulse",
          "description": "The current impulse command."
        },
        {
          "name": "vel",
          "description": "Players desired velocity."
        },
        {
          "name": "angles",
          "description": "Players desired view angles."
        },
        {
          "name": "weapon",
          "description": "Entity index of the new weapon if player switches weapon, 0 otherwise."
        },
        {
          "name": "subtype",
          "description": "Weapon subtype when selected from a menu."
        },
        {
          "name": "cmdnum",
          "description": "Command number. Increments from the first command sent."
        },
        {
          "name": "tickcount",
          "description": "Tick count. A client's prediction based on the server's GetGameTickCount value."
        },
        {
          "name": "seed",
          "description": "Random seed. Used to determine weapon recoil, spread, and other predicted elements."
        },
        {
          "name": "mouse",
          "description": "Mouse direction (x, y)."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Index of the client."
      },
      {
        "name": "buttons",
        "type": "int",
        "default": null,
        "description": "The current commands (as bitflags - see entity_prop_stocks.inc)."
      },
      {
        "name": "impulse",
        "type": "int",
        "default": null,
        "description": "The current impulse command."
      },
      {
        "name": "vel",
        "type": "float",
        "default": null,
        "description": "Players desired velocity."
      },
      {
        "name": "angles",
        "type": "float",
        "default": null,
        "description": "Players desired view angles."
      },
      {
        "name": "weapon",
        "type": "int",
        "default": null,
        "description": "Entity index of the new weapon if player switches weapon, 0 otherwise."
      },
      {
        "name": "subtype",
        "type": "int",
        "default": null,
        "description": "Weapon subtype when selected from a menu."
      },
      {
        "name": "cmdnum",
        "type": "int",
        "default": null,
        "description": "Command number. Increments from the first command sent."
      },
      {
        "name": "tickcount",
        "type": "int",
        "default": null,
        "description": "Tick count. A client's prediction based on the server's GetGameTickCount value."
      },
      {
        "name": "seed",
        "type": "int",
        "default": null,
        "description": "Random seed. Used to determine weapon recoil, spread, and other predicted elements."
      },
      {
        "name": "mouse",
        "type": "int",
        "default": null,
        "description": "Mouse direction (x, y)."
      }
    ],
    "full_declaration": "forward void OnPlayerRunCmdPost(int client, int buttons, int impulse, const float vel[3], const float angles[3], int weapon, int subtype, int cmdnum, int tickcount, int seed, const int mouse[2]);"
  },
  {
    "name": "OnFileSend",
    "type": "forward",
    "source_file": "sdktools_hooks.inc",
    "return_type": "Action",
    "comment": "Called when a client requests a file from the server.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "sFile",
          "description": "Requested file path."
        }
      ],
      "error": [],
      "note": [],
      "return": "Plugin_Handled to block the transfer, Plugin_Continue to let it proceed."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "sFile",
        "type": "char[]",
        "default": null,
        "description": "Requested file path."
      }
    ],
    "full_declaration": "forward Action OnFileSend(int client, const char[] sFile);"
  },
  {
    "name": "OnFileReceive",
    "type": "forward",
    "source_file": "sdktools_hooks.inc",
    "return_type": "Action",
    "comment": "Called when a client sends a file to the server.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "sFile",
          "description": "Requested file path."
        }
      ],
      "error": [],
      "note": [],
      "return": "Plugin_Handled to block the transfer, Plugin_Continue to let it proceed."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "sFile",
        "type": "char[]",
        "default": null,
        "description": "Requested file path."
      }
    ],
    "full_declaration": "forward Action OnFileReceive(int client, const char[] sFile);"
  },
  {
    "name": "PrefetchSound",
    "type": "native",
    "source_file": "sdktools_sound.inc",
    "return_type": "void",
    "comment": "Prefetches a sound.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Sound file name relative to the \"sound\" folder."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Sound file name relative to the \"sound\" folder."
      }
    ],
    "full_declaration": "native void PrefetchSound(const char[] name);"
  },
  {
    "name": "GetSoundDuration",
    "type": "native",
    "source_file": "sdktools_sound.inc",
    "return_type": "float",
    "comment": "This function is not known to work, and may crash.  You should\nnot use it.  It is provided for backwards compatibility only.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Sound file name relative to the \"sound\" folder."
        }
      ],
      "error": [],
      "note": [],
      "return": "Duration in seconds.",
      "deprecated": [
        "Does not work, may crash."
      ]
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Sound file name relative to the \"sound\" folder."
      }
    ],
    "full_declaration": "native float GetSoundDuration(const char[] name);"
  },
  {
    "name": "EmitAmbientSound",
    "type": "native",
    "source_file": "sdktools_sound.inc",
    "return_type": "void",
    "comment": "Emits an ambient sound.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Sound file name relative to the \"sound\" folder."
        },
        {
          "name": "pos",
          "description": "Origin of sound."
        },
        {
          "name": "entity",
          "description": "Entity index to associate sound with."
        },
        {
          "name": "level",
          "description": "Sound level (from 0 to 255)."
        },
        {
          "name": "flags",
          "description": "Sound flags."
        },
        {
          "name": "vol",
          "description": "Volume (from 0.0 to 1.0)."
        },
        {
          "name": "pitch",
          "description": "Pitch (from 0 to 255)."
        },
        {
          "name": "delay",
          "description": "Play delay."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Sound file name relative to the \"sound\" folder."
      },
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Origin of sound."
      },
      {
        "name": "entity",
        "type": "int",
        "default": "",
        "description": "Entity index to associate sound with."
      },
      {
        "name": "level",
        "type": "int",
        "default": "",
        "description": "Sound level (from 0 to 255)."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Sound flags."
      },
      {
        "name": "vol",
        "type": "float",
        "default": "",
        "description": "Volume (from 0.0 to 1.0)."
      },
      {
        "name": "pitch",
        "type": "int",
        "default": "",
        "description": "Pitch (from 0 to 255)."
      },
      {
        "name": "delay",
        "type": "float",
        "default": "",
        "description": "Play delay."
      }
    ],
    "full_declaration": "native void EmitAmbientSound(const char[] name, \t\t\t\t\t\tconst float pos[3], \t\t\t\t\t\tint entity = SOUND_FROM_WORLD, \t\t\t\t\t\tint level = SNDLEVEL_NORMAL, \t\t\t\t\t\tint flags = SND_NOFLAGS, \t\t\t\t\t\tfloat vol = SNDVOL_NORMAL, \t\t\t\t\t\tint pitch = SNDPITCH_NORMAL, \t\t\t\t\t\tfloat delay = 0.0);"
  },
  {
    "name": "FadeClientVolume",
    "type": "native",
    "source_file": "sdktools_sound.inc",
    "return_type": "void",
    "comment": "Fades a client's volume level toward silence or a given percentage.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "percent",
          "description": "Fade percentage."
        },
        {
          "name": "outtime",
          "description": "Fade out time, in seconds."
        },
        {
          "name": "holdtime",
          "description": "Hold time, in seconds."
        },
        {
          "name": "intime",
          "description": "Fade in time, in seconds."
        }
      ],
      "error": [
        "Invalid client index or client not in game."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "percent",
        "type": "float",
        "default": null,
        "description": "Fade percentage."
      },
      {
        "name": "outtime",
        "type": "float",
        "default": null,
        "description": "Fade out time, in seconds."
      },
      {
        "name": "holdtime",
        "type": "float",
        "default": null,
        "description": "Hold time, in seconds."
      },
      {
        "name": "intime",
        "type": "float",
        "default": null,
        "description": "Fade in time, in seconds."
      }
    ],
    "full_declaration": "native void FadeClientVolume(int client, float percent, float outtime, float holdtime, float intime);"
  },
  {
    "name": "StopSound",
    "type": "native",
    "source_file": "sdktools_sound.inc",
    "return_type": "void",
    "comment": "Stops a sound.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index."
        },
        {
          "name": "channel",
          "description": "Channel number."
        },
        {
          "name": "name",
          "description": "Sound file name relative to the \"sound\" folder."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      },
      {
        "name": "channel",
        "type": "int",
        "default": null,
        "description": "Channel number."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Sound file name relative to the \"sound\" folder."
      }
    ],
    "full_declaration": "native void StopSound(int entity, int channel, const char[] name);"
  },
  {
    "name": "EmitSound",
    "type": "native",
    "source_file": "sdktools_sound.inc",
    "return_type": "void",
    "comment": "Emits a sound to a list of clients.",
    "tags": {
      "param": [
        {
          "name": "clients",
          "description": "Array of client indexes."
        },
        {
          "name": "numClients",
          "description": "Number of clients in the array."
        },
        {
          "name": "sample",
          "description": "Sound file name relative to the \"sound\" folder."
        },
        {
          "name": "entity",
          "description": "Entity to emit from."
        },
        {
          "name": "channel",
          "description": "Channel to emit with."
        },
        {
          "name": "level",
          "description": "Sound level."
        },
        {
          "name": "flags",
          "description": "Sound flags."
        },
        {
          "name": "volume",
          "description": "Sound volume."
        },
        {
          "name": "pitch",
          "description": "Sound pitch."
        },
        {
          "name": "speakerentity",
          "description": "Unknown."
        },
        {
          "name": "origin",
          "description": "Sound origin."
        },
        {
          "name": "dir",
          "description": "Sound direction."
        },
        {
          "name": "updatePos",
          "description": "Unknown (updates positions?)"
        },
        {
          "name": "soundtime",
          "description": "Alternate time to play sound for."
        }
      ],
      "error": [
        "Invalid client index or client not in game."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "clients",
        "type": "int[]",
        "default": null,
        "description": "Array of client indexes."
      },
      {
        "name": "numClients",
        "type": "int",
        "default": null,
        "description": "Number of clients in the array."
      },
      {
        "name": "sample",
        "type": "char[]",
        "default": null,
        "description": "Sound file name relative to the \"sound\" folder."
      },
      {
        "name": "entity",
        "type": "int",
        "default": "",
        "description": "Entity to emit from."
      },
      {
        "name": "channel",
        "type": "int",
        "default": "",
        "description": "Channel to emit with."
      },
      {
        "name": "level",
        "type": "int",
        "default": "",
        "description": "Sound level."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Sound flags."
      },
      {
        "name": "volume",
        "type": "float",
        "default": "",
        "description": "Sound volume."
      },
      {
        "name": "pitch",
        "type": "int",
        "default": "",
        "description": "Sound pitch."
      },
      {
        "name": "speakerentity",
        "type": "int",
        "default": "",
        "description": "Unknown."
      },
      {
        "name": "origin",
        "type": "float",
        "default": null,
        "description": "Sound origin."
      },
      {
        "name": "dir",
        "type": "float",
        "default": null,
        "description": "Sound direction."
      },
      {
        "name": "updatePos",
        "type": "bool",
        "default": "",
        "description": "Unknown (updates positions?)"
      },
      {
        "name": "soundtime",
        "type": "float",
        "default": "",
        "description": "Alternate time to play sound for."
      }
    ],
    "full_declaration": "native void EmitSound(const int[] clients, \t\t\t\t int numClients, \t\t\t\t const char[] sample, \t\t\t\t int entity = SOUND_FROM_PLAYER, \t\t\t\t int channel = SNDCHAN_AUTO, \t\t\t\t int level = SNDLEVEL_NORMAL, \t\t\t\t int flags = SND_NOFLAGS, \t\t\t\t float volume = SNDVOL_NORMAL, \t\t\t\t int pitch = SNDPITCH_NORMAL, \t\t\t\t int speakerentity = -1, \t\t\t\t const float origin[3] = NULL_VECTOR, \t\t\t\t const float dir[3] = NULL_VECTOR, \t\t\t\t bool updatePos = true, \t\t\t\t float soundtime = 0.0, \t\t\t\t any ...);"
  },
  {
    "name": "EmitSoundEntry",
    "type": "native",
    "source_file": "sdktools_sound.inc",
    "return_type": "void",
    "comment": "Emits a sound or game sound to a list of clients using the latest version of the engine sound interface.\nThis native is only available in engines that are greater than or equal to Portal 2.",
    "tags": {
      "param": [
        {
          "name": "clients",
          "description": "Array of client indexes."
        },
        {
          "name": "numClients",
          "description": "Number of clients in the array."
        },
        {
          "name": "soundEntry",
          "description": "Sound entry name."
        },
        {
          "name": "sample",
          "description": "Sound file name relative to the \"sound\" folder."
        },
        {
          "name": "entity",
          "description": "Entity to emit from."
        },
        {
          "name": "channel",
          "description": "Channel to emit with."
        },
        {
          "name": "level",
          "description": "Sound level."
        },
        {
          "name": "seed",
          "description": "Sound seed."
        },
        {
          "name": "flags",
          "description": "Sound flags."
        },
        {
          "name": "volume",
          "description": "Sound volume."
        },
        {
          "name": "pitch",
          "description": "Sound pitch."
        },
        {
          "name": "speakerentity",
          "description": "Unknown."
        },
        {
          "name": "origin",
          "description": "Sound origin."
        },
        {
          "name": "dir",
          "description": "Sound direction."
        },
        {
          "name": "updatePos",
          "description": "Unknown (updates positions?)"
        },
        {
          "name": "soundtime",
          "description": "Alternate time to play sound for."
        }
      ],
      "error": [
        "Invalid client index, client not in game, or lack of mod support."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "clients",
        "type": "int[]",
        "default": null,
        "description": "Array of client indexes."
      },
      {
        "name": "numClients",
        "type": "int",
        "default": null,
        "description": "Number of clients in the array."
      },
      {
        "name": "soundEntry",
        "type": "char[]",
        "default": null,
        "description": "Sound entry name."
      },
      {
        "name": "sample",
        "type": "char[]",
        "default": null,
        "description": "Sound file name relative to the \"sound\" folder."
      },
      {
        "name": "entity",
        "type": "int",
        "default": "",
        "description": "Entity to emit from."
      },
      {
        "name": "channel",
        "type": "int",
        "default": "",
        "description": "Channel to emit with."
      },
      {
        "name": "level",
        "type": "int",
        "default": "",
        "description": "Sound level."
      },
      {
        "name": "seed",
        "type": "int",
        "default": "",
        "description": "Sound seed."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Sound flags."
      },
      {
        "name": "volume",
        "type": "float",
        "default": "",
        "description": "Sound volume."
      },
      {
        "name": "pitch",
        "type": "int",
        "default": "",
        "description": "Sound pitch."
      },
      {
        "name": "speakerentity",
        "type": "int",
        "default": "",
        "description": "Unknown."
      },
      {
        "name": "origin",
        "type": "float",
        "default": null,
        "description": "Sound origin."
      },
      {
        "name": "dir",
        "type": "float",
        "default": null,
        "description": "Sound direction."
      },
      {
        "name": "updatePos",
        "type": "bool",
        "default": "",
        "description": "Unknown (updates positions?)"
      },
      {
        "name": "soundtime",
        "type": "float",
        "default": "",
        "description": "Alternate time to play sound for."
      }
    ],
    "full_declaration": "native void EmitSoundEntry(const int[] clients, \t\t\t\t int numClients, \t\t\t\t const char[] soundEntry, \t\t\t\t const char[] sample, \t\t\t\t int entity = SOUND_FROM_PLAYER, \t\t\t\t int channel = SNDCHAN_AUTO, \t\t\t\t int level = SNDLEVEL_NORMAL, \t\t\t\t int seed = 0, \t\t\t\t int flags = SND_NOFLAGS, \t\t\t\t float volume = SNDVOL_NORMAL, \t\t\t\t int pitch = SNDPITCH_NORMAL, \t\t\t\t int speakerentity = -1, \t\t\t\t const float origin[3] = NULL_VECTOR, \t\t\t\t const float dir[3] = NULL_VECTOR, \t\t\t\t bool updatePos = true, \t\t\t\t float soundtime = 0.0, \t\t\t\t any ...);"
  },
  {
    "name": "EmitSentence",
    "type": "native",
    "source_file": "sdktools_sound.inc",
    "return_type": "void",
    "comment": "Emits a sentence to a list of clients.",
    "tags": {
      "param": [
        {
          "name": "clients",
          "description": "Array of client indexes."
        },
        {
          "name": "numClients",
          "description": "Number of clients in the array."
        },
        {
          "name": "sentence",
          "description": "Sentence index (from PrecacheSentenceFile)."
        },
        {
          "name": "entity",
          "description": "Entity to emit from."
        },
        {
          "name": "channel",
          "description": "Channel to emit with."
        },
        {
          "name": "level",
          "description": "Sound level."
        },
        {
          "name": "flags",
          "description": "Sound flags."
        },
        {
          "name": "volume",
          "description": "Sound volume."
        },
        {
          "name": "pitch",
          "description": "Sound pitch."
        },
        {
          "name": "speakerentity",
          "description": "Unknown."
        },
        {
          "name": "origin",
          "description": "Sound origin."
        },
        {
          "name": "dir",
          "description": "Sound direction."
        },
        {
          "name": "updatePos",
          "description": "Unknown (updates positions?)"
        },
        {
          "name": "soundtime",
          "description": "Alternate time to play sound for."
        }
      ],
      "error": [
        "Invalid client index or client not in game."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "clients",
        "type": "int[]",
        "default": null,
        "description": "Array of client indexes."
      },
      {
        "name": "numClients",
        "type": "int",
        "default": null,
        "description": "Number of clients in the array."
      },
      {
        "name": "sentence",
        "type": "int",
        "default": null,
        "description": "Sentence index (from PrecacheSentenceFile)."
      },
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity to emit from."
      },
      {
        "name": "channel",
        "type": "int",
        "default": "",
        "description": "Channel to emit with."
      },
      {
        "name": "level",
        "type": "int",
        "default": "",
        "description": "Sound level."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Sound flags."
      },
      {
        "name": "volume",
        "type": "float",
        "default": "",
        "description": "Sound volume."
      },
      {
        "name": "pitch",
        "type": "int",
        "default": "",
        "description": "Sound pitch."
      },
      {
        "name": "speakerentity",
        "type": "int",
        "default": "",
        "description": "Unknown."
      },
      {
        "name": "origin",
        "type": "float",
        "default": null,
        "description": "Sound origin."
      },
      {
        "name": "dir",
        "type": "float",
        "default": null,
        "description": "Sound direction."
      },
      {
        "name": "updatePos",
        "type": "bool",
        "default": "",
        "description": "Unknown (updates positions?)"
      },
      {
        "name": "soundtime",
        "type": "float",
        "default": "",
        "description": "Alternate time to play sound for."
      }
    ],
    "full_declaration": "native void EmitSentence(const int[] clients, \t\t\t\t int numClients, \t\t\t\t int sentence, \t\t\t\t int entity, \t\t\t\t int channel = SNDCHAN_AUTO, \t\t\t\t int level = SNDLEVEL_NORMAL, \t\t\t\t int flags = SND_NOFLAGS, \t\t\t\t float volume = SNDVOL_NORMAL, \t\t\t\t int pitch = SNDPITCH_NORMAL, \t\t\t\t int speakerentity = -1, \t\t\t\t const float origin[3] = NULL_VECTOR, \t\t\t\t const float dir[3] = NULL_VECTOR, \t\t\t\t bool updatePos = true, \t\t\t\t float soundtime = 0.0, \t\t\t\t any ...);"
  },
  {
    "name": "GetDistGainFromSoundLevel",
    "type": "native",
    "source_file": "sdktools_sound.inc",
    "return_type": "float",
    "comment": "Calculates gain of sound on given distance with given sound level in decibel",
    "tags": {
      "param": [
        {
          "name": "soundlevel",
          "description": "decibel of sound, like SNDLEVEL_NORMAL or integer value"
        },
        {
          "name": "distance",
          "description": "distance of sound to calculate, not meter or feet, but Source Engine`s normal Coordinate unit"
        }
      ],
      "error": [],
      "note": [],
      "return": "gain of sound. you can multiply this with original sound`s volume to calculate volume on given distance"
    },
    "params": [
      {
        "name": "soundlevel",
        "type": "int",
        "default": null,
        "description": "decibel of sound, like SNDLEVEL_NORMAL or integer value"
      },
      {
        "name": "distance",
        "type": "float",
        "default": null,
        "description": "distance of sound to calculate, not meter or feet, but Source Engine`s normal Coordinate unit"
      }
    ],
    "full_declaration": "native float GetDistGainFromSoundLevel(int soundlevel, float distance);"
  },
  {
    "name": "AddAmbientSoundHook",
    "type": "native",
    "source_file": "sdktools_sound.inc",
    "return_type": "void",
    "comment": "Hooks all played ambient sounds.",
    "tags": {
      "param": [
        {
          "name": "hook",
          "description": "Function to use as a hook."
        }
      ],
      "error": [
        "Invalid function hook."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hook",
        "type": "AmbientSHook",
        "default": null,
        "description": "Function to use as a hook."
      }
    ],
    "full_declaration": "native void AddAmbientSoundHook(AmbientSHook hook);"
  },
  {
    "name": "AddNormalSoundHook",
    "type": "native",
    "source_file": "sdktools_sound.inc",
    "return_type": "void",
    "comment": "Hooks all played normal sounds.",
    "tags": {
      "param": [
        {
          "name": "hook",
          "description": "Function to use as a hook."
        }
      ],
      "error": [
        "Invalid function hook."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hook",
        "type": "NormalSHook",
        "default": null,
        "description": "Function to use as a hook."
      }
    ],
    "full_declaration": "native void AddNormalSoundHook(NormalSHook hook);"
  },
  {
    "name": "RemoveAmbientSoundHook",
    "type": "native",
    "source_file": "sdktools_sound.inc",
    "return_type": "void",
    "comment": "Unhooks all played ambient sounds.",
    "tags": {
      "param": [
        {
          "name": "hook",
          "description": "Function used for the hook."
        }
      ],
      "error": [
        "Invalid function hook."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hook",
        "type": "AmbientSHook",
        "default": null,
        "description": "Function used for the hook."
      }
    ],
    "full_declaration": "native void RemoveAmbientSoundHook(AmbientSHook hook);"
  },
  {
    "name": "RemoveNormalSoundHook",
    "type": "native",
    "source_file": "sdktools_sound.inc",
    "return_type": "void",
    "comment": "Unhooks all played normal sounds.",
    "tags": {
      "param": [
        {
          "name": "hook",
          "description": "Function used for the hook."
        }
      ],
      "error": [
        "Invalid function hook."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hook",
        "type": "NormalSHook",
        "default": null,
        "description": "Function used for the hook."
      }
    ],
    "full_declaration": "native void RemoveNormalSoundHook(NormalSHook hook);"
  },
  {
    "name": "EmitSoundToClient",
    "type": "stock",
    "source_file": "sdktools_sound.inc",
    "return_type": "void",
    "comment": "Wrapper to emit sound to one client.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "sample",
          "description": "Sound file name relative to the \"sound\" folder."
        },
        {
          "name": "entity",
          "description": "Entity to emit from."
        },
        {
          "name": "channel",
          "description": "Channel to emit with."
        },
        {
          "name": "level",
          "description": "Sound level."
        },
        {
          "name": "flags",
          "description": "Sound flags."
        },
        {
          "name": "volume",
          "description": "Sound volume."
        },
        {
          "name": "pitch",
          "description": "Sound pitch."
        },
        {
          "name": "speakerentity",
          "description": "Unknown."
        },
        {
          "name": "origin",
          "description": "Sound origin."
        },
        {
          "name": "dir",
          "description": "Sound direction."
        },
        {
          "name": "updatePos",
          "description": "Unknown (updates positions?)"
        },
        {
          "name": "soundtime",
          "description": "Alternate time to play sound for."
        }
      ],
      "error": [
        "Invalid client index or client not in game."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "sample",
        "type": "char[]",
        "default": null,
        "description": "Sound file name relative to the \"sound\" folder."
      },
      {
        "name": "entity",
        "type": "int",
        "default": "",
        "description": "Entity to emit from."
      },
      {
        "name": "channel",
        "type": "int",
        "default": "",
        "description": "Channel to emit with."
      },
      {
        "name": "level",
        "type": "int",
        "default": "",
        "description": "Sound level."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Sound flags."
      },
      {
        "name": "volume",
        "type": "float",
        "default": "",
        "description": "Sound volume."
      },
      {
        "name": "pitch",
        "type": "int",
        "default": "",
        "description": "Sound pitch."
      },
      {
        "name": "speakerentity",
        "type": "int",
        "default": "",
        "description": "Unknown."
      },
      {
        "name": "origin",
        "type": "float",
        "default": null,
        "description": "Sound origin."
      },
      {
        "name": "dir",
        "type": "float",
        "default": null,
        "description": "Sound direction."
      },
      {
        "name": "updatePos",
        "type": "bool",
        "default": "",
        "description": "Unknown (updates positions?)"
      },
      {
        "name": "soundtime",
        "type": "float",
        "default": "",
        "description": "Alternate time to play sound for."
      }
    ],
    "full_declaration": "stock void EmitSoundToClient(int client, \t\t\t\t const char[] sample, \t\t\t\t int entity = SOUND_FROM_PLAYER, \t\t\t\t int channel = SNDCHAN_AUTO, \t\t\t\t int level = SNDLEVEL_NORMAL, \t\t\t\t int flags = SND_NOFLAGS, \t\t\t\t float volume = SNDVOL_NORMAL, \t\t\t\t int pitch = SNDPITCH_NORMAL, \t\t\t\t int speakerentity = -1, \t\t\t\t const float origin[3] = NULL_VECTOR, \t\t\t\t const float dir[3] = NULL_VECTOR, \t\t\t\t bool updatePos = true, \t\t\t\t float soundtime = 0.0) { \tint clients[1]; \tclients[0] = client; \t/* Save some work for SDKTools and remove SOUND_FROM_PLAYER references */ \tentity = (entity == SOUND_FROM_PLAYER) ? client : entity; \tEmitSound(clients, 1, sample, entity, channel, \t\tlevel, flags, volume, pitch, speakerentity, \t\torigin, dir, updatePos, soundtime);"
  },
  {
    "name": "EmitSoundToAll",
    "type": "stock",
    "source_file": "sdktools_sound.inc",
    "return_type": "void",
    "comment": "Wrapper to emit sound to all clients.",
    "tags": {
      "param": [
        {
          "name": "sample",
          "description": "Sound file name relative to the \"sound\" folder."
        },
        {
          "name": "entity",
          "description": "Entity to emit from."
        },
        {
          "name": "channel",
          "description": "Channel to emit with."
        },
        {
          "name": "level",
          "description": "Sound level."
        },
        {
          "name": "flags",
          "description": "Sound flags."
        },
        {
          "name": "volume",
          "description": "Sound volume."
        },
        {
          "name": "pitch",
          "description": "Sound pitch."
        },
        {
          "name": "speakerentity",
          "description": "Unknown."
        },
        {
          "name": "origin",
          "description": "Sound origin."
        },
        {
          "name": "dir",
          "description": "Sound direction."
        },
        {
          "name": "updatePos",
          "description": "Unknown (updates positions?)"
        },
        {
          "name": "soundtime",
          "description": "Alternate time to play sound for."
        }
      ],
      "error": [
        "Invalid client index."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "sample",
        "type": "char[]",
        "default": null,
        "description": "Sound file name relative to the \"sound\" folder."
      },
      {
        "name": "entity",
        "type": "int",
        "default": "",
        "description": "Entity to emit from."
      },
      {
        "name": "channel",
        "type": "int",
        "default": "",
        "description": "Channel to emit with."
      },
      {
        "name": "level",
        "type": "int",
        "default": "",
        "description": "Sound level."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Sound flags."
      },
      {
        "name": "volume",
        "type": "float",
        "default": "",
        "description": "Sound volume."
      },
      {
        "name": "pitch",
        "type": "int",
        "default": "",
        "description": "Sound pitch."
      },
      {
        "name": "speakerentity",
        "type": "int",
        "default": "",
        "description": "Unknown."
      },
      {
        "name": "origin",
        "type": "float",
        "default": null,
        "description": "Sound origin."
      },
      {
        "name": "dir",
        "type": "float",
        "default": null,
        "description": "Sound direction."
      },
      {
        "name": "updatePos",
        "type": "bool",
        "default": "",
        "description": "Unknown (updates positions?)"
      },
      {
        "name": "soundtime",
        "type": "float",
        "default": "",
        "description": "Alternate time to play sound for."
      }
    ],
    "full_declaration": "stock void EmitSoundToAll(const char[] sample, \t\t\t\t int entity = SOUND_FROM_PLAYER, \t\t\t\t int channel = SNDCHAN_AUTO, \t\t\t\t int level = SNDLEVEL_NORMAL, \t\t\t\t int flags = SND_NOFLAGS, \t\t\t\t float volume = SNDVOL_NORMAL, \t\t\t\t int pitch = SNDPITCH_NORMAL, \t\t\t\t int speakerentity = -1, \t\t\t\t const float origin[3] = NULL_VECTOR, \t\t\t\t const float dir[3] = NULL_VECTOR, \t\t\t\t bool updatePos = true, \t\t\t\t float soundtime = 0.0) { \tint[] clients = new int[MaxClients]; \tint total = 0;  \tfor (int i=1; i<=MaxClients; i++) \t{ \t\tif (IsClientInGame(i)) \t\t{ \t\t\tclients[total++] = i; \t\t} \t}  \tif (total) \t{ \t\tEmitSound(clients, total, sample, entity, channel, \t\t\tlevel, flags, volume, pitch, speakerentity, \t\t\torigin, dir, updatePos, soundtime);"
  },
  {
    "name": "ATTN_TO_SNDLEVEL",
    "type": "stock",
    "source_file": "sdktools_sound.inc",
    "return_type": "int",
    "comment": "Converts an attenuation value to a sound level.\nThis function is from the HL2SDK.",
    "tags": {
      "param": [
        {
          "name": "attn",
          "description": "Attenuation value."
        }
      ],
      "error": [],
      "note": [],
      "return": "Integer sound level."
    },
    "params": [
      {
        "name": "attn",
        "type": "float",
        "default": null,
        "description": "Attenuation value."
      }
    ],
    "full_declaration": "stock int ATTN_TO_SNDLEVEL(float attn) { \tif (attn > 0.0) \t{ \t\treturn RoundFloat(50.0 + (20.0 / attn));"
  },
  {
    "name": "GetGameSoundParams",
    "type": "native",
    "source_file": "sdktools_sound.inc",
    "return_type": "bool",
    "comment": "Retrieves the parameters for a game sound.\n\nGame sounds are found in a game's scripts/game_sound.txt or other files\nreferenced from it\n\nNote that if a game sound has a rndwave section, one of them will be returned\nat random.",
    "tags": {
      "param": [
        {
          "name": "gameSound",
          "description": "Name of game sound."
        },
        {
          "name": "channel",
          "description": "Channel to emit with."
        },
        {
          "name": "level",
          "description": "Sound level."
        },
        {
          "name": "volume",
          "description": "Sound volume."
        },
        {
          "name": "pitch",
          "description": "Sound pitch."
        },
        {
          "name": "sample",
          "description": "Sound file name relative to the \"sound\" folder."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of sample string buffer."
        },
        {
          "name": "entity",
          "description": "Entity the sound is being emitted from."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if the sound was successfully retrieved, false if it was not found"
    },
    "params": [
      {
        "name": "gameSound",
        "type": "char[]",
        "default": null,
        "description": "Name of game sound."
      },
      {
        "name": "channel",
        "type": "int",
        "default": null,
        "description": "Channel to emit with."
      },
      {
        "name": "soundLevel",
        "type": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "volume",
        "type": "float",
        "default": null,
        "description": "Sound volume."
      },
      {
        "name": "pitch",
        "type": "int",
        "default": null,
        "description": "Sound pitch."
      },
      {
        "name": "sample",
        "type": "char[]",
        "default": null,
        "description": "Sound file name relative to the \"sound\" folder."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of sample string buffer."
      },
      {
        "name": "entity",
        "type": "int",
        "default": "",
        "description": "Entity the sound is being emitted from."
      }
    ],
    "full_declaration": "native bool GetGameSoundParams(const char[] gameSound, \t\t\t\tint &channel, \t\t\t\tint &soundLevel, \t\t\t\tfloat &volume, \t\t\t\tint &pitch, \t\t\t\tchar[] sample, \t\t\t\tint maxlength, \t\t\t\tint entity=SOUND_FROM_PLAYER);"
  },
  {
    "name": "EmitGameSound",
    "type": "stock",
    "source_file": "sdktools_sound.inc",
    "return_type": "bool",
    "comment": "Emits a game sound to a list of clients.\n\nGame sounds are found in a game's scripts/game_sound.txt or other files\nreferenced from it\n\nNote that if a game sound has a rndwave section, one of them will be returned\nat random.",
    "tags": {
      "param": [
        {
          "name": "clients",
          "description": "Array of client indexes."
        },
        {
          "name": "numClients",
          "description": "Number of clients in the array."
        },
        {
          "name": "gameSound",
          "description": "Name of game sound."
        },
        {
          "name": "entity",
          "description": "Entity to emit from."
        },
        {
          "name": "flags",
          "description": "Sound flags."
        },
        {
          "name": "speakerentity",
          "description": "Unknown."
        },
        {
          "name": "origin",
          "description": "Sound origin."
        },
        {
          "name": "dir",
          "description": "Sound direction."
        },
        {
          "name": "updatePos",
          "description": "Unknown (updates positions?)"
        },
        {
          "name": "soundtime",
          "description": "Alternate time to play sound for."
        }
      ],
      "error": [
        "Invalid client index or client not in game."
      ],
      "note": [],
      "return": "True if the sound was played successfully, false if it failed"
    },
    "params": [
      {
        "name": "clients",
        "type": "int[]",
        "default": null,
        "description": "Array of client indexes."
      },
      {
        "name": "numClients",
        "type": "int",
        "default": null,
        "description": "Number of clients in the array."
      },
      {
        "name": "gameSound",
        "type": "char[]",
        "default": null,
        "description": "Name of game sound."
      },
      {
        "name": "entity",
        "type": "int",
        "default": "",
        "description": "Entity to emit from."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Sound flags."
      },
      {
        "name": "speakerentity",
        "type": "int",
        "default": "",
        "description": "Unknown."
      },
      {
        "name": "origin",
        "type": "float",
        "default": null,
        "description": "Sound origin."
      },
      {
        "name": "dir",
        "type": "float",
        "default": null,
        "description": "Sound direction."
      },
      {
        "name": "updatePos",
        "type": "bool",
        "default": "",
        "description": "Unknown (updates positions?)"
      },
      {
        "name": "soundtime",
        "type": "float",
        "default": "",
        "description": "Alternate time to play sound for."
      }
    ],
    "full_declaration": "stock bool EmitGameSound(const int[] clients, \t\t\t\tint numClients, \t\t\t\tconst char[] gameSound, \t\t\t\tint entity = SOUND_FROM_PLAYER, \t\t\t\tint flags = SND_NOFLAGS, \t\t\t\tint speakerentity = -1, \t\t\t\tconst float origin[3] = NULL_VECTOR, \t\t\t\tconst float dir[3] = NULL_VECTOR, \t\t\t\tbool updatePos = true, \t\t\t\tfloat soundtime = 0.0) { \tint channel; \tint level; \tfloat volume; \tint pitch; \tchar sample[PLATFORM_MAX_PATH];  \tif (GetGameSoundParams(gameSound, channel, level, volume, pitch, sample, sizeof(sample), entity)) \t{ \t\tEmitSound(clients, numClients, sample, entity, channel, level, flags, volume, pitch, speakerentity, origin, dir, updatePos, soundtime);"
  },
  {
    "name": "EmitAmbientGameSound",
    "type": "stock",
    "source_file": "sdktools_sound.inc",
    "return_type": "bool",
    "comment": "Emits an ambient game sound.\n\nGame sounds are found in a game's scripts/game_sound.txt or other files\nreferenced from it\n\nNote that if a game sound has a rndwave section, one of them will be returned\nat random.",
    "tags": {
      "param": [
        {
          "name": "gameSound",
          "description": "Name of game sound."
        },
        {
          "name": "pos",
          "description": "Origin of sound."
        },
        {
          "name": "entity",
          "description": "Entity index to associate sound with."
        },
        {
          "name": "flags",
          "description": "Sound flags."
        },
        {
          "name": "delay",
          "description": "Play delay."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "gameSound",
        "type": "char[]",
        "default": null,
        "description": "Name of game sound."
      },
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Origin of sound."
      },
      {
        "name": "entity",
        "type": "int",
        "default": "",
        "description": "Entity index to associate sound with."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Sound flags."
      },
      {
        "name": "delay",
        "type": "float",
        "default": "",
        "description": "Play delay."
      },
      {
        "name": "it",
        "type": "but",
        "default": null,
        "description": ""
      }
    ],
    "full_declaration": "stock bool EmitAmbientGameSound(const char[] gameSound, \t\t\t\tconst float pos[3], \t\t\t\tint entity = SOUND_FROM_WORLD, \t\t\t\tint flags = SND_NOFLAGS, \t\t\t\tfloat delay = 0.0) { \tint channel; // This is never actually used for Ambients, but it's a mandatory field to GetGameSoundParams \tint level; \tfloat volume; \tint pitch; \tchar sample[PLATFORM_MAX_PATH];  \tif (GetGameSoundParams(gameSound, channel, level, volume, pitch, sample, sizeof(sample), entity)) \t{ \t\tEmitAmbientSound(sample, pos, entity, level, flags, volume, pitch, delay);"
  },
  {
    "name": "EmitGameSoundToClient",
    "type": "stock",
    "source_file": "sdktools_sound.inc",
    "return_type": "bool",
    "comment": "Wrapper to emit a game sound to one client.\n\nGame sounds are found in a game's scripts/game_sound.txt or other files\nreferenced from it\n\nNote that if a game sound has a rndwave section, one of them will be returned\nat random.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "gameSound",
          "description": "Name of game sound."
        },
        {
          "name": "entity",
          "description": "Entity to emit from."
        },
        {
          "name": "flags",
          "description": "Sound flags."
        },
        {
          "name": "speakerentity",
          "description": "Unknown."
        },
        {
          "name": "origin",
          "description": "Sound origin."
        },
        {
          "name": "dir",
          "description": "Sound direction."
        },
        {
          "name": "updatePos",
          "description": "Unknown (updates positions?)"
        },
        {
          "name": "soundtime",
          "description": "Alternate time to play sound for."
        }
      ],
      "error": [
        "Invalid client index or client not in game."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "gameSound",
        "type": "char[]",
        "default": null,
        "description": "Name of game sound."
      },
      {
        "name": "entity",
        "type": "int",
        "default": "",
        "description": "Entity to emit from."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Sound flags."
      },
      {
        "name": "speakerentity",
        "type": "int",
        "default": "",
        "description": "Unknown."
      },
      {
        "name": "origin",
        "type": "float",
        "default": null,
        "description": "Sound origin."
      },
      {
        "name": "dir",
        "type": "float",
        "default": null,
        "description": "Sound direction."
      },
      {
        "name": "updatePos",
        "type": "bool",
        "default": "",
        "description": "Unknown (updates positions?)"
      },
      {
        "name": "soundtime",
        "type": "float",
        "default": "",
        "description": "Alternate time to play sound for."
      }
    ],
    "full_declaration": "stock bool EmitGameSoundToClient(int client, \t\t\t\tconst char[] gameSound, \t\t\t\tint entity = SOUND_FROM_PLAYER, \t\t\t\tint flags = SND_NOFLAGS, \t\t\t\tint speakerentity = -1, \t\t\t\tconst float origin[3] = NULL_VECTOR, \t\t\t\tconst float dir[3] = NULL_VECTOR, \t\t\t\tbool updatePos = true, \t\t\t\tfloat soundtime = 0.0) { \tint clients[1]; \tclients[0] = client; \t/* Save some work for SDKTools and remove SOUND_FROM_PLAYER references */ \tentity = (entity == SOUND_FROM_PLAYER) ? client : entity; \treturn EmitGameSound(clients, 1, gameSound, entity, flags, \t\tspeakerentity, origin, dir, updatePos, soundtime);"
  },
  {
    "name": "EmitGameSoundToAll",
    "type": "stock",
    "source_file": "sdktools_sound.inc",
    "return_type": "bool",
    "comment": "Wrapper to emit game sound to all clients.\n\nGame sounds are found in a game's scripts/game_sound.txt or other files\nreferenced from it\n\nNote that if a game sound has a rndwave section, one of them will be returned\nat random.",
    "tags": {
      "param": [
        {
          "name": "gameSound",
          "description": "Name of game sound."
        },
        {
          "name": "entity",
          "description": "Entity to emit from."
        },
        {
          "name": "flags",
          "description": "Sound flags."
        },
        {
          "name": "speakerentity",
          "description": "Unknown."
        },
        {
          "name": "origin",
          "description": "Sound origin."
        },
        {
          "name": "dir",
          "description": "Sound direction."
        },
        {
          "name": "updatePos",
          "description": "Unknown (updates positions?)"
        },
        {
          "name": "soundtime",
          "description": "Alternate time to play sound for."
        }
      ],
      "error": [
        "Invalid client index."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "gameSound",
        "type": "char[]",
        "default": null,
        "description": "Name of game sound."
      },
      {
        "name": "entity",
        "type": "int",
        "default": "",
        "description": "Entity to emit from."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Sound flags."
      },
      {
        "name": "speakerentity",
        "type": "int",
        "default": "",
        "description": "Unknown."
      },
      {
        "name": "origin",
        "type": "float",
        "default": null,
        "description": "Sound origin."
      },
      {
        "name": "dir",
        "type": "float",
        "default": null,
        "description": "Sound direction."
      },
      {
        "name": "updatePos",
        "type": "bool",
        "default": "",
        "description": "Unknown (updates positions?)"
      },
      {
        "name": "soundtime",
        "type": "float",
        "default": "",
        "description": "Alternate time to play sound for."
      }
    ],
    "full_declaration": "stock bool EmitGameSoundToAll(const char[] gameSound, \t\t\t\tint entity = SOUND_FROM_PLAYER, \t\t\t\tint flags = SND_NOFLAGS, \t\t\t\tint speakerentity = -1, \t\t\t\tconst float origin[3] = NULL_VECTOR, \t\t\t\tconst float dir[3] = NULL_VECTOR, \t\t\t\tbool updatePos = true, \t\t\t\tfloat soundtime = 0.0) { \tint[] clients = new int[MaxClients]; \tint total = 0;  \tfor (int i=1; i<=MaxClients; i++) \t{ \t\tif (IsClientInGame(i)) \t\t{ \t\t\tclients[total++] = i; \t\t} \t}  \tif (!total) \t{ \t\treturn false; \t}  \treturn EmitGameSound(clients, total, gameSound, entity, flags, \t\tspeakerentity, origin, dir, updatePos, soundtime);"
  },
  {
    "name": "PrecacheScriptSound",
    "type": "native",
    "source_file": "sdktools_sound.inc",
    "return_type": "bool",
    "comment": "Precache a game sound.\n\nMost games will precache all game sounds on map start, but this is not guaranteed...\nTeam Fortress 2 is known to not pre-cache MvM game mode sounds on non-MvM maps.\n\nDue to the above, this native should be called before any calls to GetGameSoundParams,\nEmitGameSound*, or EmitAmbientGameSound.\n\nIt should be safe to pass already precached game sounds to this function.\n\nNote: It precaches all files for a game sound.",
    "tags": {
      "param": [
        {
          "name": "soundname",
          "description": "Game sound to precache"
        }
      ],
      "error": [],
      "note": [],
      "return": "True if the game sound was found, false if sound did not exist or had no files"
    },
    "params": [
      {
        "name": "soundname",
        "type": "char[]",
        "default": null,
        "description": "Game sound to precache"
      }
    ],
    "full_declaration": "native bool PrecacheScriptSound(const char[] soundname);"
  },
  {
    "name": "FindTeamByName",
    "type": "stock",
    "source_file": "sdktools_stocks.inc",
    "return_type": "int",
    "comment": "Given a partial team name, attempts to find a matching team.\n\nThe search is performed case insensitively and only against the\nfirst N characters of the team names, where N is the number of\ncharacters in the search pattern.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Partial or full team name."
        }
      ],
      "error": [],
      "note": [],
      "return": "A valid team index on success. -1 if no team matched. -2 if more than one team matched."
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Partial or full team name."
      }
    ],
    "full_declaration": "stock int FindTeamByName(const char[] name) { \tint name_len = strlen(name);"
  },
  {
    "name": "FindStringTable",
    "type": "native",
    "source_file": "sdktools_stringtables.inc",
    "return_type": "int",
    "comment": "Searches for a string table.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Name of string table to find."
        }
      ],
      "error": [],
      "note": [],
      "return": "A string table index number if found, INVALID_STRING_TABLE otherwise."
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Name of string table to find."
      }
    ],
    "full_declaration": "native int FindStringTable(const char[] name);"
  },
  {
    "name": "GetNumStringTables",
    "type": "native",
    "source_file": "sdktools_stringtables.inc",
    "return_type": "int",
    "comment": "Returns the number of string tables that currently exist.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "Number of string tables that currently exist."
    },
    "params": [],
    "full_declaration": "native int GetNumStringTables();"
  },
  {
    "name": "GetStringTableNumStrings",
    "type": "native",
    "source_file": "sdktools_stringtables.inc",
    "return_type": "int",
    "comment": "Returns the number of strings that currently exist in a given string table.",
    "tags": {
      "param": [
        {
          "name": "tableidx",
          "description": "A string table index."
        }
      ],
      "error": [
        "Invalid string table index."
      ],
      "note": [],
      "return": "Number of strings that currently exist."
    },
    "params": [
      {
        "name": "tableidx",
        "type": "int",
        "default": null,
        "description": "A string table index."
      }
    ],
    "full_declaration": "native int GetStringTableNumStrings(int tableidx);"
  },
  {
    "name": "GetStringTableMaxStrings",
    "type": "native",
    "source_file": "sdktools_stringtables.inc",
    "return_type": "int",
    "comment": "Returns the maximum number of strings that are allowed in a given string table.",
    "tags": {
      "param": [
        {
          "name": "tableidx",
          "description": "A string table index."
        }
      ],
      "error": [
        "Invalid string table index."
      ],
      "note": [],
      "return": "Maximum number of strings allowed."
    },
    "params": [
      {
        "name": "tableidx",
        "type": "int",
        "default": null,
        "description": "A string table index."
      }
    ],
    "full_declaration": "native int GetStringTableMaxStrings(int tableidx);"
  },
  {
    "name": "GetStringTableName",
    "type": "native",
    "source_file": "sdktools_stringtables.inc",
    "return_type": "int",
    "comment": "Retrieves the name of a string table.",
    "tags": {
      "param": [
        {
          "name": "tableidx",
          "description": "A string table index."
        },
        {
          "name": "name",
          "description": "Buffer to store the name of the string table."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of string buffer."
        }
      ],
      "error": [
        "Invalid string table index."
      ],
      "note": [],
      "return": "Number of bytes written to the buffer (UTF-8 safe)."
    },
    "params": [
      {
        "name": "tableidx",
        "type": "int",
        "default": null,
        "description": "A string table index."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the name of the string table."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of string buffer."
      }
    ],
    "full_declaration": "native int GetStringTableName(int tableidx, char[] name, int maxlength);"
  },
  {
    "name": "FindStringIndex",
    "type": "native",
    "source_file": "sdktools_stringtables.inc",
    "return_type": "int",
    "comment": "Searches for the index of a given string in a string table.",
    "tags": {
      "param": [
        {
          "name": "tableidx",
          "description": "A string table index."
        },
        {
          "name": "str",
          "description": "String to find."
        }
      ],
      "error": [
        "Invalid string table index."
      ],
      "note": [],
      "return": "String index if found, INVALID_STRING_INDEX otherwise."
    },
    "params": [
      {
        "name": "tableidx",
        "type": "int",
        "default": null,
        "description": "A string table index."
      },
      {
        "name": "str",
        "type": "char[]",
        "default": null,
        "description": "String to find."
      }
    ],
    "full_declaration": "native int FindStringIndex(int tableidx, const char[] str);"
  },
  {
    "name": "ReadStringTable",
    "type": "native",
    "source_file": "sdktools_stringtables.inc",
    "return_type": "int",
    "comment": "Retrieves the string at a given index of a string table.",
    "tags": {
      "param": [
        {
          "name": "tableidx",
          "description": "A string table index."
        },
        {
          "name": "stringidx",
          "description": "A string index."
        },
        {
          "name": "str",
          "description": "Buffer to store the string value."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of string buffer."
        }
      ],
      "error": [
        "Invalid string table index or string index."
      ],
      "note": [],
      "return": "Number of bytes written to the buffer (UTF-8 safe)."
    },
    "params": [
      {
        "name": "tableidx",
        "type": "int",
        "default": null,
        "description": "A string table index."
      },
      {
        "name": "stringidx",
        "type": "int",
        "default": null,
        "description": "A string index."
      },
      {
        "name": "str",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the string value."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of string buffer."
      }
    ],
    "full_declaration": "native int ReadStringTable(int tableidx, int stringidx, char[] str, int maxlength);"
  },
  {
    "name": "GetStringTableDataLength",
    "type": "native",
    "source_file": "sdktools_stringtables.inc",
    "return_type": "int",
    "comment": "Returns the length of the user data associated with a given string index.",
    "tags": {
      "param": [
        {
          "name": "tableidx",
          "description": "A string table index."
        },
        {
          "name": "stringidx",
          "description": "A string index."
        }
      ],
      "error": [
        "Invalid string table index or string index."
      ],
      "note": [],
      "return": "Length of user data. This will be 0 if there is no user data."
    },
    "params": [
      {
        "name": "tableidx",
        "type": "int",
        "default": null,
        "description": "A string table index."
      },
      {
        "name": "stringidx",
        "type": "int",
        "default": null,
        "description": "A string index."
      }
    ],
    "full_declaration": "native int GetStringTableDataLength(int tableidx, int stringidx);"
  },
  {
    "name": "GetStringTableData",
    "type": "native",
    "source_file": "sdktools_stringtables.inc",
    "return_type": "int",
    "comment": "Retrieves the user data associated with a given string index.",
    "tags": {
      "param": [
        {
          "name": "tableidx",
          "description": "A string table index."
        },
        {
          "name": "stringidx",
          "description": "A string index."
        },
        {
          "name": "userdata",
          "description": "Buffer to store the user data. This will be set to \"\" if there is no user data"
        },
        {
          "name": "maxlength",
          "description": "Maximum length of string buffer."
        }
      ],
      "error": [
        "Invalid string table index or string index."
      ],
      "note": [],
      "return": "Number of bytes written to the buffer (binary safe, includes the null terminator)."
    },
    "params": [
      {
        "name": "tableidx",
        "type": "int",
        "default": null,
        "description": "A string table index."
      },
      {
        "name": "stringidx",
        "type": "int",
        "default": null,
        "description": "A string index."
      },
      {
        "name": "userdata",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the user data. This will be set to \"\" if there is no user data"
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of string buffer."
      }
    ],
    "full_declaration": "native int GetStringTableData(int tableidx, int stringidx, char[] userdata, int maxlength);"
  },
  {
    "name": "SetStringTableData",
    "type": "native",
    "source_file": "sdktools_stringtables.inc",
    "return_type": "void",
    "comment": "Sets the user data associated with a given string index.",
    "tags": {
      "param": [
        {
          "name": "tableidx",
          "description": "A string table index."
        },
        {
          "name": "stringidx",
          "description": "A string index."
        },
        {
          "name": "userdata",
          "description": "User data string that will be set."
        },
        {
          "name": "length",
          "description": "Length of user data string. This should include the null terminator."
        }
      ],
      "error": [
        "Invalid string table index or string index."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "tableidx",
        "type": "int",
        "default": null,
        "description": "A string table index."
      },
      {
        "name": "stringidx",
        "type": "int",
        "default": null,
        "description": "A string index."
      },
      {
        "name": "userdata",
        "type": "char[]",
        "default": null,
        "description": "User data string that will be set."
      },
      {
        "name": "length",
        "type": "int",
        "default": null,
        "description": "Length of user data string. This should include the null terminator."
      }
    ],
    "full_declaration": "native void SetStringTableData(int tableidx, int stringidx, const char[] userdata, int length);"
  },
  {
    "name": "AddToStringTable",
    "type": "native",
    "source_file": "sdktools_stringtables.inc",
    "return_type": "void",
    "comment": "Adds a string to a given string table.",
    "tags": {
      "param": [
        {
          "name": "tableidx",
          "description": "A string table index."
        },
        {
          "name": "str",
          "description": "String to add."
        },
        {
          "name": "userdata",
          "description": "An optional user data string."
        },
        {
          "name": "length",
          "description": "Length of user data string. This should include the null terminator. If set to -1, then user data will be not be altered if the specified string already exists in the string table."
        }
      ],
      "error": [
        "Invalid string table index."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "tableidx",
        "type": "int",
        "default": null,
        "description": "A string table index."
      },
      {
        "name": "str",
        "type": "char[]",
        "default": null,
        "description": "String to add."
      },
      {
        "name": "userdata",
        "type": "char[]",
        "default": "",
        "description": "An optional user data string."
      },
      {
        "name": "length",
        "type": "int",
        "default": "",
        "description": "Length of user data string. This should include the null terminator. If set to -1, then user data will be not be altered if the specified string already exists in the string table."
      }
    ],
    "full_declaration": "native void AddToStringTable(int tableidx, const char[] str, const char[] userdata=\"\", int length=-1);"
  },
  {
    "name": "LockStringTables",
    "type": "native",
    "source_file": "sdktools_stringtables.inc",
    "return_type": "bool",
    "comment": "Locks or unlocks the network string tables.",
    "tags": {
      "param": [
        {
          "name": "lock",
          "description": "Determines whether network string tables should be locked. True means the tables should be locked for writing; false means unlocked."
        }
      ],
      "error": [],
      "note": [],
      "return": "Previous lock state."
    },
    "params": [
      {
        "name": "lock",
        "type": "bool",
        "default": null,
        "description": "Determines whether network string tables should be locked. True means the tables should be locked for writing; false means unlocked."
      }
    ],
    "full_declaration": "native bool LockStringTables(bool lock);"
  },
  {
    "name": "AddFileToDownloadsTable",
    "type": "stock",
    "source_file": "sdktools_stringtables.inc",
    "return_type": "void",
    "comment": "Adds a file to the downloadables network string table.\nThis forces a client to download the file if they do not already have it.",
    "tags": {
      "param": [
        {
          "name": "filename",
          "description": "File that will be added to downloadables table."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "filename",
        "type": "char[]",
        "default": null,
        "description": "File that will be added to downloadables table."
      }
    ],
    "full_declaration": "stock void AddFileToDownloadsTable(const char[] filename) { \tstatic int table = INVALID_STRING_TABLE;  \tif (table == INVALID_STRING_TABLE) \t{ \t\ttable = FindStringTable(\"downloadables\");"
  },
  {
    "name": "TEHook",
    "type": "typedef",
    "source_file": "sdktools_tempents.inc",
    "return_type": "Action",
    "comment": "Called when a temp entity is going to be sent.",
    "tags": {
      "param": [
        {
          "name": "te_name",
          "description": "TE name."
        },
        {
          "name": "Players",
          "description": "Array containing target player indexes."
        },
        {
          "name": "numClients",
          "description": "Number of players in the array."
        },
        {
          "name": "delay",
          "description": "Delay in seconds to send the TE."
        }
      ],
      "error": [],
      "note": [],
      "return": "Plugin_Continue to allow the transmission of the TE, Plugin_Stop to block it."
    },
    "params": [
      {
        "name": "te_name",
        "type": "char[]",
        "default": null,
        "description": "TE name."
      },
      {
        "name": "Players",
        "type": "int[]",
        "default": null,
        "description": "Array containing target player indexes."
      },
      {
        "name": "numClients",
        "type": "int",
        "default": null,
        "description": "Number of players in the array."
      },
      {
        "name": "delay",
        "type": "float",
        "default": null,
        "description": "Delay in seconds to send the TE."
      }
    ],
    "full_declaration": "typedef TEHook = function Action (const char[] te_name, const int[] Players, int numClients, float delay);"
  },
  {
    "name": "AddTempEntHook",
    "type": "native",
    "source_file": "sdktools_tempents.inc",
    "return_type": "void",
    "comment": "Hooks a temp entity.",
    "tags": {
      "param": [
        {
          "name": "te_name",
          "description": "TE name to hook."
        },
        {
          "name": "hook",
          "description": "Function to use as a hook."
        }
      ],
      "error": [
        "Temp Entity name not available or invalid function hook."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "te_name",
        "type": "char[]",
        "default": null,
        "description": "TE name to hook."
      },
      {
        "name": "hook",
        "type": "TEHook",
        "default": null,
        "description": "Function to use as a hook."
      }
    ],
    "full_declaration": "native void AddTempEntHook(const char[] te_name, TEHook hook);"
  },
  {
    "name": "RemoveTempEntHook",
    "type": "native",
    "source_file": "sdktools_tempents.inc",
    "return_type": "void",
    "comment": "Removes a temp entity hook.",
    "tags": {
      "param": [
        {
          "name": "te_name",
          "description": "TE name to unhook."
        },
        {
          "name": "hook",
          "description": "Function used for the hook."
        }
      ],
      "error": [
        "Temp Entity name not available or invalid function hook."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "te_name",
        "type": "char[]",
        "default": null,
        "description": "TE name to unhook."
      },
      {
        "name": "hook",
        "type": "TEHook",
        "default": null,
        "description": "Function used for the hook."
      }
    ],
    "full_declaration": "native void RemoveTempEntHook(const char[] te_name, TEHook hook);"
  },
  {
    "name": "TE_Start",
    "type": "native",
    "source_file": "sdktools_tempents.inc",
    "return_type": "void",
    "comment": "Starts a temp entity transmission.",
    "tags": {
      "param": [
        {
          "name": "te_name",
          "description": "TE name."
        }
      ],
      "error": [
        "Temp Entity name not available."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "te_name",
        "type": "char[]",
        "default": null,
        "description": "TE name."
      }
    ],
    "full_declaration": "native void TE_Start(const char[] te_name);"
  },
  {
    "name": "TE_IsValidProp",
    "type": "native",
    "source_file": "sdktools_tempents.inc",
    "return_type": "bool",
    "comment": "Checks if a certain TE property exists.",
    "tags": {
      "param": [
        {
          "name": "prop",
          "description": "Property to use."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if the property exists, otherwise false."
    },
    "params": [
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property to use."
      }
    ],
    "full_declaration": "native bool TE_IsValidProp(const char[] prop);"
  },
  {
    "name": "TE_WriteNum",
    "type": "native",
    "source_file": "sdktools_tempents.inc",
    "return_type": "void",
    "comment": "Sets an integer value in the current temp entity.",
    "tags": {
      "param": [
        {
          "name": "prop",
          "description": "Property to use."
        },
        {
          "name": "value",
          "description": "Integer value to set."
        }
      ],
      "error": [
        "Property not found."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property to use."
      },
      {
        "name": "value",
        "type": "int",
        "default": null,
        "description": "Integer value to set."
      }
    ],
    "full_declaration": "native void TE_WriteNum(const char[] prop, int value);"
  },
  {
    "name": "TE_ReadNum",
    "type": "native",
    "source_file": "sdktools_tempents.inc",
    "return_type": "int",
    "comment": "Reads an integer value in the current temp entity.",
    "tags": {
      "param": [
        {
          "name": "prop",
          "description": "Property to use."
        }
      ],
      "error": [
        "Property not found."
      ],
      "note": [],
      "return": "Property value."
    },
    "params": [
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property to use."
      }
    ],
    "full_declaration": "native int TE_ReadNum(const char[] prop);"
  },
  {
    "name": "TE_WriteEnt",
    "type": "native",
    "source_file": "sdktools_tempents.inc",
    "return_type": "void",
    "comment": "Sets an entity value in the current temp entity.",
    "tags": {
      "param": [
        {
          "name": "prop",
          "description": "Property to use."
        },
        {
          "name": "value",
          "description": "Entity reference or index value to set."
        }
      ],
      "error": [
        "Property not found."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property to use."
      },
      {
        "name": "value",
        "type": "int",
        "default": null,
        "description": "Entity reference or index value to set."
      }
    ],
    "full_declaration": "native void TE_WriteEnt(const char[] prop, int value);"
  },
  {
    "name": "TE_ReadEnt",
    "type": "native",
    "source_file": "sdktools_tempents.inc",
    "return_type": "int",
    "comment": "Reads an entity value in the current temp entity.",
    "tags": {
      "param": [
        {
          "name": "prop",
          "description": "Property to use."
        }
      ],
      "error": [
        "Property not found."
      ],
      "note": [],
      "return": "Property value as backwards compatible entity reference."
    },
    "params": [
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property to use."
      }
    ],
    "full_declaration": "native int TE_ReadEnt(const char[] prop);"
  },
  {
    "name": "TE_WriteFloat",
    "type": "native",
    "source_file": "sdktools_tempents.inc",
    "return_type": "void",
    "comment": "Sets a floating point number in the current temp entity.",
    "tags": {
      "param": [
        {
          "name": "prop",
          "description": "Property to use."
        },
        {
          "name": "value",
          "description": "Floating point number to set."
        }
      ],
      "error": [
        "Property not found."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property to use."
      },
      {
        "name": "value",
        "type": "float",
        "default": null,
        "description": "Floating point number to set."
      }
    ],
    "full_declaration": "native void TE_WriteFloat(const char[] prop, float value);"
  },
  {
    "name": "TE_ReadFloat",
    "type": "native",
    "source_file": "sdktools_tempents.inc",
    "return_type": "float",
    "comment": "Reads a floating point number in the current temp entity.",
    "tags": {
      "param": [
        {
          "name": "prop",
          "description": "Property to use."
        }
      ],
      "error": [
        "Property not found."
      ],
      "note": [],
      "return": "Property value."
    },
    "params": [
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property to use."
      }
    ],
    "full_declaration": "native float TE_ReadFloat(const char[] prop);"
  },
  {
    "name": "TE_WriteVector",
    "type": "native",
    "source_file": "sdktools_tempents.inc",
    "return_type": "void",
    "comment": "Sets a vector in the current temp entity.",
    "tags": {
      "param": [
        {
          "name": "prop",
          "description": "Property to use."
        },
        {
          "name": "vector",
          "description": "Vector to set."
        }
      ],
      "error": [
        "Property not found."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property to use."
      },
      {
        "name": "vector",
        "type": "float",
        "default": null,
        "description": "Vector to set."
      }
    ],
    "full_declaration": "native void TE_WriteVector(const char[] prop, const float vector[3]);"
  },
  {
    "name": "TE_ReadVector",
    "type": "native",
    "source_file": "sdktools_tempents.inc",
    "return_type": "void",
    "comment": "Reads a vector in the current temp entity.",
    "tags": {
      "param": [
        {
          "name": "prop",
          "description": "Property to use."
        },
        {
          "name": "vector",
          "description": "Vector to read."
        }
      ],
      "error": [
        "Property not found."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property to use."
      },
      {
        "name": "vector",
        "type": "float",
        "default": null,
        "description": "Vector to read."
      }
    ],
    "full_declaration": "native void TE_ReadVector(const char[] prop, float vector[3]);"
  },
  {
    "name": "TE_WriteAngles",
    "type": "native",
    "source_file": "sdktools_tempents.inc",
    "return_type": "void",
    "comment": "Sets a QAngle in the current temp entity.",
    "tags": {
      "param": [
        {
          "name": "prop",
          "description": "Property to use."
        },
        {
          "name": "angles",
          "description": "Angles to set."
        }
      ],
      "error": [
        "Property not found."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property to use."
      },
      {
        "name": "angles",
        "type": "float",
        "default": null,
        "description": "Angles to set."
      }
    ],
    "full_declaration": "native void TE_WriteAngles(const char[] prop, const float angles[3]);"
  },
  {
    "name": "TE_WriteFloatArray",
    "type": "native",
    "source_file": "sdktools_tempents.inc",
    "return_type": "void",
    "comment": "Sets an array of floats in the current temp entity.",
    "tags": {
      "param": [
        {
          "name": "prop",
          "description": "Property to use."
        },
        {
          "name": "array",
          "description": "Array of values to copy."
        },
        {
          "name": "arraySize",
          "description": "Number of values to copy."
        }
      ],
      "error": [
        "Property not found."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property to use."
      },
      {
        "name": "array",
        "type": "float[]",
        "default": null,
        "description": "Array of values to copy."
      },
      {
        "name": "arraySize",
        "type": "int",
        "default": null,
        "description": "Number of values to copy."
      }
    ],
    "full_declaration": "native void TE_WriteFloatArray(const char[] prop, const float[] array, int arraySize);"
  },
  {
    "name": "TE_Send",
    "type": "native",
    "source_file": "sdktools_tempents.inc",
    "return_type": "void",
    "comment": "Sends the current temp entity to one or more clients.",
    "tags": {
      "param": [
        {
          "name": "clients",
          "description": "Array containing player indexes to broadcast to."
        },
        {
          "name": "numClients",
          "description": "Number of players in the array."
        },
        {
          "name": "delay",
          "description": "Delay in seconds to send the TE."
        }
      ],
      "error": [
        "Invalid client index or client not in game."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "clients",
        "type": "int[]",
        "default": null,
        "description": "Array containing player indexes to broadcast to."
      },
      {
        "name": "numClients",
        "type": "int",
        "default": null,
        "description": "Number of players in the array."
      },
      {
        "name": "delay",
        "type": "float",
        "default": "",
        "description": "Delay in seconds to send the TE."
      }
    ],
    "full_declaration": "native void TE_Send(const int[] clients, int numClients, float delay=0.0);"
  },
  {
    "name": "TE_WriteEncodedEnt",
    "type": "stock",
    "source_file": "sdktools_tempents.inc",
    "return_type": "void",
    "comment": "Sets an encoded entity index in the current temp entity.\n(This is usually used for m_nStartEntity and m_nEndEntity).",
    "tags": {
      "param": [
        {
          "name": "prop",
          "description": "Property to use."
        },
        {
          "name": "value",
          "description": "Value to set."
        }
      ],
      "error": [
        "Property not found."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "prop",
        "type": "char[]",
        "default": null,
        "description": "Property to use."
      },
      {
        "name": "value",
        "type": "int",
        "default": null,
        "description": "Value to set."
      }
    ],
    "full_declaration": "stock void TE_WriteEncodedEnt(const char[] prop, int value) { \tint encvalue = (value & 0x0FFF) | ((1 & 0xF)<<12);"
  },
  {
    "name": "TE_SendToAll",
    "type": "stock",
    "source_file": "sdktools_tempents.inc",
    "return_type": "void",
    "comment": "Broadcasts the current temp entity to all clients.",
    "tags": {
      "param": [
        {
          "name": "delay",
          "description": "Delay in seconds to send the TE."
        }
      ],
      "error": [],
      "note": [
        "See TE_Start()."
      ],
      "return": ""
    },
    "params": [
      {
        "name": "delay",
        "type": "float",
        "default": "",
        "description": "Delay in seconds to send the TE."
      }
    ],
    "full_declaration": "stock void TE_SendToAll(float delay=0.0) { \tint total = 0; \tint[] clients = new int[MaxClients]; \tfor (int i=1; i<=MaxClients; i++) \t{ \t\tif (IsClientInGame(i)) \t\t{ \t\t\tclients[total++] = i; \t\t} \t} \tTE_Send(clients, total, delay);"
  },
  {
    "name": "TE_SendToClient",
    "type": "stock",
    "source_file": "sdktools_tempents.inc",
    "return_type": "void",
    "comment": "Sends the current TE to only a client.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client to send to."
        },
        {
          "name": "delay",
          "description": "Delay in seconds to send the TE."
        }
      ],
      "error": [
        "Invalid client index or client not in game."
      ],
      "note": [
        "See TE_Start()."
      ],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client to send to."
      },
      {
        "name": "delay",
        "type": "float",
        "default": "",
        "description": "Delay in seconds to send the TE."
      }
    ],
    "full_declaration": "stock void TE_SendToClient(int client, float delay=0.0) { \tint players[1];  \tplayers[0] = client;  \tTE_Send(players, 1, delay);"
  },
  {
    "name": "TE_SendToAllInRange",
    "type": "stock",
    "source_file": "sdktools_tempents.inc",
    "return_type": "void",
    "comment": "Sends the current TE to all clients that are in\nvisible or audible range of the origin.",
    "tags": {
      "param": [
        {
          "name": "origin",
          "description": "Coordinates from which to test range."
        },
        {
          "name": "rangeType",
          "description": "Range type to use for filtering clients."
        },
        {
          "name": "delay",
          "description": "Delay in seconds to send the TE."
        }
      ],
      "error": [],
      "note": [
        "See TE_Start().",
        "See GetClientsInRange()"
      ],
      "return": ""
    },
    "params": [
      {
        "name": "origin",
        "type": "float",
        "default": null,
        "description": "Coordinates from which to test range."
      },
      {
        "name": "rangeType",
        "type": "ClientRangeType",
        "default": null,
        "description": "Range type to use for filtering clients."
      },
      {
        "name": "delay",
        "type": "float",
        "default": "",
        "description": "Delay in seconds to send the TE."
      }
    ],
    "full_declaration": "stock void TE_SendToAllInRange(const float origin[3], ClientRangeType rangeType, float delay=0.0) { \tint[] clients = new int[MaxClients]; \tint total = GetClientsInRange(origin, rangeType, clients, MaxClients);"
  },
  {
    "name": "TE_SetupSparks",
    "type": "stock",
    "source_file": "sdktools_tempents_stocks.inc",
    "return_type": "void",
    "comment": "Sets up a sparks effect.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Position of the sparks."
        },
        {
          "name": "dir",
          "description": "Direction of the sparks."
        },
        {
          "name": "Magnitude",
          "description": "Sparks size."
        },
        {
          "name": "TrailLength",
          "description": "Trail lenght of the sparks."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Position of the sparks."
      },
      {
        "name": "dir",
        "type": "float",
        "default": null,
        "description": "Direction of the sparks."
      },
      {
        "name": "Magnitude",
        "type": "int",
        "default": null,
        "description": "Sparks size."
      },
      {
        "name": "TrailLength",
        "type": "int",
        "default": null,
        "description": "Trail lenght of the sparks."
      }
    ],
    "full_declaration": "stock void TE_SetupSparks(const float pos[3], const float dir[3], int Magnitude, int TrailLength) { \tTE_Start(\"Sparks\");"
  },
  {
    "name": "TE_SetupSmoke",
    "type": "stock",
    "source_file": "sdktools_tempents_stocks.inc",
    "return_type": "void",
    "comment": "Sets up a smoke effect.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Position of the smoke."
        },
        {
          "name": "Model",
          "description": "Precached model index."
        },
        {
          "name": "Scale",
          "description": "Scale of the smoke."
        },
        {
          "name": "FrameRate",
          "description": "Frame rate of the smoke."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Position of the smoke."
      },
      {
        "name": "Model",
        "type": "int",
        "default": null,
        "description": "Precached model index."
      },
      {
        "name": "Scale",
        "type": "float",
        "default": null,
        "description": "Scale of the smoke."
      },
      {
        "name": "FrameRate",
        "type": "int",
        "default": null,
        "description": "Frame rate of the smoke."
      }
    ],
    "full_declaration": "stock void TE_SetupSmoke(const float pos[3], int Model, float Scale, int FrameRate) { \tTE_Start(\"Smoke\");"
  },
  {
    "name": "TE_SetupDust",
    "type": "stock",
    "source_file": "sdktools_tempents_stocks.inc",
    "return_type": "void",
    "comment": "Sets up a dust cloud effect.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Position of the dust."
        },
        {
          "name": "dir",
          "description": "Direction of the dust."
        },
        {
          "name": "Size",
          "description": "Dust cloud size."
        },
        {
          "name": "Speed",
          "description": "Dust cloud speed."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Position of the dust."
      },
      {
        "name": "dir",
        "type": "float",
        "default": null,
        "description": "Direction of the dust."
      },
      {
        "name": "Size",
        "type": "float",
        "default": null,
        "description": "Dust cloud size."
      },
      {
        "name": "Speed",
        "type": "float",
        "default": null,
        "description": "Dust cloud speed."
      }
    ],
    "full_declaration": "stock void TE_SetupDust(const float pos[3], const float dir[3], float Size, float Speed) { \tTE_Start(\"Dust\");"
  },
  {
    "name": "TE_SetupMuzzleFlash",
    "type": "stock",
    "source_file": "sdktools_tempents_stocks.inc",
    "return_type": "void",
    "comment": "Sets up a muzzle flash effect.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Position of the muzzle flash."
        },
        {
          "name": "angles",
          "description": "Rotation angles of the muzzle flash."
        },
        {
          "name": "Scale",
          "description": "Scale of the muzzle flash."
        },
        {
          "name": "Type",
          "description": "Muzzle flash type to render (Mod specific)."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Position of the muzzle flash."
      },
      {
        "name": "angles",
        "type": "float",
        "default": null,
        "description": "Rotation angles of the muzzle flash."
      },
      {
        "name": "Scale",
        "type": "float",
        "default": null,
        "description": "Scale of the muzzle flash."
      },
      {
        "name": "Type",
        "type": "int",
        "default": null,
        "description": "Muzzle flash type to render (Mod specific)."
      }
    ],
    "full_declaration": "stock void TE_SetupMuzzleFlash(const float pos[3], const float angles[3], float Scale, int Type) { \tTE_Start(\"MuzzleFlash\");"
  },
  {
    "name": "TE_SetupMetalSparks",
    "type": "stock",
    "source_file": "sdktools_tempents_stocks.inc",
    "return_type": "void",
    "comment": "Sets up a metal sparks effect.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Position of the metal sparks."
        },
        {
          "name": "dir",
          "description": "Direction of the metal sparks."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Position of the metal sparks."
      },
      {
        "name": "dir",
        "type": "float",
        "default": null,
        "description": "Direction of the metal sparks."
      }
    ],
    "full_declaration": "stock void TE_SetupMetalSparks(const float pos[3], const float dir[3]) { \tTE_Start(\"Metal Sparks\");"
  },
  {
    "name": "TE_SetupEnergySplash",
    "type": "stock",
    "source_file": "sdktools_tempents_stocks.inc",
    "return_type": "void",
    "comment": "Sets up an energy splash effect.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Position of the energy splash."
        },
        {
          "name": "dir",
          "description": "Direction of the energy splash."
        },
        {
          "name": "Explosive",
          "description": "Makes the effect explosive."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Position of the energy splash."
      },
      {
        "name": "dir",
        "type": "float",
        "default": null,
        "description": "Direction of the energy splash."
      },
      {
        "name": "Explosive",
        "type": "bool",
        "default": null,
        "description": "Makes the effect explosive."
      }
    ],
    "full_declaration": "stock void TE_SetupEnergySplash(const float pos[3], const float dir[3], bool Explosive) { \tTE_Start(\"Energy Splash\");"
  },
  {
    "name": "TE_SetupArmorRicochet",
    "type": "stock",
    "source_file": "sdktools_tempents_stocks.inc",
    "return_type": "void",
    "comment": "Sets up an armor ricochet effect.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Position of the armor ricochet."
        },
        {
          "name": "dir",
          "description": "Direction of the armor ricochet."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Position of the armor ricochet."
      },
      {
        "name": "dir",
        "type": "float",
        "default": null,
        "description": "Direction of the armor ricochet."
      }
    ],
    "full_declaration": "stock void TE_SetupArmorRicochet(const float pos[3], const float dir[3]) { \tTE_Start(\"Armor Ricochet\");"
  },
  {
    "name": "TE_SetupGlowSprite",
    "type": "stock",
    "source_file": "sdktools_tempents_stocks.inc",
    "return_type": "void",
    "comment": "Sets up a glowing sprite effect.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Position of the sprite."
        },
        {
          "name": "Model",
          "description": "Precached model index."
        },
        {
          "name": "Life",
          "description": "Time duration of the sprite."
        },
        {
          "name": "Size",
          "description": "Sprite size."
        },
        {
          "name": "Brightness",
          "description": "Sprite brightness."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Position of the sprite."
      },
      {
        "name": "Model",
        "type": "int",
        "default": null,
        "description": "Precached model index."
      },
      {
        "name": "Life",
        "type": "float",
        "default": null,
        "description": "Time duration of the sprite."
      },
      {
        "name": "Size",
        "type": "float",
        "default": null,
        "description": "Sprite size."
      },
      {
        "name": "Brightness",
        "type": "int",
        "default": null,
        "description": "Sprite brightness."
      }
    ],
    "full_declaration": "stock void TE_SetupGlowSprite(const float pos[3], int Model, float Life, float Size, int Brightness) { \tTE_Start(\"GlowSprite\");"
  },
  {
    "name": "TE_SetupExplosion",
    "type": "stock",
    "source_file": "sdktools_tempents_stocks.inc",
    "return_type": "void",
    "comment": "Sets up a explosion effect.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Explosion position."
        },
        {
          "name": "Model",
          "description": "Precached model index."
        },
        {
          "name": "Scale",
          "description": "Explosion scale."
        },
        {
          "name": "Framerate",
          "description": "Explosion frame rate."
        },
        {
          "name": "Flags",
          "description": "Explosion flags."
        },
        {
          "name": "Radius",
          "description": "Explosion radius."
        },
        {
          "name": "Magnitude",
          "description": "Explosion size."
        },
        {
          "name": "normal",
          "description": "Normal vector to the explosion."
        },
        {
          "name": "MaterialType",
          "description": "Exploded material type."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Explosion position."
      },
      {
        "name": "Model",
        "type": "int",
        "default": null,
        "description": "Precached model index."
      },
      {
        "name": "Scale",
        "type": "float",
        "default": null,
        "description": "Explosion scale."
      },
      {
        "name": "Framerate",
        "type": "int",
        "default": null,
        "description": "Explosion frame rate."
      },
      {
        "name": "Flags",
        "type": "int",
        "default": null,
        "description": "Explosion flags."
      },
      {
        "name": "Radius",
        "type": "int",
        "default": null,
        "description": "Explosion radius."
      },
      {
        "name": "Magnitude",
        "type": "int",
        "default": null,
        "description": "Explosion size."
      },
      {
        "name": "normal",
        "type": "float",
        "default": null,
        "description": "Normal vector to the explosion."
      },
      {
        "name": "MaterialType",
        "type": "int",
        "default": "",
        "description": "Exploded material type."
      }
    ],
    "full_declaration": "stock void TE_SetupExplosion(const float pos[3], int Model, float Scale, int Framerate, int Flags, int Radius, int Magnitude, const float normal[3]={0.0, 0.0, 1.0}, int MaterialType='C') { \tTE_Start(\"Explosion\");"
  },
  {
    "name": "TE_SetupBloodSprite",
    "type": "stock",
    "source_file": "sdktools_tempents_stocks.inc",
    "return_type": "void",
    "comment": "Sets up a blood sprite effect.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Position of the sprite."
        },
        {
          "name": "dir",
          "description": "Sprite direction."
        },
        {
          "name": "color",
          "description": "Color array (r, g, b, a)."
        },
        {
          "name": "Size",
          "description": "Sprite size."
        },
        {
          "name": "SprayModel",
          "description": "Precached model index."
        },
        {
          "name": "BloodDropModel",
          "description": "Precached model index."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Position of the sprite."
      },
      {
        "name": "dir",
        "type": "float",
        "default": null,
        "description": "Sprite direction."
      },
      {
        "name": "color",
        "type": "int",
        "default": null,
        "description": "Color array (r, g, b, a)."
      },
      {
        "name": "Size",
        "type": "int",
        "default": null,
        "description": "Sprite size."
      },
      {
        "name": "SprayModel",
        "type": "int",
        "default": null,
        "description": "Precached model index."
      },
      {
        "name": "BloodDropModel",
        "type": "int",
        "default": null,
        "description": "Precached model index."
      }
    ],
    "full_declaration": "stock void TE_SetupBloodSprite(const float pos[3], const float dir[3], const int color[4], int Size, int SprayModel, int BloodDropModel) { \tTE_Start(\"Blood Sprite\");"
  },
  {
    "name": "TE_SetupBeamRingPoint",
    "type": "stock",
    "source_file": "sdktools_tempents_stocks.inc",
    "return_type": "void",
    "comment": "Sets up a beam ring point effect.",
    "tags": {
      "param": [
        {
          "name": "center",
          "description": "Center position of the ring."
        },
        {
          "name": "Start_Radius",
          "description": "Initial ring radius."
        },
        {
          "name": "End_Radius",
          "description": "Final ring radius."
        },
        {
          "name": "ModelIndex",
          "description": "Precached model index."
        },
        {
          "name": "HaloIndex",
          "description": "Precached model index."
        },
        {
          "name": "StartFrame",
          "description": "Initial frame to render."
        },
        {
          "name": "FrameRate",
          "description": "Ring frame rate."
        },
        {
          "name": "Life",
          "description": "Time duration of the ring."
        },
        {
          "name": "Width",
          "description": "Beam width."
        },
        {
          "name": "Amplitude",
          "description": "Beam amplitude."
        },
        {
          "name": "Color",
          "description": "Color array (r, g, b, a)."
        },
        {
          "name": "Speed",
          "description": "Speed of the beam."
        },
        {
          "name": "Flags",
          "description": "Beam flags."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "center",
        "type": "float",
        "default": null,
        "description": "Center position of the ring."
      },
      {
        "name": "Start_Radius",
        "type": "float",
        "default": null,
        "description": "Initial ring radius."
      },
      {
        "name": "End_Radius",
        "type": "float",
        "default": null,
        "description": "Final ring radius."
      },
      {
        "name": "ModelIndex",
        "type": "int",
        "default": null,
        "description": "Precached model index."
      },
      {
        "name": "HaloIndex",
        "type": "int",
        "default": null,
        "description": "Precached model index."
      },
      {
        "name": "StartFrame",
        "type": "int",
        "default": null,
        "description": "Initial frame to render."
      },
      {
        "name": "FrameRate",
        "type": "int",
        "default": null,
        "description": "Ring frame rate."
      },
      {
        "name": "Life",
        "type": "float",
        "default": null,
        "description": "Time duration of the ring."
      },
      {
        "name": "Width",
        "type": "float",
        "default": null,
        "description": "Beam width."
      },
      {
        "name": "Amplitude",
        "type": "float",
        "default": null,
        "description": "Beam amplitude."
      },
      {
        "name": "Color",
        "type": "int",
        "default": null,
        "description": "Color array (r, g, b, a)."
      },
      {
        "name": "Speed",
        "type": "int",
        "default": null,
        "description": "Speed of the beam."
      },
      {
        "name": "Flags",
        "type": "int",
        "default": null,
        "description": "Beam flags."
      }
    ],
    "full_declaration": "stock void TE_SetupBeamRingPoint(const float center[3], float Start_Radius, float End_Radius, int ModelIndex, int HaloIndex, int StartFrame,  \t\t\t\tint FrameRate, float Life, float Width, float Amplitude, const int Color[4], int Speed, int Flags) { \tTE_Start(\"BeamRingPoint\");"
  },
  {
    "name": "TE_SetupBeamPoints",
    "type": "stock",
    "source_file": "sdktools_tempents_stocks.inc",
    "return_type": "void",
    "comment": "Sets up a point to point beam effect.",
    "tags": {
      "param": [
        {
          "name": "start",
          "description": "Start position of the beam."
        },
        {
          "name": "end",
          "description": "End position of the beam."
        },
        {
          "name": "ModelIndex",
          "description": "Precached model index."
        },
        {
          "name": "HaloIndex",
          "description": "Precached model index."
        },
        {
          "name": "StartFrame",
          "description": "Initial frame to render."
        },
        {
          "name": "FrameRate",
          "description": "Beam frame rate."
        },
        {
          "name": "Life",
          "description": "Time duration of the beam."
        },
        {
          "name": "Width",
          "description": "Initial beam width."
        },
        {
          "name": "EndWidth",
          "description": "Final beam width."
        },
        {
          "name": "FadeLength",
          "description": "Beam fade time duration."
        },
        {
          "name": "Amplitude",
          "description": "Beam amplitude."
        },
        {
          "name": "Color",
          "description": "Color array (r, g, b, a)."
        },
        {
          "name": "Speed",
          "description": "Speed of the beam."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "start",
        "type": "float",
        "default": null,
        "description": "Start position of the beam."
      },
      {
        "name": "end",
        "type": "float",
        "default": null,
        "description": "End position of the beam."
      },
      {
        "name": "ModelIndex",
        "type": "int",
        "default": null,
        "description": "Precached model index."
      },
      {
        "name": "HaloIndex",
        "type": "int",
        "default": null,
        "description": "Precached model index."
      },
      {
        "name": "StartFrame",
        "type": "int",
        "default": null,
        "description": "Initial frame to render."
      },
      {
        "name": "FrameRate",
        "type": "int",
        "default": null,
        "description": "Beam frame rate."
      },
      {
        "name": "Life",
        "type": "float",
        "default": null,
        "description": "Time duration of the beam."
      },
      {
        "name": "Width",
        "type": "float",
        "default": null,
        "description": "Initial beam width."
      },
      {
        "name": "EndWidth",
        "type": "float",
        "default": null,
        "description": "Final beam width."
      },
      {
        "name": "FadeLength",
        "type": "int",
        "default": null,
        "description": "Beam fade time duration."
      },
      {
        "name": "Amplitude",
        "type": "float",
        "default": null,
        "description": "Beam amplitude."
      },
      {
        "name": "Color",
        "type": "int",
        "default": null,
        "description": "Color array (r, g, b, a)."
      },
      {
        "name": "Speed",
        "type": "int",
        "default": null,
        "description": "Speed of the beam."
      }
    ],
    "full_declaration": "stock void TE_SetupBeamPoints(const float start[3], const float end[3], int ModelIndex, int HaloIndex, int StartFrame, int FrameRate, float Life,  \t\t\t\tfloat Width, float EndWidth, int FadeLength, float Amplitude, const int Color[4], int Speed) { \tTE_Start(\"BeamPoints\");"
  },
  {
    "name": "TE_SetupBeamLaser",
    "type": "stock",
    "source_file": "sdktools_tempents_stocks.inc",
    "return_type": "void",
    "comment": "Sets up an entity to entity laser effect.",
    "tags": {
      "param": [
        {
          "name": "StartEntity",
          "description": "Entity index from where the beam starts."
        },
        {
          "name": "EndEntity",
          "description": "Entity index from where the beam ends."
        },
        {
          "name": "ModelIndex",
          "description": "Precached model index."
        },
        {
          "name": "HaloIndex",
          "description": "Precached model index."
        },
        {
          "name": "StartFrame",
          "description": "Initial frame to render."
        },
        {
          "name": "FrameRate",
          "description": "Beam frame rate."
        },
        {
          "name": "Life",
          "description": "Time duration of the beam."
        },
        {
          "name": "Width",
          "description": "Initial beam width."
        },
        {
          "name": "EndWidth",
          "description": "Final beam width."
        },
        {
          "name": "FadeLength",
          "description": "Beam fade time duration."
        },
        {
          "name": "Amplitude",
          "description": "Beam amplitude."
        },
        {
          "name": "Color",
          "description": "Color array (r, g, b, a)."
        },
        {
          "name": "Speed",
          "description": "Speed of the beam."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "StartEntity",
        "type": "int",
        "default": null,
        "description": "Entity index from where the beam starts."
      },
      {
        "name": "EndEntity",
        "type": "int",
        "default": null,
        "description": "Entity index from where the beam ends."
      },
      {
        "name": "ModelIndex",
        "type": "int",
        "default": null,
        "description": "Precached model index."
      },
      {
        "name": "HaloIndex",
        "type": "int",
        "default": null,
        "description": "Precached model index."
      },
      {
        "name": "StartFrame",
        "type": "int",
        "default": null,
        "description": "Initial frame to render."
      },
      {
        "name": "FrameRate",
        "type": "int",
        "default": null,
        "description": "Beam frame rate."
      },
      {
        "name": "Life",
        "type": "float",
        "default": null,
        "description": "Time duration of the beam."
      },
      {
        "name": "Width",
        "type": "float",
        "default": null,
        "description": "Initial beam width."
      },
      {
        "name": "EndWidth",
        "type": "float",
        "default": null,
        "description": "Final beam width."
      },
      {
        "name": "FadeLength",
        "type": "int",
        "default": null,
        "description": "Beam fade time duration."
      },
      {
        "name": "Amplitude",
        "type": "float",
        "default": null,
        "description": "Beam amplitude."
      },
      {
        "name": "Color",
        "type": "int",
        "default": null,
        "description": "Color array (r, g, b, a)."
      },
      {
        "name": "Speed",
        "type": "int",
        "default": null,
        "description": "Speed of the beam."
      }
    ],
    "full_declaration": "stock void TE_SetupBeamLaser(int StartEntity, int EndEntity, int ModelIndex, int HaloIndex, int StartFrame, int FrameRate, float Life,  \t\t\t\tfloat Width, float EndWidth, int FadeLength, float Amplitude, const int Color[4], int Speed) { \tTE_Start(\"BeamLaser\");"
  },
  {
    "name": "TE_SetupBeamRing",
    "type": "stock",
    "source_file": "sdktools_tempents_stocks.inc",
    "return_type": "void",
    "comment": "Sets up a beam ring effect.",
    "tags": {
      "param": [
        {
          "name": "StartEntity",
          "description": "Entity index from where the ring starts."
        },
        {
          "name": "EndEntity",
          "description": "Entity index from where the ring ends."
        },
        {
          "name": "ModelIndex",
          "description": "Precached model index."
        },
        {
          "name": "HaloIndex",
          "description": "Precached model index."
        },
        {
          "name": "StartFrame",
          "description": "Initial frame to render."
        },
        {
          "name": "FrameRate",
          "description": "Ring frame rate."
        },
        {
          "name": "Life",
          "description": "Time duration of the ring."
        },
        {
          "name": "Width",
          "description": "Beam width."
        },
        {
          "name": "Amplitude",
          "description": "Beam amplitude."
        },
        {
          "name": "Color",
          "description": "Color array (r, g, b, a)."
        },
        {
          "name": "Speed",
          "description": "Speed of the beam."
        },
        {
          "name": "Flags",
          "description": "Beam flags."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "StartEntity",
        "type": "int",
        "default": null,
        "description": "Entity index from where the ring starts."
      },
      {
        "name": "EndEntity",
        "type": "int",
        "default": null,
        "description": "Entity index from where the ring ends."
      },
      {
        "name": "ModelIndex",
        "type": "int",
        "default": null,
        "description": "Precached model index."
      },
      {
        "name": "HaloIndex",
        "type": "int",
        "default": null,
        "description": "Precached model index."
      },
      {
        "name": "StartFrame",
        "type": "int",
        "default": null,
        "description": "Initial frame to render."
      },
      {
        "name": "FrameRate",
        "type": "int",
        "default": null,
        "description": "Ring frame rate."
      },
      {
        "name": "Life",
        "type": "float",
        "default": null,
        "description": "Time duration of the ring."
      },
      {
        "name": "Width",
        "type": "float",
        "default": null,
        "description": "Beam width."
      },
      {
        "name": "Amplitude",
        "type": "float",
        "default": null,
        "description": "Beam amplitude."
      },
      {
        "name": "Color",
        "type": "int",
        "default": null,
        "description": "Color array (r, g, b, a)."
      },
      {
        "name": "Speed",
        "type": "int",
        "default": null,
        "description": "Speed of the beam."
      },
      {
        "name": "Flags",
        "type": "int",
        "default": null,
        "description": "Beam flags."
      }
    ],
    "full_declaration": "stock void TE_SetupBeamRing(int StartEntity, int EndEntity, int ModelIndex, int HaloIndex, int StartFrame, int FrameRate, float Life, float Width, float Amplitude, const int Color[4], int Speed, int Flags) { \tTE_Start(\"BeamRing\");"
  },
  {
    "name": "TE_SetupBeamFollow",
    "type": "stock",
    "source_file": "sdktools_tempents_stocks.inc",
    "return_type": "void",
    "comment": "Sets up a follow beam effect.",
    "tags": {
      "param": [
        {
          "name": "EntIndex",
          "description": "Entity index from where the beam starts."
        },
        {
          "name": "ModelIndex",
          "description": "Precached model index."
        },
        {
          "name": "HaloIndex",
          "description": "Precached model index."
        },
        {
          "name": "Life",
          "description": "Time duration of the beam."
        },
        {
          "name": "Width",
          "description": "Initial beam width."
        },
        {
          "name": "EndWidth",
          "description": "Final beam width."
        },
        {
          "name": "FadeLength",
          "description": "Beam fade time duration."
        },
        {
          "name": "Color",
          "description": "Color array (r, g, b, a)."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "EntIndex",
        "type": "int",
        "default": null,
        "description": "Entity index from where the beam starts."
      },
      {
        "name": "ModelIndex",
        "type": "int",
        "default": null,
        "description": "Precached model index."
      },
      {
        "name": "HaloIndex",
        "type": "int",
        "default": null,
        "description": "Precached model index."
      },
      {
        "name": "Life",
        "type": "float",
        "default": null,
        "description": "Time duration of the beam."
      },
      {
        "name": "Width",
        "type": "float",
        "default": null,
        "description": "Initial beam width."
      },
      {
        "name": "EndWidth",
        "type": "float",
        "default": null,
        "description": "Final beam width."
      },
      {
        "name": "FadeLength",
        "type": "int",
        "default": null,
        "description": "Beam fade time duration."
      },
      {
        "name": "Color",
        "type": "int",
        "default": null,
        "description": "Color array (r, g, b, a)."
      }
    ],
    "full_declaration": "stock void TE_SetupBeamFollow(int EntIndex, int ModelIndex, int HaloIndex, float Life, float Width, float EndWidth, int FadeLength, const int Color[4]) { \tTE_Start(\"BeamFollow\");"
  },
  {
    "name": "TR_GetPointContents",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "int",
    "comment": "Get the contents mask and the entity index at the given position.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "World position to test."
        },
        {
          "name": "entindex",
          "description": "Entity index found at the given position (by reference)."
        }
      ],
      "error": [],
      "note": [],
      "return": "Contents mask."
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "World position to test."
      },
      {
        "name": "entindex",
        "type": "int",
        "default": "",
        "description": "Entity index found at the given position (by reference)."
      }
    ],
    "full_declaration": "native int TR_GetPointContents(const float pos[3], int &entindex=-1);"
  },
  {
    "name": "TR_GetPointContentsEnt",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "int",
    "comment": "Get the point contents testing only the given entity index.",
    "tags": {
      "param": [
        {
          "name": "entindex",
          "description": "Entity index to test."
        },
        {
          "name": "pos",
          "description": "World position."
        }
      ],
      "error": [
        "Invalid entity."
      ],
      "note": [],
      "return": "Contents mask."
    },
    "params": [
      {
        "name": "entindex",
        "type": "int",
        "default": null,
        "description": "Entity index to test."
      },
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "World position."
      }
    ],
    "full_declaration": "native int TR_GetPointContentsEnt(int entindex, const float pos[3]);"
  },
  {
    "name": "TR_TraceRay",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "void",
    "comment": "Starts up a new trace ray using a global trace result.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Starting position of the ray."
        },
        {
          "name": "vec",
          "description": "Depending on RayType, it will be used as the ending point, or the direction angle."
        },
        {
          "name": "flags",
          "description": "Trace flags."
        },
        {
          "name": "rtype",
          "description": "Method to calculate the ray direction."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Starting position of the ray."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Depending on RayType, it will be used as the ending point, or the direction angle."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "Trace flags."
      },
      {
        "name": "rtype",
        "type": "RayType",
        "default": null,
        "description": "Method to calculate the ray direction."
      }
    ],
    "full_declaration": "native void TR_TraceRay(const float pos[3],                         const float vec[3],                         int flags,                         RayType rtype);"
  },
  {
    "name": "TR_TraceHull",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "void",
    "comment": "Starts up a new trace hull using a global trace result.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Starting position of the ray."
        },
        {
          "name": "vec",
          "description": "Ending position of the ray."
        },
        {
          "name": "mins",
          "description": "Hull minimum size."
        },
        {
          "name": "maxs",
          "description": "Hull maximum size."
        },
        {
          "name": "flags",
          "description": "Trace flags."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Starting position of the ray."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Ending position of the ray."
      },
      {
        "name": "mins",
        "type": "float",
        "default": null,
        "description": "Hull minimum size."
      },
      {
        "name": "maxs",
        "type": "float",
        "default": null,
        "description": "Hull maximum size."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "Trace flags."
      }
    ],
    "full_declaration": "native void TR_TraceHull(const float pos[3],                          const float vec[3],                          const float mins[3],                          const float maxs[3],                          int flags);"
  },
  {
    "name": "TR_EnumerateEntities",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "void",
    "comment": "Enumerates over entities along a ray. This may find entities that are\nclose to the ray but do not actually intersect it. Use TR_Clip*RayToEntity\nwith TR_DidHit to check if the ray actually intersects the entity.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Starting position of the ray."
        },
        {
          "name": "vec",
          "description": "Depending on RayType, it will be used as the ending point, or the direction angle."
        },
        {
          "name": "mask",
          "description": "Mask to use for the trace. See PARTITION_* flags."
        },
        {
          "name": "rtype",
          "description": "Method to calculate the ray direction."
        },
        {
          "name": "enumerator",
          "description": "Function to use as enumerator. For each entity found along the ray, this function is called."
        },
        {
          "name": "data",
          "description": "Arbitrary data value to pass through to the enumerator."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Starting position of the ray."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Depending on RayType, it will be used as the ending point, or the direction angle."
      },
      {
        "name": "mask",
        "type": "int",
        "default": null,
        "description": "Mask to use for the trace. See PARTITION_* flags."
      },
      {
        "name": "rtype",
        "type": "RayType",
        "default": null,
        "description": "Method to calculate the ray direction."
      },
      {
        "name": "enumerator",
        "type": "TraceEntityEnumerator",
        "default": null,
        "description": "Function to use as enumerator. For each entity found along the ray, this function is called."
      },
      {
        "name": "data",
        "type": "any",
        "default": "",
        "description": "Arbitrary data value to pass through to the enumerator."
      }
    ],
    "full_declaration": "native void TR_EnumerateEntities(const float pos[3],                                  const float vec[3],                                  int mask,                                  RayType rtype,                                  TraceEntityEnumerator enumerator,                                  any data=0);"
  },
  {
    "name": "TR_EnumerateEntitiesHull",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "void",
    "comment": "Enumerates over entities along a ray hull. This may find entities that are\nclose to the ray but do not actually intersect it. Use TR_Clip*RayToEntity\nwith TR_DidHit to check if the ray actually intersects the entity.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Starting position of the ray."
        },
        {
          "name": "vec",
          "description": "Ending position of the ray."
        },
        {
          "name": "mins",
          "description": "Hull minimum size."
        },
        {
          "name": "maxs",
          "description": "Hull maximum size."
        },
        {
          "name": "mask",
          "description": "Mask to use for the trace. See PARTITION_* flags."
        },
        {
          "name": "enumerator",
          "description": "Function to use as enumerator. For each entity found along the ray, this function is called."
        },
        {
          "name": "data",
          "description": "Arbitrary data value to pass through to the enumerator."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Starting position of the ray."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Ending position of the ray."
      },
      {
        "name": "mins",
        "type": "float",
        "default": null,
        "description": "Hull minimum size."
      },
      {
        "name": "maxs",
        "type": "float",
        "default": null,
        "description": "Hull maximum size."
      },
      {
        "name": "mask",
        "type": "int",
        "default": null,
        "description": "Mask to use for the trace. See PARTITION_* flags."
      },
      {
        "name": "enumerator",
        "type": "TraceEntityEnumerator",
        "default": null,
        "description": "Function to use as enumerator. For each entity found along the ray, this function is called."
      },
      {
        "name": "data",
        "type": "any",
        "default": "",
        "description": "Arbitrary data value to pass through to the enumerator."
      }
    ],
    "full_declaration": "native void TR_EnumerateEntitiesHull(const float pos[3],                                     const float vec[3],                                     const float mins[3],                                     const float maxs[3],                                     int mask,                                     TraceEntityEnumerator enumerator,                                     any data=0);"
  },
  {
    "name": "TR_EnumerateEntitiesSphere",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "void",
    "comment": "Enumerates over entities in a sphere.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Starting position of the ray."
        },
        {
          "name": "radius",
          "description": "Radius of the ray."
        },
        {
          "name": "mask",
          "description": "Mask to use for the trace. See PARTITION_* flags."
        },
        {
          "name": "enumerator",
          "description": "Function to use as enumerator. For each entity found along the ray, this function is called."
        },
        {
          "name": "data",
          "description": "Arbitrary data value to pass through to the enumerator."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Starting position of the ray."
      },
      {
        "name": "radius",
        "type": "float",
        "default": null,
        "description": "Radius of the ray."
      },
      {
        "name": "mask",
        "type": "int",
        "default": null,
        "description": "Mask to use for the trace. See PARTITION_* flags."
      },
      {
        "name": "enumerator",
        "type": "TraceEntityEnumerator",
        "default": null,
        "description": "Function to use as enumerator. For each entity found along the ray, this function is called."
      },
      {
        "name": "data",
        "type": "any",
        "default": "",
        "description": "Arbitrary data value to pass through to the enumerator."
      }
    ],
    "full_declaration": "native void TR_EnumerateEntitiesSphere(const float pos[3],                                     float radius,                                     int mask,                                     TraceEntityEnumerator enumerator,                                     any data=0);"
  },
  {
    "name": "TR_EnumerateEntitiesBox",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "void",
    "comment": "Enumerates over entities in a box.",
    "tags": {
      "param": [
        {
          "name": "mins",
          "description": "Box minimum size."
        },
        {
          "name": "maxs",
          "description": "Box maximum size."
        },
        {
          "name": "mask",
          "description": "Mask to use for the trace. See PARTITION_* flags."
        },
        {
          "name": "enumerator",
          "description": "Function to use as enumerator. For each entity found along the box, this function is called."
        },
        {
          "name": "data",
          "description": "Arbitrary data value to pass through to the enumerator."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "mins",
        "type": "float",
        "default": null,
        "description": "Box minimum size."
      },
      {
        "name": "maxs",
        "type": "float",
        "default": null,
        "description": "Box maximum size."
      },
      {
        "name": "mask",
        "type": "int",
        "default": null,
        "description": "Mask to use for the trace. See PARTITION_* flags."
      },
      {
        "name": "enumerator",
        "type": "TraceEntityEnumerator",
        "default": null,
        "description": "Function to use as enumerator. For each entity found along the box, this function is called."
      },
      {
        "name": "data",
        "type": "any",
        "default": "",
        "description": "Arbitrary data value to pass through to the enumerator."
      }
    ],
    "full_declaration": "native void TR_EnumerateEntitiesBox(const float mins[3],                                     const float maxs[3],                                     int mask,                                     TraceEntityEnumerator enumerator,                                     any data=0);"
  },
  {
    "name": "TR_EnumerateEntitiesPoint",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "void",
    "comment": "Enumerates over entities at point.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Position of the point."
        },
        {
          "name": "mask",
          "description": "Mask to use for the trace. See PARTITION_* flags."
        },
        {
          "name": "enumerator",
          "description": "Function to use as enumerator. For each entity found along the point, this function is called."
        },
        {
          "name": "data",
          "description": "Arbitrary data value to pass through to the enumerator."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Position of the point."
      },
      {
        "name": "mask",
        "type": "int",
        "default": null,
        "description": "Mask to use for the trace. See PARTITION_* flags."
      },
      {
        "name": "enumerator",
        "type": "TraceEntityEnumerator",
        "default": null,
        "description": "Function to use as enumerator. For each entity found along the point, this function is called."
      },
      {
        "name": "data",
        "type": "any",
        "default": "",
        "description": "Arbitrary data value to pass through to the enumerator."
      }
    ],
    "full_declaration": "native void TR_EnumerateEntitiesPoint(const float pos[3],                                     int mask,                                     TraceEntityEnumerator enumerator,                                     any data=0);"
  },
  {
    "name": "TR_TraceRayFilter",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "void",
    "comment": "Starts up a new trace ray using a global trace result and a customized\ntrace ray filter.\n\nCalling TR_Trace*Filter or TR_Trace*FilterEx from inside a filter\nfunction is currently not allowed and may not work.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Starting position of the ray."
        },
        {
          "name": "vec",
          "description": "Depending on RayType, it will be used as the ending point, or the direction angle."
        },
        {
          "name": "flags",
          "description": "Trace flags."
        },
        {
          "name": "rtype",
          "description": "Method to calculate the ray direction."
        },
        {
          "name": "filter",
          "description": "Function to use as a filter."
        },
        {
          "name": "data",
          "description": "Arbitrary data value to pass through to the filter function."
        },
        {
          "name": "traceType",
          "description": "Trace type."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Starting position of the ray."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Depending on RayType, it will be used as the ending point, or the direction angle."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "Trace flags."
      },
      {
        "name": "rtype",
        "type": "RayType",
        "default": null,
        "description": "Method to calculate the ray direction."
      },
      {
        "name": "filter",
        "type": "TraceEntityFilter",
        "default": null,
        "description": "Function to use as a filter."
      },
      {
        "name": "data",
        "type": "any",
        "default": "",
        "description": "Arbitrary data value to pass through to the filter function."
      },
      {
        "name": "traceType",
        "type": "TraceType",
        "default": "",
        "description": "Trace type."
      }
    ],
    "full_declaration": "native void TR_TraceRayFilter(const float pos[3],                               const float vec[3],                               int flags,                               RayType rtype,                               TraceEntityFilter filter,                               any data=0, \t\t\t      TraceType traceType=TRACE_EVERYTHING);"
  },
  {
    "name": "TR_TraceHullFilter",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "void",
    "comment": "Starts up a new trace hull using a global trace result and a customized\ntrace ray filter.\n\nCalling TR_Trace*Filter or TR_Trace*FilterEx from inside a filter\nfunction is currently not allowed and may not work.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Starting position of the ray."
        },
        {
          "name": "vec",
          "description": "Ending position of the ray."
        },
        {
          "name": "mins",
          "description": "Hull minimum size."
        },
        {
          "name": "maxs",
          "description": "Hull maximum size."
        },
        {
          "name": "flags",
          "description": "Trace flags."
        },
        {
          "name": "filter",
          "description": "Function to use as a filter."
        },
        {
          "name": "data",
          "description": "Arbitrary data value to pass through to the filter function."
        },
        {
          "name": "traceType",
          "description": "Trace type."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Starting position of the ray."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Ending position of the ray."
      },
      {
        "name": "mins",
        "type": "float",
        "default": null,
        "description": "Hull minimum size."
      },
      {
        "name": "maxs",
        "type": "float",
        "default": null,
        "description": "Hull maximum size."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "Trace flags."
      },
      {
        "name": "filter",
        "type": "TraceEntityFilter",
        "default": null,
        "description": "Function to use as a filter."
      },
      {
        "name": "data",
        "type": "any",
        "default": "",
        "description": "Arbitrary data value to pass through to the filter function."
      },
      {
        "name": "traceType",
        "type": "TraceType",
        "default": "",
        "description": "Trace type."
      }
    ],
    "full_declaration": "native void TR_TraceHullFilter(const float pos[3],                                const float vec[3],                                const float mins[3],                                const float maxs[3],                                int flags,                                TraceEntityFilter filter,                                any data=0, \t\t\t       TraceType traceType=TRACE_EVERYTHING);"
  },
  {
    "name": "TR_ClipRayToEntity",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "void",
    "comment": "Clips a ray to a particular entity.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Starting position of the ray."
        },
        {
          "name": "vec",
          "description": "Depending on RayType, it will be used as the ending point, or the direction angle."
        },
        {
          "name": "flags",
          "description": "Trace flags."
        },
        {
          "name": "rtype",
          "description": "Method to calculate the ray direction."
        },
        {
          "name": "entity",
          "description": "Entity to clip to."
        }
      ],
      "error": [
        "Invalid entity."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Starting position of the ray."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Depending on RayType, it will be used as the ending point, or the direction angle."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "Trace flags."
      },
      {
        "name": "rtype",
        "type": "RayType",
        "default": null,
        "description": "Method to calculate the ray direction."
      },
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity to clip to."
      }
    ],
    "full_declaration": "native void TR_ClipRayToEntity(const float pos[3],                                const float vec[3],                                int flags,                                RayType rtype,                                int entity);"
  },
  {
    "name": "TR_ClipRayHullToEntity",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "void",
    "comment": "Clips a ray hull to a particular entity.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Starting position of the ray."
        },
        {
          "name": "vec",
          "description": "Ending position of the ray."
        },
        {
          "name": "mins",
          "description": "Hull minimum size."
        },
        {
          "name": "maxs",
          "description": "Hull maximum size."
        },
        {
          "name": "flags",
          "description": "Trace flags."
        },
        {
          "name": "entity",
          "description": "Entity to clip to."
        }
      ],
      "error": [
        "Invalid entity."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Starting position of the ray."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Ending position of the ray."
      },
      {
        "name": "mins",
        "type": "float",
        "default": null,
        "description": "Hull minimum size."
      },
      {
        "name": "maxs",
        "type": "float",
        "default": null,
        "description": "Hull maximum size."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "Trace flags."
      },
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity to clip to."
      }
    ],
    "full_declaration": "native void TR_ClipRayHullToEntity(const float pos[3],                                    const float vec[3],                                    const float mins[3],                                    const float maxs[3],                                    int flags,                                    int entity);"
  },
  {
    "name": "TR_ClipCurrentRayToEntity",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "void",
    "comment": "Clips the current global ray (or hull) to a particular entity.",
    "tags": {
      "param": [
        {
          "name": "flags",
          "description": "Trace flags."
        },
        {
          "name": "entity",
          "description": "Entity to clip to."
        }
      ],
      "error": [
        "Invalid entity."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "Trace flags."
      },
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity to clip to."
      }
    ],
    "full_declaration": "native void TR_ClipCurrentRayToEntity(int flags, int entity);"
  },
  {
    "name": "TR_TraceRayEx",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "Handle",
    "comment": "Starts up a new trace ray using a new trace result.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Starting position of the ray."
        },
        {
          "name": "vec",
          "description": "Depending on RayType, it will be used as the ending point, or the direction angle."
        },
        {
          "name": "flags",
          "description": "Trace flags."
        },
        {
          "name": "rtype",
          "description": "Method to calculate the ray direction."
        }
      ],
      "error": [],
      "note": [],
      "return": "Ray trace handle, which must be closed via CloseHandle()."
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Starting position of the ray."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Depending on RayType, it will be used as the ending point, or the direction angle."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "Trace flags."
      },
      {
        "name": "rtype",
        "type": "RayType",
        "default": null,
        "description": "Method to calculate the ray direction."
      }
    ],
    "full_declaration": "native Handle TR_TraceRayEx(const float pos[3],                             const float vec[3],                             int flags,                             RayType rtype);"
  },
  {
    "name": "TR_TraceHullEx",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "Handle",
    "comment": "Starts up a new trace hull using a new trace result.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Starting position of the ray."
        },
        {
          "name": "vec",
          "description": "Ending position of the ray."
        },
        {
          "name": "mins",
          "description": "Hull minimum size."
        },
        {
          "name": "maxs",
          "description": "Hull maximum size."
        },
        {
          "name": "flags",
          "description": "Trace flags."
        }
      ],
      "error": [],
      "note": [],
      "return": "Ray trace handle, which must be closed via CloseHandle()."
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Starting position of the ray."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Ending position of the ray."
      },
      {
        "name": "mins",
        "type": "float",
        "default": null,
        "description": "Hull minimum size."
      },
      {
        "name": "maxs",
        "type": "float",
        "default": null,
        "description": "Hull maximum size."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "Trace flags."
      }
    ],
    "full_declaration": "native Handle TR_TraceHullEx(const float pos[3],                              const float vec[3],                              const float mins[3],                              const float maxs[3],                              int flags);"
  },
  {
    "name": "TR_TraceRayFilterEx",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "Handle",
    "comment": "Starts up a new trace ray using a new trace result and a customized\ntrace ray filter.\n\nCalling TR_Trace*Filter or TR_TraceRay*Ex from inside a filter\nfunction is currently not allowed and may not work.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Starting position of the ray."
        },
        {
          "name": "vec",
          "description": "Depending on RayType, it will be used as the ending point, or the direction angle."
        },
        {
          "name": "flags",
          "description": "Trace flags."
        },
        {
          "name": "rtype",
          "description": "Method to calculate the ray direction."
        },
        {
          "name": "filter",
          "description": "Function to use as a filter."
        },
        {
          "name": "data",
          "description": "Arbitrary data value to pass through to the filter function."
        },
        {
          "name": "traceType",
          "description": "Trace type."
        }
      ],
      "error": [],
      "note": [],
      "return": "Ray trace handle, which must be closed via CloseHandle()."
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Starting position of the ray."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Depending on RayType, it will be used as the ending point, or the direction angle."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "Trace flags."
      },
      {
        "name": "rtype",
        "type": "RayType",
        "default": null,
        "description": "Method to calculate the ray direction."
      },
      {
        "name": "filter",
        "type": "TraceEntityFilter",
        "default": null,
        "description": "Function to use as a filter."
      },
      {
        "name": "data",
        "type": "any",
        "default": "",
        "description": "Arbitrary data value to pass through to the filter function."
      },
      {
        "name": "traceType",
        "type": "TraceType",
        "default": "",
        "description": "Trace type."
      }
    ],
    "full_declaration": "native Handle TR_TraceRayFilterEx(const float pos[3],                                   const float vec[3],                                   int flags,                                   RayType rtype,                                   TraceEntityFilter filter,                                   any data=0, \t\t\t\t  TraceType traceType=TRACE_EVERYTHING);"
  },
  {
    "name": "TR_TraceHullFilterEx",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "Handle",
    "comment": "Starts up a new trace hull using a new trace result and a customized\ntrace ray filter.\n\nCalling TR_Trace*Filter or TR_Trace*FilterEx from inside a filter\nfunction is currently not allowed and may not work.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Starting position of the ray."
        },
        {
          "name": "vec",
          "description": "Ending position of the ray."
        },
        {
          "name": "mins",
          "description": "Hull minimum size."
        },
        {
          "name": "maxs",
          "description": "Hull maximum size."
        },
        {
          "name": "flags",
          "description": "Trace flags."
        },
        {
          "name": "filter",
          "description": "Function to use as a filter."
        },
        {
          "name": "data",
          "description": "Arbitrary data value to pass through to the filter function."
        },
        {
          "name": "traceType",
          "description": "Trace type."
        }
      ],
      "error": [],
      "note": [],
      "return": "Ray trace handle, which must be closed via CloseHandle()."
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Starting position of the ray."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Ending position of the ray."
      },
      {
        "name": "mins",
        "type": "float",
        "default": null,
        "description": "Hull minimum size."
      },
      {
        "name": "maxs",
        "type": "float",
        "default": null,
        "description": "Hull maximum size."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "Trace flags."
      },
      {
        "name": "filter",
        "type": "TraceEntityFilter",
        "default": null,
        "description": "Function to use as a filter."
      },
      {
        "name": "data",
        "type": "any",
        "default": "",
        "description": "Arbitrary data value to pass through to the filter function."
      },
      {
        "name": "traceType",
        "type": "TraceType",
        "default": "",
        "description": "Trace type."
      }
    ],
    "full_declaration": "native Handle TR_TraceHullFilterEx(const float pos[3],                                    const float vec[3],                                    const float mins[3],                                    const float maxs[3],                                    int flags,                                    TraceEntityFilter filter,                                    any data=0, \t\t\t\t   TraceType traceType=TRACE_EVERYTHING);"
  },
  {
    "name": "TR_ClipRayToEntityEx",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "Handle",
    "comment": "Clips a ray to a particular entity.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Starting position of the ray."
        },
        {
          "name": "vec",
          "description": "Depending on RayType, it will be used as the ending point, or the direction angle."
        },
        {
          "name": "flags",
          "description": "Trace flags."
        },
        {
          "name": "rtype",
          "description": "Method to calculate the ray direction."
        },
        {
          "name": "entity",
          "description": "Entity to clip to."
        }
      ],
      "error": [
        "Invalid entity."
      ],
      "note": [],
      "return": "Ray trace handle, which must be closed via CloseHandle()."
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Starting position of the ray."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Depending on RayType, it will be used as the ending point, or the direction angle."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "Trace flags."
      },
      {
        "name": "rtype",
        "type": "RayType",
        "default": null,
        "description": "Method to calculate the ray direction."
      },
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity to clip to."
      }
    ],
    "full_declaration": "native Handle TR_ClipRayToEntityEx(const float pos[3],                                    const float vec[3],                                    int flags,                                    RayType rtype,                                    int entity);"
  },
  {
    "name": "TR_ClipRayHullToEntityEx",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "Handle",
    "comment": "Clips a ray hull to a particular entity.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Starting position of the ray."
        },
        {
          "name": "vec",
          "description": "Ending position of the ray."
        },
        {
          "name": "mins",
          "description": "Hull minimum size."
        },
        {
          "name": "maxs",
          "description": "Hull maximum size."
        },
        {
          "name": "flags",
          "description": "Trace flags."
        },
        {
          "name": "entity",
          "description": "Entity to clip to."
        }
      ],
      "error": [
        "Invalid entity."
      ],
      "note": [],
      "return": "Ray trace handle, which must be closed via CloseHandle()."
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Starting position of the ray."
      },
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Ending position of the ray."
      },
      {
        "name": "mins",
        "type": "float",
        "default": null,
        "description": "Hull minimum size."
      },
      {
        "name": "maxs",
        "type": "float",
        "default": null,
        "description": "Hull maximum size."
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "Trace flags."
      },
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity to clip to."
      }
    ],
    "full_declaration": "native Handle TR_ClipRayHullToEntityEx(const float pos[3],                                        const float vec[3],                                        const float mins[3],                                        const float maxs[3],                                        int flags,                                        int entity);"
  },
  {
    "name": "TR_ClipCurrentRayToEntityEx",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "Handle",
    "comment": "Clips the current global ray (or hull) to a particular entity.",
    "tags": {
      "param": [
        {
          "name": "flags",
          "description": "Trace flags."
        },
        {
          "name": "entity",
          "description": "Entity to clip to."
        }
      ],
      "error": [
        "Invalid entity."
      ],
      "note": [],
      "return": "Ray trace handle, which must be closed via CloseHandle()."
    },
    "params": [
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "Trace flags."
      },
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity to clip to."
      }
    ],
    "full_declaration": "native Handle TR_ClipCurrentRayToEntityEx(int flags, int entity);"
  },
  {
    "name": "TR_GetFraction",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "float",
    "comment": "Returns the time fraction from a trace result (1.0 means no collision).",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Time fraction value of the trace."
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": "",
        "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
      }
    ],
    "full_declaration": "native float TR_GetFraction(Handle hndl=INVALID_HANDLE);"
  },
  {
    "name": "TR_GetFractionLeftSolid",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "float",
    "comment": "Returns the time fraction from a trace result when it left a solid.\nOnly valid if trace started in solid",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Time fraction left solid value of the trace."
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": "",
        "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
      }
    ],
    "full_declaration": "native float TR_GetFractionLeftSolid(Handle hndl=INVALID_HANDLE);"
  },
  {
    "name": "TR_GetStartPosition",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "void",
    "comment": "Returns the starting position of a trace.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
        },
        {
          "name": "pos",
          "description": "Vector buffer to store data in."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": null,
        "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
      },
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Vector buffer to store data in."
      }
    ],
    "full_declaration": "native void TR_GetStartPosition(Handle hndl, float pos[3]);"
  },
  {
    "name": "TR_GetEndPosition",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "void",
    "comment": "Returns the collision position of a trace result.",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Vector buffer to store data in."
        },
        {
          "name": "hndl",
          "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Vector buffer to store data in."
      },
      {
        "name": "hndl",
        "type": "Handle",
        "default": "",
        "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
      }
    ],
    "full_declaration": "native void TR_GetEndPosition(float pos[3], Handle hndl=INVALID_HANDLE);"
  },
  {
    "name": "TR_GetEntityIndex",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "int",
    "comment": "Returns the entity index that collided with the trace.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Entity index or -1 for no collision."
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": "",
        "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
      }
    ],
    "full_declaration": "native int TR_GetEntityIndex(Handle hndl=INVALID_HANDLE);"
  },
  {
    "name": "TR_GetDisplacementFlags",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "int",
    "comment": "Returns the displacement flags for the surface that was hit. See DISPSURF_FLAG_*.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Displacement flags."
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": "",
        "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
      }
    ],
    "full_declaration": "native int TR_GetDisplacementFlags(Handle hndl=INVALID_HANDLE);"
  },
  {
    "name": "TR_GetSurfaceName",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "void",
    "comment": "Returns the name of the surface that was hit.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
        },
        {
          "name": "buffer",
          "description": "Buffer to store surface name in"
        },
        {
          "name": "maxlen",
          "description": "Maximum length of output buffer"
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": null,
        "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store surface name in"
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "Maximum length of output buffer"
      }
    ],
    "full_declaration": "native void TR_GetSurfaceName(Handle hndl, char[] buffer, int maxlen);"
  },
  {
    "name": "TR_GetSurfaceProps",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "int",
    "comment": "Returns the surface properties index of the surface that was hit.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Surface props."
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": "",
        "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
      }
    ],
    "full_declaration": "native int TR_GetSurfaceProps(Handle hndl=INVALID_HANDLE);"
  },
  {
    "name": "TR_GetSurfaceFlags",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "int",
    "comment": "Returns the surface flags. See SURF_*.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Surface flags."
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": "",
        "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
      }
    ],
    "full_declaration": "native int TR_GetSurfaceFlags(Handle hndl=INVALID_HANDLE);"
  },
  {
    "name": "TR_GetPhysicsBone",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "int",
    "comment": "Returns the index of the physics bone that was hit.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Physics bone index."
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": "",
        "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
      }
    ],
    "full_declaration": "native int TR_GetPhysicsBone(Handle hndl=INVALID_HANDLE);"
  },
  {
    "name": "TR_AllSolid",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "bool",
    "comment": "Returns whether the entire trace was in a solid area.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True if entire trace was in a solid area, otherwise false."
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": "",
        "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
      }
    ],
    "full_declaration": "native bool TR_AllSolid(Handle hndl=INVALID_HANDLE);"
  },
  {
    "name": "TR_StartSolid",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "bool",
    "comment": "Returns whether the initial point was in a solid area.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True if initial point was in a solid area, otherwise false."
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": "",
        "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
      }
    ],
    "full_declaration": "native bool TR_StartSolid(Handle hndl=INVALID_HANDLE);"
  },
  {
    "name": "TR_DidHit",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "bool",
    "comment": "Returns if there was any kind of collision along the trace ray.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True if any collision found, otherwise false."
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": "",
        "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
      }
    ],
    "full_declaration": "native bool TR_DidHit(Handle hndl=INVALID_HANDLE);"
  },
  {
    "name": "TR_GetHitGroup",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "int",
    "comment": "Returns in which body hit group the trace collided if any.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Body hit group."
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": "",
        "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
      }
    ],
    "full_declaration": "native int TR_GetHitGroup(Handle hndl=INVALID_HANDLE);"
  },
  {
    "name": "TR_GetHitBoxIndex",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "int",
    "comment": "Returns in which hitbox the trace collided if any.\n\nNote: if the entity that collided with the trace is the world entity,\nthen this function doesn't return an hitbox index but a static prop index.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Hitbox index (Or static prop index)."
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": "",
        "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
      }
    ],
    "full_declaration": "native int TR_GetHitBoxIndex(Handle hndl=INVALID_HANDLE);"
  },
  {
    "name": "TR_GetPlaneNormal",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "void",
    "comment": "Find the normal vector to the collision plane of a trace.",
    "tags": {
      "param": [
        {
          "name": "hndl",
          "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
        },
        {
          "name": "normal",
          "description": "Vector buffer to store the vector normal to the collision plane"
        }
      ],
      "error": [
        "Invalid Handle"
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "hndl",
        "type": "Handle",
        "default": null,
        "description": "A trace Handle, or INVALID_HANDLE to use a global trace result."
      },
      {
        "name": "normal",
        "type": "float",
        "default": null,
        "description": "Vector buffer to store the vector normal to the collision plane"
      }
    ],
    "full_declaration": "native void TR_GetPlaneNormal(Handle hndl, float normal[3]);"
  },
  {
    "name": "TR_PointOutsideWorld",
    "type": "native",
    "source_file": "sdktools_trace.inc",
    "return_type": "bool",
    "comment": "Tests a point to see if it's outside any playable area",
    "tags": {
      "param": [
        {
          "name": "pos",
          "description": "Vector buffer to store data in."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if outside world, otherwise false."
    },
    "params": [
      {
        "name": "pos",
        "type": "float",
        "default": null,
        "description": "Vector buffer to store data in."
      }
    ],
    "full_declaration": "native bool TR_PointOutsideWorld(float pos[3]);"
  },
  {
    "name": "SetVariantBool",
    "type": "native",
    "source_file": "sdktools_variant_t.inc",
    "return_type": "void",
    "comment": "Sets a bool value in the global variant object.",
    "tags": {
      "param": [
        {
          "name": "val",
          "description": "Input value."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "val",
        "type": "bool",
        "default": null,
        "description": "Input value."
      }
    ],
    "full_declaration": "native void SetVariantBool(bool val);"
  },
  {
    "name": "SetVariantString",
    "type": "native",
    "source_file": "sdktools_variant_t.inc",
    "return_type": "void",
    "comment": "Sets a string in the global variant object.",
    "tags": {
      "param": [
        {
          "name": "str",
          "description": "Input string."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "str",
        "type": "char[]",
        "default": null,
        "description": "Input string."
      }
    ],
    "full_declaration": "native void SetVariantString(const char[] str);"
  },
  {
    "name": "SetVariantInt",
    "type": "native",
    "source_file": "sdktools_variant_t.inc",
    "return_type": "void",
    "comment": "Sets an integer value in the global variant object.",
    "tags": {
      "param": [
        {
          "name": "val",
          "description": "Input value."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "val",
        "type": "int",
        "default": null,
        "description": "Input value."
      }
    ],
    "full_declaration": "native void SetVariantInt(int val);"
  },
  {
    "name": "SetVariantFloat",
    "type": "native",
    "source_file": "sdktools_variant_t.inc",
    "return_type": "void",
    "comment": "Sets a floating point value in the global variant object.",
    "tags": {
      "param": [
        {
          "name": "val",
          "description": "Input value."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "val",
        "type": "float",
        "default": null,
        "description": "Input value."
      }
    ],
    "full_declaration": "native void SetVariantFloat(float val);"
  },
  {
    "name": "SetVariantVector3D",
    "type": "native",
    "source_file": "sdktools_variant_t.inc",
    "return_type": "void",
    "comment": "Sets a 3D vector in the global variant object.",
    "tags": {
      "param": [
        {
          "name": "vec",
          "description": "Input vector."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Input vector."
      }
    ],
    "full_declaration": "native void SetVariantVector3D(const float vec[3]);"
  },
  {
    "name": "SetVariantPosVector3D",
    "type": "native",
    "source_file": "sdktools_variant_t.inc",
    "return_type": "void",
    "comment": "Sets a 3D position vector in the global variant object.",
    "tags": {
      "param": [
        {
          "name": "vec",
          "description": "Input position vector."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Input position vector."
      }
    ],
    "full_declaration": "native void SetVariantPosVector3D(const float vec[3]);"
  },
  {
    "name": "SetVariantColor",
    "type": "native",
    "source_file": "sdktools_variant_t.inc",
    "return_type": "void",
    "comment": "Sets a color in the global variant object.",
    "tags": {
      "param": [
        {
          "name": "color",
          "description": "Input color."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "color",
        "type": "int",
        "default": null,
        "description": "Input color."
      }
    ],
    "full_declaration": "native void SetVariantColor(const int color[4]);"
  },
  {
    "name": "SetVariantEntity",
    "type": "native",
    "source_file": "sdktools_variant_t.inc",
    "return_type": "void",
    "comment": "Sets an entity in the global variant object.",
    "tags": {
      "param": [
        {
          "name": "entity",
          "description": "Entity index."
        }
      ],
      "error": [
        "Invalid entity index."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "entity",
        "type": "int",
        "default": null,
        "description": "Entity index."
      }
    ],
    "full_declaration": "native void SetVariantEntity(int entity);"
  },
  {
    "name": "OnClientSpeaking",
    "type": "forward",
    "source_file": "sdktools_voice.inc",
    "return_type": "void",
    "comment": "Called when a client is speaking.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "The client index"
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "The client index"
      }
    ],
    "full_declaration": "forward void OnClientSpeaking(int client);"
  },
  {
    "name": "OnClientSpeakingEnd",
    "type": "forward",
    "source_file": "sdktools_voice.inc",
    "return_type": "void",
    "comment": "Called once a client speaking end.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "The client index"
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "The client index"
      }
    ],
    "full_declaration": "forward void OnClientSpeakingEnd(int client);"
  },
  {
    "name": "SetClientListeningFlags",
    "type": "native",
    "source_file": "sdktools_voice.inc",
    "return_type": "void",
    "comment": "Set the client listening flags.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "The client index"
        },
        {
          "name": "flags",
          "description": "The voice flags"
        }
      ],
      "error": [
        "Invalid client index or client not connected."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "The client index"
      },
      {
        "name": "flags",
        "type": "int",
        "default": null,
        "description": "The voice flags"
      }
    ],
    "full_declaration": "native void SetClientListeningFlags(int client, int flags);"
  },
  {
    "name": "GetClientListeningFlags",
    "type": "native",
    "source_file": "sdktools_voice.inc",
    "return_type": "int",
    "comment": "Retrieve the client current listening flags.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "The client index"
        }
      ],
      "error": [
        "Invalid client index or client not connected."
      ],
      "note": [],
      "return": "The current voice flags"
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "The client index"
      }
    ],
    "full_declaration": "native int GetClientListeningFlags(int client);"
  },
  {
    "name": "SetClientListening",
    "type": "native",
    "source_file": "sdktools_voice.inc",
    "return_type": "bool",
    "comment": "Set the receiver ability to listen to the sender.",
    "tags": {
      "param": [
        {
          "name": "iReceiver",
          "description": "The listener index."
        },
        {
          "name": "iSender",
          "description": "The sender index."
        },
        {
          "name": "bListen",
          "description": "True if the receiver can listen to the sender, false otherwise."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if successful otherwise false.",
      "deprecated": [
        "Use SetListenOverride() instead."
      ]
    },
    "params": [
      {
        "name": "iReceiver",
        "type": "int",
        "default": null,
        "description": "The listener index."
      },
      {
        "name": "iSender",
        "type": "int",
        "default": null,
        "description": "The sender index."
      },
      {
        "name": "bListen",
        "type": "bool",
        "default": null,
        "description": "True if the receiver can listen to the sender, false otherwise."
      }
    ],
    "full_declaration": "native bool SetClientListening(int iReceiver, int iSender, bool bListen);"
  },
  {
    "name": "GetClientListening",
    "type": "native",
    "source_file": "sdktools_voice.inc",
    "return_type": "bool",
    "comment": "Retrieves if the receiver can listen to the sender.",
    "tags": {
      "param": [
        {
          "name": "iReceiver",
          "description": "The listener index."
        },
        {
          "name": "iSender",
          "description": "The sender index."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if successful otherwise false.",
      "deprecated": [
        "GetListenOverride() instead."
      ]
    },
    "params": [
      {
        "name": "iReceiver",
        "type": "int",
        "default": null,
        "description": "The listener index."
      },
      {
        "name": "iSender",
        "type": "int",
        "default": null,
        "description": "The sender index."
      }
    ],
    "full_declaration": "native bool GetClientListening(int iReceiver, int iSender);"
  },
  {
    "name": "SetListenOverride",
    "type": "native",
    "source_file": "sdktools_voice.inc",
    "return_type": "bool",
    "comment": "Override the receiver's ability to listen to the sender.",
    "tags": {
      "param": [
        {
          "name": "iReceiver",
          "description": "The listener index."
        },
        {
          "name": "iSender",
          "description": "The sender index."
        },
        {
          "name": "override",
          "description": "The override of the receiver's ability to listen to the sender."
        }
      ],
      "error": [
        "Listener or sender client index is invalid or not connected."
      ],
      "note": [],
      "return": "True if successful otherwise false."
    },
    "params": [
      {
        "name": "iReceiver",
        "type": "int",
        "default": null,
        "description": "The listener index."
      },
      {
        "name": "iSender",
        "type": "int",
        "default": null,
        "description": "The sender index."
      },
      {
        "name": "override",
        "type": "ListenOverride",
        "default": null,
        "description": "The override of the receiver's ability to listen to the sender."
      }
    ],
    "full_declaration": "native bool SetListenOverride(int iReceiver, int iSender, ListenOverride override);"
  },
  {
    "name": "GetListenOverride",
    "type": "native",
    "source_file": "sdktools_voice.inc",
    "return_type": "ListenOverride",
    "comment": "Retrieves the override of the receiver's ability to listen to the sender.",
    "tags": {
      "param": [
        {
          "name": "iReceiver",
          "description": "The listener index."
        },
        {
          "name": "iSender",
          "description": "The sender index."
        }
      ],
      "error": [
        "Listener or sender client index is invalid or not connected."
      ],
      "note": [],
      "return": "The override value."
    },
    "params": [
      {
        "name": "iReceiver",
        "type": "int",
        "default": null,
        "description": "The listener index."
      },
      {
        "name": "iSender",
        "type": "int",
        "default": null,
        "description": "The sender index."
      }
    ],
    "full_declaration": "native ListenOverride GetListenOverride(int iReceiver, int iSender);"
  },
  {
    "name": "IsClientMuted",
    "type": "native",
    "source_file": "sdktools_voice.inc",
    "return_type": "bool",
    "comment": "Retrieves if the muter has muted the mutee.",
    "tags": {
      "param": [
        {
          "name": "iMuter",
          "description": "The muter index."
        },
        {
          "name": "iMutee",
          "description": "The mutee index."
        }
      ],
      "error": [
        "Muter or mutee client index is invalid or not connected."
      ],
      "note": [],
      "return": "True if muter has muted mutee, false otherwise."
    },
    "params": [
      {
        "name": "iMuter",
        "type": "int",
        "default": null,
        "description": "The muter index."
      },
      {
        "name": "iMutee",
        "type": "int",
        "default": null,
        "description": "The mutee index."
      }
    ],
    "full_declaration": "native bool IsClientMuted(int iMuter, int iMutee);"
  },
  {
    "name": "SortIntegers",
    "type": "native",
    "source_file": "sorting.inc",
    "return_type": "void",
    "comment": "Sorts an array of integers.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array of integers to sort in-place."
        },
        {
          "name": "array_size",
          "description": "Size of the array."
        },
        {
          "name": "order",
          "description": "Sorting order to use."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "array",
        "type": "int[]",
        "default": null,
        "description": "Array of integers to sort in-place."
      },
      {
        "name": "array_size",
        "type": "int",
        "default": null,
        "description": "Size of the array."
      },
      {
        "name": "order",
        "type": "SortOrder",
        "default": "",
        "description": "Sorting order to use."
      }
    ],
    "full_declaration": "native void SortIntegers(int[] array, int array_size, SortOrder order = Sort_Ascending);"
  },
  {
    "name": "SortFloats",
    "type": "native",
    "source_file": "sorting.inc",
    "return_type": "void",
    "comment": "Sorts an array of float point numbers.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array of floating point numbers to sort in-place."
        },
        {
          "name": "array_size",
          "description": "Size of the array."
        },
        {
          "name": "order",
          "description": "Sorting order to use."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "array",
        "type": "float[]",
        "default": null,
        "description": "Array of floating point numbers to sort in-place."
      },
      {
        "name": "array_size",
        "type": "int",
        "default": null,
        "description": "Size of the array."
      },
      {
        "name": "order",
        "type": "SortOrder",
        "default": "",
        "description": "Sorting order to use."
      }
    ],
    "full_declaration": "native void SortFloats(float[] array, int array_size, SortOrder order = Sort_Ascending);"
  },
  {
    "name": "SortStrings",
    "type": "native",
    "source_file": "sorting.inc",
    "return_type": "void",
    "comment": "Sorts an array of strings.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array of strings to sort in-place."
        },
        {
          "name": "array_size",
          "description": "Size of the array."
        },
        {
          "name": "order",
          "description": "Sorting order to use."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "array",
        "type": "char[][]",
        "default": null,
        "description": "Array of strings to sort in-place."
      },
      {
        "name": "array_size",
        "type": "int",
        "default": null,
        "description": "Size of the array."
      },
      {
        "name": "order",
        "type": "SortOrder",
        "default": "",
        "description": "Sorting order to use."
      }
    ],
    "full_declaration": "native void SortStrings(char[][] array, int array_size, SortOrder order = Sort_Ascending);"
  },
  {
    "name": "SortFunc1D",
    "type": "typedef",
    "source_file": "sorting.inc",
    "return_type": "int",
    "comment": "Sort comparison function for 1D array elements.",
    "tags": {
      "param": [
        {
          "name": "elem1",
          "description": "First element to compare."
        },
        {
          "name": "elem2",
          "description": "Second element to compare."
        },
        {
          "name": "array",
          "description": "Array that is being sorted (order is undefined)."
        },
        {
          "name": "hndl",
          "description": "Handle optionally passed in while sorting."
        }
      ],
      "error": [],
      "note": [
        "You may need to use explicit tags in order to use data properly."
      ],
      "return": "-1 if first should go before second 0 if first is equal to second 1 if first should go after second"
    },
    "params": [
      {
        "name": "elem1",
        "type": "int",
        "default": null,
        "description": "First element to compare."
      },
      {
        "name": "elem2",
        "type": "int",
        "default": null,
        "description": "Second element to compare."
      },
      {
        "name": "array",
        "type": "int[]",
        "default": null,
        "description": "Array that is being sorted (order is undefined)."
      },
      {
        "name": "hndl",
        "type": "Handle",
        "default": null,
        "description": "Handle optionally passed in while sorting."
      }
    ],
    "full_declaration": "typedef SortFunc1D = function int (int elem1, int elem2, const int[] array, Handle hndl);"
  },
  {
    "name": "SortCustom1D",
    "type": "native",
    "source_file": "sorting.inc",
    "return_type": "void",
    "comment": "Sorts a custom 1D array.  You must pass in a comparison function.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array to sort."
        },
        {
          "name": "array_size",
          "description": "Size of the array to sort."
        },
        {
          "name": "sortfunc",
          "description": "Sort function."
        },
        {
          "name": "hndl",
          "description": "Optional Handle to pass through the comparison calls."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "array",
        "type": "int[]",
        "default": null,
        "description": "Array to sort."
      },
      {
        "name": "array_size",
        "type": "int",
        "default": null,
        "description": "Size of the array to sort."
      },
      {
        "name": "sortfunc",
        "type": "SortFunc1D",
        "default": null,
        "description": "Sort function."
      },
      {
        "name": "hndl",
        "type": "Handle",
        "default": "",
        "description": "Optional Handle to pass through the comparison calls."
      }
    ],
    "full_declaration": "native void SortCustom1D(int[] array, int array_size, SortFunc1D sortfunc, Handle hndl=INVALID_HANDLE);"
  },
  {
    "name": "SortCustom2D",
    "type": "native",
    "source_file": "sorting.inc",
    "return_type": "void",
    "comment": "Sorts a custom 2D array.  You must pass in a comparison function.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array to sort."
        },
        {
          "name": "array_size",
          "description": "Size of the major array to sort (first index, outermost)."
        },
        {
          "name": "sortfunc",
          "description": "Sort comparison function to use."
        },
        {
          "name": "hndl",
          "description": "Optional Handle to pass through the comparison calls."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "array",
        "type": "any[][]",
        "default": null,
        "description": "Array to sort."
      },
      {
        "name": "array_size",
        "type": "int",
        "default": null,
        "description": "Size of the major array to sort (first index, outermost)."
      },
      {
        "name": "sortfunc",
        "type": "SortFunc2D",
        "default": null,
        "description": "Sort comparison function to use."
      },
      {
        "name": "hndl",
        "type": "Handle",
        "default": "",
        "description": "Optional Handle to pass through the comparison calls."
      }
    ],
    "full_declaration": "native void SortCustom2D(any[][] array, int array_size, SortFunc2D sortfunc, Handle hndl=INVALID_HANDLE);"
  },
  {
    "name": "SortADTArray",
    "type": "native",
    "source_file": "sorting.inc",
    "return_type": "void",
    "comment": "Sort an ADT Array. Specify the type as Integer, Float, or String.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array Handle to sort"
        },
        {
          "name": "order",
          "description": "Sort order to use, same as other sorts."
        },
        {
          "name": "type",
          "description": "Data type stored in the ADT Array"
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "array",
        "type": "Handle",
        "default": null,
        "description": "Array Handle to sort"
      },
      {
        "name": "order",
        "type": "SortOrder",
        "default": null,
        "description": "Sort order to use, same as other sorts."
      },
      {
        "name": "type",
        "type": "SortType",
        "default": null,
        "description": "Data type stored in the ADT Array"
      }
    ],
    "full_declaration": "native void SortADTArray(Handle array, SortOrder order, SortType type);"
  },
  {
    "name": "SortFuncADTArray",
    "type": "typedef",
    "source_file": "sorting.inc",
    "return_type": "int",
    "comment": "Sort comparison function for ADT Array elements. Function provides you with\nindexes currently being sorted, use ADT Array functions to retrieve the\nindex values and compare.",
    "tags": {
      "param": [
        {
          "name": "index1",
          "description": "First index to compare."
        },
        {
          "name": "index2",
          "description": "Second index to compare."
        },
        {
          "name": "array",
          "description": "Array that is being sorted (order is undefined)."
        },
        {
          "name": "hndl",
          "description": "Handle optionally passed in while sorting."
        }
      ],
      "error": [],
      "note": [],
      "return": "-1 if first should go before second 0 if first is equal to second 1 if first should go after second"
    },
    "params": [
      {
        "name": "index1",
        "type": "int",
        "default": null,
        "description": "First index to compare."
      },
      {
        "name": "index2",
        "type": "int",
        "default": null,
        "description": "Second index to compare."
      },
      {
        "name": "array",
        "type": "Handle",
        "default": null,
        "description": "Array that is being sorted (order is undefined)."
      },
      {
        "name": "hndl",
        "type": "Handle",
        "default": null,
        "description": "Handle optionally passed in while sorting."
      }
    ],
    "full_declaration": "typedef SortFuncADTArray = function int (int index1, int index2, Handle array, Handle hndl);"
  },
  {
    "name": "SortADTArrayCustom",
    "type": "native",
    "source_file": "sorting.inc",
    "return_type": "void",
    "comment": "Custom sorts an ADT Array. You must pass in a comparison function.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array Handle to sort"
        },
        {
          "name": "sortfunc",
          "description": "Sort comparison function to use"
        },
        {
          "name": "hndl",
          "description": "Optional Handle to pass through the comparison calls."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "array",
        "type": "Handle",
        "default": null,
        "description": "Array Handle to sort"
      },
      {
        "name": "sortfunc",
        "type": "SortFuncADTArray",
        "default": null,
        "description": "Sort comparison function to use"
      },
      {
        "name": "hndl",
        "type": "Handle",
        "default": "",
        "description": "Optional Handle to pass through the comparison calls."
      }
    ],
    "full_declaration": "native void SortADTArrayCustom(Handle array, SortFuncADTArray sortfunc, Handle hndl=INVALID_HANDLE);"
  },
  {
    "name": "OnPluginStart",
    "type": "forward",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "Called when the plugin is fully initialized and all known external references\nare resolved. This is only called once in the lifetime of the plugin, and is\npaired with OnPluginEnd().\n\nIf any run-time error is thrown during this callback, the plugin will be marked\nas failed.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [],
    "full_declaration": "forward void OnPluginStart();"
  },
  {
    "name": "AskPluginLoad",
    "type": "forward",
    "source_file": "sourcemod.inc",
    "return_type": "bool",
    "comment": "@deprecated Use AskPluginLoad2() instead.\nIf a plugin contains both AskPluginLoad() and AskPluginLoad2(), the former will\nnot be called, but old plugins with only AskPluginLoad() will work.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "myself",
        "type": "Handle",
        "default": null,
        "description": ""
      },
      {
        "name": "late",
        "type": "bool",
        "default": null,
        "description": ""
      },
      {
        "name": "error",
        "type": "char[]",
        "default": null,
        "description": ""
      },
      {
        "name": "err_max",
        "type": "int",
        "default": null,
        "description": ""
      }
    ],
    "full_declaration": "forward bool AskPluginLoad(Handle myself, bool late, char[] error, int err_max);"
  },
  {
    "name": "AskPluginLoad2",
    "type": "forward",
    "source_file": "sourcemod.inc",
    "return_type": "APLRes",
    "comment": "Called before OnPluginStart, in case the plugin wants to check for load failure.\nThis is called even if the plugin type is \"private.\"  Any natives from modules are\nnot available at this point.  Thus, this forward should only be used for explicit\npre-emptive things, such as adding dynamic natives, setting certain types of load\nfilters (such as not loading the plugin for certain games).",
    "tags": {
      "param": [
        {
          "name": "myself",
          "description": "Handle to the plugin."
        },
        {
          "name": "late",
          "description": "Whether or not the plugin was loaded \"late\" (after map load)."
        },
        {
          "name": "error",
          "description": "Error message buffer in case load failed."
        },
        {
          "name": "err_max",
          "description": "Maximum number of characters for error message buffer."
        }
      ],
      "error": [],
      "note": [
        "It is not safe to call externally resolved natives until OnPluginStart().",
        "Any sort of RTE in this function will cause the plugin to fail loading.",
        "If you do not return anything, it is treated like returning success.",
        "If a plugin has an AskPluginLoad2(), AskPluginLoad() will not be called."
      ],
      "return": "APLRes_Success for load success, APLRes_Failure or APLRes_SilentFailure otherwise"
    },
    "params": [
      {
        "name": "myself",
        "type": "Handle",
        "default": null,
        "description": "Handle to the plugin."
      },
      {
        "name": "late",
        "type": "bool",
        "default": null,
        "description": "Whether or not the plugin was loaded \"late\" (after map load)."
      },
      {
        "name": "error",
        "type": "char[]",
        "default": null,
        "description": "Error message buffer in case load failed."
      },
      {
        "name": "err_max",
        "type": "int",
        "default": null,
        "description": "Maximum number of characters for error message buffer."
      }
    ],
    "full_declaration": "forward APLRes AskPluginLoad2(Handle myself, bool late, char[] error, int err_max);"
  },
  {
    "name": "OnPluginEnd",
    "type": "forward",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "Called when the plugin is about to be unloaded.\n\nIt is not necessary to close any handles or remove hooks in this function.\nSourceMod guarantees that plugin shutdown automatically and correctly releases\nall resources.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [],
    "full_declaration": "forward void OnPluginEnd();"
  },
  {
    "name": "OnPluginPauseChange",
    "type": "forward",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "Called when the plugin's pause status is changing.",
    "tags": {
      "param": [
        {
          "name": "pause",
          "description": "True if the plugin is being paused, false otherwise."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "pause",
        "type": "bool",
        "default": null,
        "description": "True if the plugin is being paused, false otherwise."
      }
    ],
    "full_declaration": "forward void OnPluginPauseChange(bool pause);"
  },
  {
    "name": "OnGameFrame",
    "type": "forward",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "Called before every server frame.  Note that you should avoid\ndoing expensive computations or declaring large local arrays.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [],
    "full_declaration": "forward void OnGameFrame();"
  },
  {
    "name": "OnMapInit",
    "type": "forward",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "Called when the map starts loading.",
    "tags": {
      "param": [
        {
          "name": "mapName",
          "description": "Name of the map"
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "mapName",
        "type": "char[]",
        "default": null,
        "description": "Name of the map"
      }
    ],
    "full_declaration": "forward void OnMapInit(const char[] mapName);"
  },
  {
    "name": "OnMapStart",
    "type": "forward",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "Called when the map is loaded.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [],
    "full_declaration": "forward void OnMapStart();"
  },
  {
    "name": "OnMapEnd",
    "type": "forward",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "Called right before a map ends.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [],
    "full_declaration": "forward void OnMapEnd();"
  },
  {
    "name": "OnConfigsExecuted",
    "type": "forward",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "Called when the map has loaded, servercfgfile (server.cfg) has been\nexecuted, and all plugin configs are done executing.  This is the best\nplace to initialize plugin functions which are based on cvar data.",
    "tags": {
      "param": [],
      "error": [],
      "note": [
        "This will always be called once and only once per map.  It will be called after OnMapStart()."
      ],
      "return": ""
    },
    "params": [],
    "full_declaration": "forward void OnConfigsExecuted();"
  },
  {
    "name": "OnAutoConfigsBuffered",
    "type": "forward",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "This is called once, right after OnMapStart() but any time before\nOnConfigsExecuted().  It is called after the \"exec sourcemod.cfg\"\ncommand and all AutoExecConfig() exec commands have been added to\nthe ServerCommand() buffer.\n\nIf you need to load per-map settings that override default values,\nadding commands to the ServerCommand() buffer here will guarantee\nthat they're set before OnConfigsExecuted().\n\nUnlike OnMapStart() and OnConfigsExecuted(), this is not called on\nlate loads that occur after OnMapStart().",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [],
    "full_declaration": "forward void OnAutoConfigsBuffered();"
  },
  {
    "name": "OnServerCfg",
    "type": "forward",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "@deprecated          Use OnConfigsExecuted() instead.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [],
    "full_declaration": "forward void OnServerCfg();"
  },
  {
    "name": "OnAllPluginsLoaded",
    "type": "forward",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "Called after all plugins have been loaded.  This is called once for\nevery plugin.  If a plugin late loads, it will be called immediately\nafter OnPluginStart().",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [],
    "full_declaration": "forward void OnAllPluginsLoaded();"
  },
  {
    "name": "GetMyHandle",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "Handle",
    "comment": "Returns the calling plugin's Handle.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "Handle of the calling plugin."
    },
    "params": [],
    "full_declaration": "native Handle GetMyHandle();"
  },
  {
    "name": "GetPluginIterator",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "Handle",
    "comment": "Returns an iterator that can be used to search through plugins.",
    "tags": {
      "param": [],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Handle to iterate with.  Must be closed via CloseHandle()."
    },
    "params": [],
    "full_declaration": "native Handle GetPluginIterator();"
  },
  {
    "name": "MorePlugins",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "bool",
    "comment": "Returns whether there are more plugins available in the iterator.",
    "tags": {
      "param": [
        {
          "name": "iter",
          "description": "Handle to the plugin iterator."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on more plugins, false otherwise."
    },
    "params": [
      {
        "name": "iter",
        "type": "Handle",
        "default": null,
        "description": "Handle to the plugin iterator."
      }
    ],
    "full_declaration": "native bool MorePlugins(Handle iter);"
  },
  {
    "name": "ReadPlugin",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "Handle",
    "comment": "Returns the current plugin in the iterator and advances the iterator.",
    "tags": {
      "param": [
        {
          "name": "iter",
          "description": "Handle to the plugin iterator."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Current plugin the iterator is at, before the iterator is advanced."
    },
    "params": [
      {
        "name": "iter",
        "type": "Handle",
        "default": null,
        "description": "Handle to the plugin iterator."
      }
    ],
    "full_declaration": "native Handle ReadPlugin(Handle iter);"
  },
  {
    "name": "GetPluginStatus",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "PluginStatus",
    "comment": "Returns a plugin's status.",
    "tags": {
      "param": [
        {
          "name": "plugin",
          "description": "Plugin Handle (INVALID_HANDLE uses the calling plugin)."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "Status code for the plugin."
    },
    "params": [
      {
        "name": "plugin",
        "type": "Handle",
        "default": null,
        "description": "Plugin Handle (INVALID_HANDLE uses the calling plugin)."
      }
    ],
    "full_declaration": "native PluginStatus GetPluginStatus(Handle plugin);"
  },
  {
    "name": "GetPluginFilename",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "Retrieves a plugin's file name relative to the plugins folder.",
    "tags": {
      "param": [
        {
          "name": "plugin",
          "description": "Plugin Handle (INVALID_HANDLE uses the calling plugin)."
        },
        {
          "name": "buffer",
          "description": "Buffer to the store the file name."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of the name buffer."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "plugin",
        "type": "Handle",
        "default": null,
        "description": "Plugin Handle (INVALID_HANDLE uses the calling plugin)."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Buffer to the store the file name."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the name buffer."
      }
    ],
    "full_declaration": "native void GetPluginFilename(Handle plugin, char[] buffer, int maxlength);"
  },
  {
    "name": "IsPluginDebugging",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "bool",
    "comment": "Retrieves whether or not a plugin is being debugged.",
    "tags": {
      "param": [
        {
          "name": "plugin",
          "description": "Plugin Handle (INVALID_HANDLE uses the calling plugin)."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True if being debugged, false otherwise."
    },
    "params": [
      {
        "name": "plugin",
        "type": "Handle",
        "default": null,
        "description": "Plugin Handle (INVALID_HANDLE uses the calling plugin)."
      }
    ],
    "full_declaration": "native bool IsPluginDebugging(Handle plugin);"
  },
  {
    "name": "GetPluginInfo",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "bool",
    "comment": "Retrieves a plugin's public info.",
    "tags": {
      "param": [
        {
          "name": "plugin",
          "description": "Plugin Handle (INVALID_HANDLE uses the calling plugin)."
        },
        {
          "name": "info",
          "description": "Plugin info property to retrieve."
        },
        {
          "name": "buffer",
          "description": "Buffer to store info in."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of buffer."
        }
      ],
      "error": [
        "Invalid Handle."
      ],
      "note": [],
      "return": "True on success, false if property is not available."
    },
    "params": [
      {
        "name": "plugin",
        "type": "Handle",
        "default": null,
        "description": "Plugin Handle (INVALID_HANDLE uses the calling plugin)."
      },
      {
        "name": "info",
        "type": "PluginInfo",
        "default": null,
        "description": "Plugin info property to retrieve."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store info in."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of buffer."
      }
    ],
    "full_declaration": "native bool GetPluginInfo(Handle plugin, PluginInfo info, char[] buffer, int maxlength);"
  },
  {
    "name": "FindPluginByNumber",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "Handle",
    "comment": "Finds a plugin by its order in the list from the \"plugins list\" server\n\"sm\" command.  You should not use this function to loop through all plugins,\nuse the iterator instead.  Looping through all plugins using this native\nis O(n^2), whereas using the iterator is O(n).",
    "tags": {
      "param": [
        {
          "name": "order_num",
          "description": "Number of the plugin as it appears in \"sm plugins list\"."
        }
      ],
      "error": [],
      "note": [],
      "return": "Plugin Handle on success, INVALID_HANDLE if no plugin matches the given number."
    },
    "params": [
      {
        "name": "order_num",
        "type": "int",
        "default": null,
        "description": "Number of the plugin as it appears in \"sm plugins list\"."
      }
    ],
    "full_declaration": "native Handle FindPluginByNumber(int order_num);"
  },
  {
    "name": "SetFailState",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "Causes the plugin to enter a failed state.  An error will be thrown and\nthe plugin will be paused until it is unloaded or reloaded.\n\nFor backwards compatibility, if no extra arguments are passed, no\nformatting is applied.  If one or more additional arguments is passed,\nthe string is formatted using Format().  If any errors are encountered\nduring formatting, both the format specifier string and an additional\nerror message are written.\n\nThis function does not return, and no further code in the plugin is\nexecuted.",
    "tags": {
      "param": [
        {
          "name": "string",
          "description": "Format specifier string."
        }
      ],
      "error": [
        "Always throws SP_ERROR_ABORT."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "string",
        "type": "char[]",
        "default": null,
        "description": "Format specifier string."
      }
    ],
    "full_declaration": "native void SetFailState(const char[] string, any ...);"
  },
  {
    "name": "ThrowError",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "Aborts the current callback and throws an error.  This function\ndoes not return in that no code is executed following it.",
    "tags": {
      "param": [
        {
          "name": "fmt",
          "description": "String format."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "fmt",
        "type": "char[]",
        "default": null,
        "description": "String format."
      }
    ],
    "full_declaration": "native void ThrowError(const char[] fmt, any ...);"
  },
  {
    "name": "LogStackTrace",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "Logs a stack trace from the current function call. Code\nexecution continues after the call",
    "tags": {
      "param": [
        {
          "name": "fmt",
          "description": "Format string to send with the stack trace."
        }
      ],
      "error": [
        "Always logs a stack trace."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "fmt",
        "type": "char[]",
        "default": null,
        "description": "Format string to send with the stack trace."
      }
    ],
    "full_declaration": "native void LogStackTrace(const char[] fmt, any ...);"
  },
  {
    "name": "GetTime",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "int",
    "comment": "Gets the system time as a unix timestamp.",
    "tags": {
      "param": [
        {
          "name": "bigStamp",
          "description": "Optional array to store the 64bit timestamp in."
        }
      ],
      "error": [],
      "note": [],
      "return": "32bit timestamp (number of seconds since unix epoch)."
    },
    "params": [
      {
        "name": "bigStamp",
        "type": "int",
        "default": null,
        "description": "Optional array to store the 64bit timestamp in."
      }
    ],
    "full_declaration": "native int GetTime(int bigStamp[2]={0,0});"
  },
  {
    "name": "FormatTime",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "Produces a date and/or time string value for a timestamp.\n\nSee this URL for valid parameters:\nhttps://cplusplus.com/reference/ctime/strftime/\n\nNote that available parameters depends on support from your operating system.\nIn particular, ones highlighted in yellow on that page are not currently\navailable on Windows and should be avoided for portable plugins.",
    "tags": {
      "param": [
        {
          "name": "buffer",
          "description": "Destination string buffer."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of output string buffer."
        },
        {
          "name": "format",
          "description": "Formatting rules (passing NULL_STRING will use the rules defined in sm_datetime_format)."
        },
        {
          "name": "stamp",
          "description": "Optional time stamp."
        }
      ],
      "error": [
        "Buffer too small or invalid time format."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Destination string buffer."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of output string buffer."
      },
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "Formatting rules (passing NULL_STRING will use the rules defined in sm_datetime_format)."
      },
      {
        "name": "stamp",
        "type": "int",
        "default": "",
        "description": "Optional time stamp."
      }
    ],
    "full_declaration": "native void FormatTime(char[] buffer, int maxlength, const char[] format, int stamp=-1);"
  },
  {
    "name": "ParseTime",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "int",
    "comment": "Parses a string representing a date and/or time into a unix timestamp.\nThe timezone is always interpreted as UTC/GMT.\n\nSee this URL for valid parameters:\nhttps://en.cppreference.com/w/cpp/io/manip/get_time\n\nNote that available parameters depends on support from your operating system.\nIn particular, ones highlighted in yellow on that page are not currently\navailable on Windows and should be avoided for portable plugins.",
    "tags": {
      "param": [
        {
          "name": "dateTime",
          "description": "Date and/or time string."
        },
        {
          "name": "format",
          "description": "Formatting rules (passing NULL_STRING will use the rules defined in sm_datetime_format)."
        }
      ],
      "error": [
        "Invalid date/time string or time format."
      ],
      "note": [],
      "return": "32bit timestamp (number of seconds since unix epoch)."
    },
    "params": [
      {
        "name": "dateTime",
        "type": "char[]",
        "default": null,
        "description": "Date and/or time string."
      },
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "Formatting rules (passing NULL_STRING will use the rules defined in sm_datetime_format)."
      }
    ],
    "full_declaration": "native int ParseTime(const char[] dateTime, const char[] format);"
  },
  {
    "name": "LoadGameConfigFile",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "GameData",
    "comment": "Loads a game config file.",
    "tags": {
      "param": [
        {
          "name": "file",
          "description": "File to load.  The path must be relative to the 'gamedata' folder under the config folder and the extension should be omitted."
        }
      ],
      "error": [],
      "note": [],
      "return": "A handle to the game config file or INVALID_HANDLE on failure."
    },
    "params": [
      {
        "name": "file",
        "type": "char[]",
        "default": null,
        "description": "File to load.  The path must be relative to the 'gamedata' folder under the config folder and the extension should be omitted."
      }
    ],
    "full_declaration": "native GameData LoadGameConfigFile(const char[] file);"
  },
  {
    "name": "GameConfGetOffset",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "int",
    "comment": "Returns an offset value.",
    "tags": {
      "param": [
        {
          "name": "gc",
          "description": "Game config handle."
        },
        {
          "name": "key",
          "description": "Key to retrieve from the offset section."
        }
      ],
      "error": [],
      "note": [],
      "return": "An offset, or -1 on failure."
    },
    "params": [
      {
        "name": "gc",
        "type": "Handle",
        "default": null,
        "description": "Game config handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Key to retrieve from the offset section."
      }
    ],
    "full_declaration": "native int GameConfGetOffset(Handle gc, const char[] key);"
  },
  {
    "name": "GameConfGetKeyValue",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "bool",
    "comment": "Gets the value of a key from the \"Keys\" section.",
    "tags": {
      "param": [
        {
          "name": "gc",
          "description": "Game config handle."
        },
        {
          "name": "key",
          "description": "Key to retrieve from the Keys section."
        },
        {
          "name": "buffer",
          "description": "Destination string buffer."
        },
        {
          "name": "maxlen",
          "description": "Maximum length of output string buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if key existed, false otherwise."
    },
    "params": [
      {
        "name": "gc",
        "type": "Handle",
        "default": null,
        "description": "Game config handle."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "Key to retrieve from the Keys section."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Destination string buffer."
      },
      {
        "name": "maxlen",
        "type": "int",
        "default": null,
        "description": "Maximum length of output string buffer."
      }
    ],
    "full_declaration": "native bool GameConfGetKeyValue(Handle gc, const char[] key, char[] buffer, int maxlen);"
  },
  {
    "name": "GameConfGetAddress",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "Address",
    "comment": "Finds an address calculation in a GameConfig file,\nperforms LoadFromAddress on it as appropriate, then returns the final address.",
    "tags": {
      "param": [
        {
          "name": "gameconf",
          "description": "Game config handle."
        },
        {
          "name": "name",
          "description": "Name of the property to find."
        }
      ],
      "error": [],
      "note": [],
      "return": "An address calculated on success, or 0 on failure."
    },
    "params": [
      {
        "name": "gameconf",
        "type": "Handle",
        "default": null,
        "description": "Game config handle."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Name of the property to find."
      }
    ],
    "full_declaration": "native Address GameConfGetAddress(Handle gameconf, const char[] name);"
  },
  {
    "name": "GetSysTickCount",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "int",
    "comment": "Returns the operating system's \"tick count,\" which is a number of\nmilliseconds since the operating system loaded.  This can be used\nfor basic benchmarks.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "Tick count in milliseconds."
    },
    "params": [],
    "full_declaration": "native int GetSysTickCount();"
  },
  {
    "name": "AutoExecConfig",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "Specifies that the given config file should be executed after plugin load.\nOnConfigsExecuted() will not be called until the config file has executed,\nbut it will be called if the execution fails.",
    "tags": {
      "param": [
        {
          "name": "autoCreate",
          "description": "If true, and the config file does not exist, such a config file will be automatically created and populated with information from the plugin's registered cvars."
        },
        {
          "name": "name",
          "description": "Name of the config file, excluding the .cfg extension. If empty, <plugin.filename.cfg> is assumed."
        },
        {
          "name": "folder",
          "description": "Folder under cfg/ to use.  By default this is \"sourcemod.\""
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "autoCreate",
        "type": "bool",
        "default": "",
        "description": "If true, and the config file does not exist, such a config file will be automatically created and populated with information from the plugin's registered cvars."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": "",
        "description": "Name of the config file, excluding the .cfg extension. If empty, <plugin.filename.cfg> is assumed."
      },
      {
        "name": "folder",
        "type": "char[]",
        "default": "",
        "description": "Folder under cfg/ to use.  By default this is \"sourcemod.\""
      }
    ],
    "full_declaration": "native void AutoExecConfig(bool autoCreate=true, const char[] name=\"\", const char[] folder=\"sourcemod\");"
  },
  {
    "name": "RegPluginLibrary",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "Registers a library name for identifying as a dependency to\nother plugins.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Library name."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Library name."
      }
    ],
    "full_declaration": "native void RegPluginLibrary(const char[] name);"
  },
  {
    "name": "LibraryExists",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "bool",
    "comment": "Returns whether a library exists.  This function should be considered\nexpensive; it should only be called on plugin to determine availability\nof resources.  Use OnLibraryAdded()/OnLibraryRemoved() to detect changes\nin libraries.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Library name of a plugin or extension."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if exists, false otherwise."
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Library name of a plugin or extension."
      }
    ],
    "full_declaration": "native bool LibraryExists(const char[] name);"
  },
  {
    "name": "GetExtensionFileStatus",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "int",
    "comment": "Returns the status of an extension, by filename.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Extension name (like \"sdktools.ext\")."
        },
        {
          "name": "error",
          "description": "Optional error message buffer."
        },
        {
          "name": "maxlength",
          "description": "Length of optional error message buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "-2 if the extension was not found. -1 if the extension was found but failed to load. 0 if the extension loaded but reported an error. 1 if the extension is running without error."
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Extension name (like \"sdktools.ext\")."
      },
      {
        "name": "error",
        "type": "char[]",
        "default": "",
        "description": "Optional error message buffer."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": "",
        "description": "Length of optional error message buffer."
      }
    ],
    "full_declaration": "native int GetExtensionFileStatus(const char[] name, char[] error=\"\", int maxlength=0);"
  },
  {
    "name": "OnLibraryAdded",
    "type": "forward",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "Called after a library is added.\nA library is either a plugin name or extension name, as\nexposed via its include file.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Library name."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Library name."
      }
    ],
    "full_declaration": "forward void OnLibraryAdded(const char[] name);"
  },
  {
    "name": "OnLibraryRemoved",
    "type": "forward",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "Called right before a library is removed.\nA library is either a plugin name or extension name, as\nexposed via its include file.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Library name."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Library name."
      }
    ],
    "full_declaration": "forward void OnLibraryRemoved(const char[] name);"
  },
  {
    "name": "OnNotifyPluginUnloaded",
    "type": "forward",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "Called when a plugin unloaded.",
    "tags": {
      "param": [
        {
          "name": "plugin",
          "description": "Plugin Handle who unloaded."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "plugin",
        "type": "Handle",
        "default": null,
        "description": "Plugin Handle who unloaded."
      }
    ],
    "full_declaration": "forward void OnNotifyPluginUnloaded(Handle plugin);"
  },
  {
    "name": "ReadMapList",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "Handle",
    "comment": "Loads a map list to an ADT Array.\n\nA map list is a list of maps from a file.  SourceMod allows easy configuration of\nmaplists through addons/sourcemod/configs/maplists.cfg.  Each entry is given a\nname and a file (for example, \"rtv\" => \"rtv.cfg\"), or a name and a redirection\n(for example, \"rtv\" => \"default\").  This native will read a map list entry,\ncache the file, and return the list of maps it holds.\n\nSerial change numbers are used to identify if a map list has changed.  Thus, if\nyou pass a serial change number and it's equal to what SourceMod currently knows\nabout the map list, then SourceMod won't re-parse the file.\n\nIf the maps end up being read from the maps folder (MAPLIST_FLAG_MAPSFOLDER), they\nare automatically sorted in alphabetical, ascending order.\n\nArrays created by this function are temporary and must be freed via CloseHandle().\nModifying arrays created by this function will not affect future return values or\nor the contents of arrays returned to other plugins.",
    "tags": {
      "param": [
        {
          "name": "array",
          "description": "Array to store the map list.  If INVALID_HANDLE, a new blank array will be created.  The blocksize should be at least 16; otherwise results may be truncated.  Items are added to the array as strings.  The array is never checked for duplicates, and it is not read beforehand.  Only the serial number is used to detect changes."
        },
        {
          "name": "serial",
          "description": "Serial number to identify last known map list change.  If -1, the the value will not be checked.  If the map list has since changed, the serial is updated (even if -1 was passed).  If there is an error finding a valid maplist, then the serial is set to -1."
        },
        {
          "name": "str",
          "description": "Config name, or \"default\" for the default map list.  Config names should be somewhat descriptive.  For example, the admin menu uses a config name of \"admin menu\".  The list names can be configured by users in addons/sourcemod/configs/maplists.cfg."
        },
        {
          "name": "flags",
          "description": "MAPLIST_FLAG flags."
        }
      ],
      "error": [
        "Invalid array Handle that is not INVALID_HANDLE."
      ],
      "note": [],
      "return": "On failure: INVALID_HANDLE is returned, the serial is set to -1, and the input array (if any) is left unchanged. On no change: INVALID_HANDLE is returned, the serial is unchanged, and the input array (if any) is left unchanged. On success: A valid array Handle is returned, containing at least one map string. If an array was passed, the return value is equal to the passed Array Handle.  If the passed array was not cleared, it will have grown by at least one item.  The serial number is updated to a positive number."
    },
    "params": [
      {
        "name": "array",
        "type": "Handle",
        "default": "",
        "description": "Array to store the map list.  If INVALID_HANDLE, a new blank array will be created.  The blocksize should be at least 16; otherwise results may be truncated.  Items are added to the array as strings.  The array is never checked for duplicates, and it is not read beforehand.  Only the serial number is used to detect changes."
      },
      {
        "name": "serial",
        "type": "int",
        "default": "",
        "description": "Serial number to identify last known map list change.  If -1, the the value will not be checked.  If the map list has since changed, the serial is updated (even if -1 was passed).  If there is an error finding a valid maplist, then the serial is set to -1."
      },
      {
        "name": "str",
        "type": "char[]",
        "default": "",
        "description": "Config name, or \"default\" for the default map list.  Config names should be somewhat descriptive.  For example, the admin menu uses a config name of \"admin menu\".  The list names can be configured by users in addons/sourcemod/configs/maplists.cfg."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "MAPLIST_FLAG flags."
      }
    ],
    "full_declaration": "native Handle ReadMapList(Handle array=INVALID_HANDLE,                           int &serial=-1,                           const char[] str=\"default\",                           int flags=MAPLIST_FLAG_CLEARARRAY);"
  },
  {
    "name": "SetMapListCompatBind",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "Makes a compatibility binding for map lists.  For example, if a function previously used\n\"clam.cfg\" for map lists, this function will insert a \"fake\" binding to \"clam.cfg\" that\nwill be overridden if it's in the maplists.cfg file.",
    "tags": {
      "param": [
        {
          "name": "name",
          "description": "Configuration name that would be used with ReadMapList()."
        },
        {
          "name": "file",
          "description": "Default file to use."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Configuration name that would be used with ReadMapList()."
      },
      {
        "name": "file",
        "type": "char[]",
        "default": null,
        "description": "Default file to use."
      }
    ],
    "full_declaration": "native void SetMapListCompatBind(const char[] name, const char[] file);"
  },
  {
    "name": "OnClientFloodCheck",
    "type": "forward",
    "source_file": "sourcemod.inc",
    "return_type": "bool",
    "comment": "Called when a client has sent chat text.  This must return either true or\nfalse to indicate that a client is or is not spamming the server.\n\nThe return value is a hint only.  Core or another plugin may decide\notherwise.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index.  The server (0) will never be passed."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if client is spamming the server, false otherwise."
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index.  The server (0) will never be passed."
      }
    ],
    "full_declaration": "forward bool OnClientFloodCheck(int client);"
  },
  {
    "name": "OnClientFloodResult",
    "type": "forward",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "Called after a client's flood check has been computed.  This can be used\nby antiflood algorithms to decay/increase flooding weights.\n\nSince the result from \"OnClientFloodCheck\" isn't guaranteed to be the\nfinal result, it is generally a good idea to use this to play with other\nalgorithms nicely.",
    "tags": {
      "param": [
        {
          "name": "client",
          "description": "Client index.  The server (0) will never be passed."
        },
        {
          "name": "blocked",
          "description": "True if client flooded last \"say\", false otherwise."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index.  The server (0) will never be passed."
      },
      {
        "name": "blocked",
        "type": "bool",
        "default": null,
        "description": "True if client flooded last \"say\", false otherwise."
      }
    ],
    "full_declaration": "forward void OnClientFloodResult(int client, bool blocked);"
  },
  {
    "name": "CanTestFeatures",
    "type": "stock",
    "source_file": "sourcemod.inc",
    "return_type": "bool",
    "comment": "Returns whether \"GetFeatureStatus\" will work. Using this native\nor this function will not cause SourceMod to fail loading on older versions,\nhowever, GetFeatureStatus will only work if this function returns true.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "True if GetFeatureStatus will work, false otherwise."
    },
    "params": [],
    "full_declaration": "stock bool CanTestFeatures() { \treturn LibraryExists(\"__CanTestFeatures__\");"
  },
  {
    "name": "GetFeatureStatus",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "FeatureStatus",
    "comment": "Returns whether a feature exists, and if so, whether it is usable.",
    "tags": {
      "param": [
        {
          "name": "type",
          "description": "Feature type."
        },
        {
          "name": "name",
          "description": "Feature name."
        }
      ],
      "error": [],
      "note": [],
      "return": "Feature status."
    },
    "params": [
      {
        "name": "type",
        "type": "FeatureType",
        "default": null,
        "description": "Feature type."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Feature name."
      }
    ],
    "full_declaration": "native FeatureStatus GetFeatureStatus(FeatureType type, const char[] name);"
  },
  {
    "name": "RequireFeature",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "Requires that a given feature is available. If it is not, SetFailState()\nis called with the given message.",
    "tags": {
      "param": [
        {
          "name": "type",
          "description": "Feature type."
        },
        {
          "name": "name",
          "description": "Feature name."
        },
        {
          "name": "fmt",
          "description": "Message format string, or empty to use default."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "type",
        "type": "FeatureType",
        "default": null,
        "description": "Feature type."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Feature name."
      },
      {
        "name": "fmt",
        "type": "char[]",
        "default": "",
        "description": "Message format string, or empty to use default."
      }
    ],
    "full_declaration": "native void RequireFeature(FeatureType type, const char[] name,                            const char[] fmt=\"\", any ...);"
  },
  {
    "name": "LoadFromAddress",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "any",
    "comment": "Load up to 4 bytes from a memory address.",
    "tags": {
      "param": [
        {
          "name": "addr",
          "description": "Address to a memory location."
        },
        {
          "name": "size",
          "description": "How many bytes should be read. If loading a floating-point value, use NumberType_Int32."
        }
      ],
      "error": [
        "Address is null or pointing to reserved memory."
      ],
      "note": [],
      "return": "The value that is stored at that address."
    },
    "params": [
      {
        "name": "addr",
        "type": "Address",
        "default": null,
        "description": "Address to a memory location."
      },
      {
        "name": "size",
        "type": "NumberType",
        "default": null,
        "description": "How many bytes should be read. If loading a floating-point value, use NumberType_Int32."
      }
    ],
    "full_declaration": "native any LoadFromAddress(Address addr, NumberType size);"
  },
  {
    "name": "StoreToAddress",
    "type": "native",
    "source_file": "sourcemod.inc",
    "return_type": "void",
    "comment": "Store up to 4 bytes to a memory address.",
    "tags": {
      "param": [
        {
          "name": "addr",
          "description": "Address to a memory location."
        },
        {
          "name": "data",
          "description": "Value to store at the address."
        },
        {
          "name": "size",
          "description": "How many bytes should be written. If storing a floating-point value, use NumberType_Int32."
        },
        {
          "name": "updateMemAccess",
          "description": "If true, SourceMod will set read / write / exec permissions on the memory page being written to."
        }
      ],
      "error": [
        "Address is null or pointing to reserved memory."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "addr",
        "type": "Address",
        "default": null,
        "description": "Address to a memory location."
      },
      {
        "name": "data",
        "type": "any",
        "default": null,
        "description": "Value to store at the address."
      },
      {
        "name": "size",
        "type": "NumberType",
        "default": null,
        "description": "How many bytes should be written. If storing a floating-point value, use NumberType_Int32."
      },
      {
        "name": "updateMemAccess",
        "type": "bool",
        "default": "",
        "description": "If true, SourceMod will set read / write / exec permissions on the memory page being written to."
      }
    ],
    "full_declaration": "native void StoreToAddress(Address addr, any data, NumberType size, bool updateMemAccess = true);"
  },
  {
    "name": "strlen",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Calculates the length of a string.",
    "tags": {
      "param": [
        {
          "name": "str",
          "description": "String to check."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of valid character bytes in the string."
    },
    "params": [
      {
        "name": "str",
        "type": "char[]",
        "default": null,
        "description": "String to check."
      }
    ],
    "full_declaration": "native int strlen(const char[] str);"
  },
  {
    "name": "StrContains",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Tests whether a string is found inside another string.",
    "tags": {
      "param": [
        {
          "name": "str",
          "description": "String to search in."
        },
        {
          "name": "substr",
          "description": "Substring to find inside the original string."
        },
        {
          "name": "caseSensitive",
          "description": "If true (default), search is case sensitive. If false, search is case insensitive."
        }
      ],
      "error": [],
      "note": [],
      "return": "-1 on failure (no match found). Any other value indicates a position in the string where the match starts."
    },
    "params": [
      {
        "name": "str",
        "type": "char[]",
        "default": null,
        "description": "String to search in."
      },
      {
        "name": "substr",
        "type": "char[]",
        "default": null,
        "description": "Substring to find inside the original string."
      },
      {
        "name": "caseSensitive",
        "type": "bool",
        "default": "",
        "description": "If true (default), search is case sensitive. If false, search is case insensitive."
      }
    ],
    "full_declaration": "native int StrContains(const char[] str, const char[] substr, bool caseSensitive=true);"
  },
  {
    "name": "strcmp",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Compares two strings lexographically.",
    "tags": {
      "param": [
        {
          "name": "str1",
          "description": "First string (left)."
        },
        {
          "name": "str2",
          "description": "Second string (right)."
        },
        {
          "name": "caseSensitive",
          "description": "If true (default), comparison is case sensitive. If false, comparison is case insensitive."
        }
      ],
      "error": [],
      "note": [],
      "return": "-1 if str1 < str2 0 if str1 == str2 1 if str1 > str2"
    },
    "params": [
      {
        "name": "str1",
        "type": "char[]",
        "default": null,
        "description": "First string (left)."
      },
      {
        "name": "str2",
        "type": "char[]",
        "default": null,
        "description": "Second string (right)."
      },
      {
        "name": "caseSensitive",
        "type": "bool",
        "default": "",
        "description": "If true (default), comparison is case sensitive. If false, comparison is case insensitive."
      }
    ],
    "full_declaration": "native int strcmp(const char[] str1, const char[] str2, bool caseSensitive=true);"
  },
  {
    "name": "strncmp",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Compares two strings parts lexographically.",
    "tags": {
      "param": [
        {
          "name": "str1",
          "description": "First string (left)."
        },
        {
          "name": "str2",
          "description": "Second string (right)."
        },
        {
          "name": "num",
          "description": "Number of characters to compare."
        },
        {
          "name": "caseSensitive",
          "description": "If true (default), comparison is case sensitive. If false, comparison is case insensitive."
        }
      ],
      "error": [],
      "note": [],
      "return": "-1 if str1 < str2 0 if str1 == str2 1 if str1 > str2"
    },
    "params": [
      {
        "name": "str1",
        "type": "char[]",
        "default": null,
        "description": "First string (left)."
      },
      {
        "name": "str2",
        "type": "char[]",
        "default": null,
        "description": "Second string (right)."
      },
      {
        "name": "num",
        "type": "int",
        "default": null,
        "description": "Number of characters to compare."
      },
      {
        "name": "caseSensitive",
        "type": "bool",
        "default": "",
        "description": "If true (default), comparison is case sensitive. If false, comparison is case insensitive."
      }
    ],
    "full_declaration": "native int strncmp(const char[] str1, const char[] str2, int num, bool caseSensitive=true);"
  },
  {
    "name": "StrCompare",
    "type": "stock",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Backwards compatible stock - StrCompare is now strcmp",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "",
      "deprecated": [
        "Renamed to strcmp"
      ]
    },
    "params": [
      {
        "name": "str1",
        "type": "char[]",
        "default": null,
        "description": ""
      },
      {
        "name": "str2",
        "type": "char[]",
        "default": null,
        "description": ""
      },
      {
        "name": "caseSensitive",
        "type": "bool",
        "default": "",
        "description": ""
      }
    ],
    "full_declaration": "stock int StrCompare(const char[] str1, const char[] str2, bool caseSensitive=true) { \treturn strcmp(str1, str2, caseSensitive);"
  },
  {
    "name": "StrEqual",
    "type": "stock",
    "source_file": "string.inc",
    "return_type": "bool",
    "comment": "Returns whether two strings are equal.",
    "tags": {
      "param": [
        {
          "name": "str1",
          "description": "First string (left)."
        },
        {
          "name": "str2",
          "description": "Second string (right)."
        },
        {
          "name": "caseSensitive",
          "description": "If true (default), comparison is case sensitive. If false, comparison is case insensitive."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if equal, false otherwise."
    },
    "params": [
      {
        "name": "str1",
        "type": "char[]",
        "default": null,
        "description": "First string (left)."
      },
      {
        "name": "str2",
        "type": "char[]",
        "default": null,
        "description": "Second string (right)."
      },
      {
        "name": "caseSensitive",
        "type": "bool",
        "default": "",
        "description": "If true (default), comparison is case sensitive. If false, comparison is case insensitive."
      }
    ],
    "full_declaration": "stock bool StrEqual(const char[] str1, const char[] str2, bool caseSensitive=true) { \treturn (strcmp(str1, str2, caseSensitive) == 0);"
  },
  {
    "name": "strcopy",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Copies one string to another string.",
    "tags": {
      "param": [
        {
          "name": "dest",
          "description": "Destination string buffer to copy to."
        },
        {
          "name": "destLen",
          "description": "Destination buffer length (includes null terminator)."
        },
        {
          "name": "source",
          "description": "Source string buffer to copy from."
        }
      ],
      "error": [],
      "note": [
        "If the destination buffer is too small to hold the source string, the destination will be truncated."
      ],
      "return": "Number of characters written to the buffer, not including the null terminator."
    },
    "params": [
      {
        "name": "dest",
        "type": "char[]",
        "default": null,
        "description": "Destination string buffer to copy to."
      },
      {
        "name": "destLen",
        "type": "int",
        "default": null,
        "description": "Destination buffer length (includes null terminator)."
      },
      {
        "name": "source",
        "type": "char[]",
        "default": null,
        "description": "Source string buffer to copy from."
      }
    ],
    "full_declaration": "native int strcopy(char[] dest, int destLen, const char[] source);"
  },
  {
    "name": "StrCopy",
    "type": "stock",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Backwards compatibility stock - use strcopy",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "",
      "deprecated": [
        "Renamed to strcopy"
      ]
    },
    "params": [
      {
        "name": "dest",
        "type": "char[]",
        "default": null,
        "description": ""
      },
      {
        "name": "destLen",
        "type": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "source",
        "type": "char[]",
        "default": null,
        "description": ""
      }
    ],
    "full_declaration": "stock int StrCopy(char[] dest, int destLen, const char[] source) { \treturn strcopy(dest, destLen, source);"
  },
  {
    "name": "Format",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Formats a string according to the SourceMod format rules (see documentation).",
    "tags": {
      "param": [
        {
          "name": "buffer",
          "description": "Destination string buffer."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of output string buffer, including the null terminator."
        },
        {
          "name": "format",
          "description": "Formatting rules."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of characters written to the buffer, not including the null terminator."
    },
    "params": [
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Destination string buffer."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of output string buffer, including the null terminator."
      },
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "Formatting rules."
      }
    ],
    "full_declaration": "native int Format(char[] buffer, int maxlength, const char[] format, any ...);"
  },
  {
    "name": "FormatEx",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Formats a string according to the SourceMod format rules (see documentation).",
    "tags": {
      "param": [
        {
          "name": "buffer",
          "description": "Destination string buffer."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of output string buffer, including the null terminator."
        },
        {
          "name": "format",
          "description": "Formatting rules."
        }
      ],
      "error": [],
      "note": [
        "This is the same as Format(), except none of the input buffers can overlap the same memory as the output buffer.  Since this security check is removed, it is slightly faster."
      ],
      "return": "Number of characters written to the buffer, not including the null terminator."
    },
    "params": [
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Destination string buffer."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of output string buffer, including the null terminator."
      },
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "Formatting rules."
      }
    ],
    "full_declaration": "native int FormatEx(char[] buffer, int maxlength, const char[] format, any ...);"
  },
  {
    "name": "VFormat",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Formats a string according to the SourceMod format rules (see documentation).",
    "tags": {
      "param": [
        {
          "name": "buffer",
          "description": "Destination string buffer."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of output string buffer, including the null terminator."
        },
        {
          "name": "format",
          "description": "Formatting rules."
        },
        {
          "name": "varpos",
          "description": "Argument number which contains the '...' symbol. Note: Arguments start at 1."
        }
      ],
      "error": [
        "Invalid argument index."
      ],
      "note": [
        "This is the same as Format(), except it grabs parameters from a parent parameter stack, rather than a local.  This is useful for implementing your own variable argument functions."
      ],
      "return": "Number of bytes written."
    },
    "params": [
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Destination string buffer."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of output string buffer, including the null terminator."
      },
      {
        "name": "format",
        "type": "char[]",
        "default": null,
        "description": "Formatting rules."
      },
      {
        "name": "varpos",
        "type": "int",
        "default": null,
        "description": "Argument number which contains the '...' symbol. Note: Arguments start at 1."
      }
    ],
    "full_declaration": "native int VFormat(char[] buffer, int maxlength, const char[] format, int varpos);"
  },
  {
    "name": "StringToInt",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Converts a string to an integer.",
    "tags": {
      "param": [
        {
          "name": "str",
          "description": "String to convert."
        },
        {
          "name": "nBase",
          "description": "Numerical base to use.  10 is default."
        }
      ],
      "error": [],
      "note": [],
      "return": "Integer conversion of string, or 0 on failure."
    },
    "params": [
      {
        "name": "str",
        "type": "char[]",
        "default": null,
        "description": "String to convert."
      },
      {
        "name": "nBase",
        "type": "int",
        "default": "",
        "description": "Numerical base to use.  10 is default."
      }
    ],
    "full_declaration": "native int StringToInt(const char[] str, int nBase=10);"
  },
  {
    "name": "StringToIntEx",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Converts a string to an integer with some more options.",
    "tags": {
      "param": [
        {
          "name": "str",
          "description": "String to convert."
        },
        {
          "name": "result",
          "description": "Variable to store the result in."
        },
        {
          "name": "nBase",
          "description": "Numerical base to use.  10 is default."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of characters consumed."
    },
    "params": [
      {
        "name": "str",
        "type": "char[]",
        "default": null,
        "description": "String to convert."
      },
      {
        "name": "result",
        "type": "int",
        "default": null,
        "description": "Variable to store the result in."
      },
      {
        "name": "nBase",
        "type": "int",
        "default": "",
        "description": "Numerical base to use.  10 is default."
      }
    ],
    "full_declaration": "native int StringToIntEx(const char[] str, int &result, int nBase=10);"
  },
  {
    "name": "StringToInt64",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Converts a string to a 64-bit integer.",
    "tags": {
      "param": [
        {
          "name": "str",
          "description": "String to convert."
        },
        {
          "name": "result",
          "description": "Array to store the upper and lower 32-bits of the 64-bit integer."
        },
        {
          "name": "nBase",
          "description": "Numerical base to use.  10 is default."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of characters consumed."
    },
    "params": [
      {
        "name": "str",
        "type": "char[]",
        "default": null,
        "description": "String to convert."
      },
      {
        "name": "result",
        "type": "int",
        "default": null,
        "description": "Array to store the upper and lower 32-bits of the 64-bit integer."
      },
      {
        "name": "nBase",
        "type": "int",
        "default": "",
        "description": "Numerical base to use.  10 is default."
      }
    ],
    "full_declaration": "native int StringToInt64(const char[] str, int result[2], int nBase=10);"
  },
  {
    "name": "IntToString",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Converts an integer to a string.",
    "tags": {
      "param": [
        {
          "name": "num",
          "description": "Integer to convert."
        },
        {
          "name": "str",
          "description": "Buffer to store string in."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of string buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of characters written to the buffer, not including the null terminator."
    },
    "params": [
      {
        "name": "num",
        "type": "int",
        "default": null,
        "description": "Integer to convert."
      },
      {
        "name": "str",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store string in."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of string buffer."
      }
    ],
    "full_declaration": "native int IntToString(int num, char[] str, int maxlength);"
  },
  {
    "name": "Int64ToString",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Converts a 64-bit integer to a string.",
    "tags": {
      "param": [
        {
          "name": "num",
          "description": "Array containing the upper and lower 32-bits of a 64-bit integer."
        },
        {
          "name": "str",
          "description": "Buffer to store string in."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of string buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of characters written to the buffer, not including the null terminator."
    },
    "params": [
      {
        "name": "num",
        "type": "int",
        "default": null,
        "description": "Array containing the upper and lower 32-bits of a 64-bit integer."
      },
      {
        "name": "str",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store string in."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of string buffer."
      }
    ],
    "full_declaration": "native int Int64ToString(const int num[2], char[] str, int maxlength);"
  },
  {
    "name": "StringToFloat",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "float",
    "comment": "Converts a string to a floating point number.",
    "tags": {
      "param": [
        {
          "name": "str",
          "description": "String to convert to a float."
        }
      ],
      "error": [],
      "note": [],
      "return": "Floating point result, or 0.0 on error."
    },
    "params": [
      {
        "name": "str",
        "type": "char[]",
        "default": null,
        "description": "String to convert to a float."
      }
    ],
    "full_declaration": "native float StringToFloat(const char[] str);"
  },
  {
    "name": "StringToFloatEx",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Converts a string to a floating point number with some more options.",
    "tags": {
      "param": [
        {
          "name": "str",
          "description": "String to convert to a float."
        },
        {
          "name": "result",
          "description": "Variable to store result in."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of characters consumed."
    },
    "params": [
      {
        "name": "str",
        "type": "char[]",
        "default": null,
        "description": "String to convert to a float."
      },
      {
        "name": "result",
        "type": "float",
        "default": null,
        "description": "Variable to store result in."
      }
    ],
    "full_declaration": "native int StringToFloatEx(const char[] str, float &result);"
  },
  {
    "name": "FloatToString",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Converts a floating point number to a string.",
    "tags": {
      "param": [
        {
          "name": "num",
          "description": "Floating point number to convert."
        },
        {
          "name": "str",
          "description": "Buffer to store string in."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of string buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of characters written to the buffer, not including the null terminator."
    },
    "params": [
      {
        "name": "num",
        "type": "float",
        "default": null,
        "description": "Floating point number to convert."
      },
      {
        "name": "str",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store string in."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of string buffer."
      }
    ],
    "full_declaration": "native int FloatToString(float num, char[] str, int maxlength);"
  },
  {
    "name": "BreakString",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Finds the first \"argument\" in a string; either a set of space\nterminated characters, or a fully quoted string.  After the\nargument is found, whitespace is read until the next portion\nof the string is reached.  If nothing remains, -1 is returned.\nOtherwise, the index to the first character is returned.",
    "tags": {
      "param": [
        {
          "name": "source",
          "description": "Source input string."
        },
        {
          "name": "arg",
          "description": "Stores argument read from string."
        },
        {
          "name": "argLen",
          "description": "Maximum length of argument buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "Index to next piece of string, or -1 if none."
    },
    "params": [
      {
        "name": "source",
        "type": "char[]",
        "default": null,
        "description": "Source input string."
      },
      {
        "name": "arg",
        "type": "char[]",
        "default": null,
        "description": "Stores argument read from string."
      },
      {
        "name": "argLen",
        "type": "int",
        "default": null,
        "description": "Maximum length of argument buffer."
      }
    ],
    "full_declaration": "native int BreakString(const char[] source, char[] arg, int argLen);"
  },
  {
    "name": "StrBreak",
    "type": "stock",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Backwards compatibility stock - use BreakString",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "",
      "deprecated": [
        "Renamed to BreakString."
      ]
    },
    "params": [
      {
        "name": "source",
        "type": "char[]",
        "default": null,
        "description": ""
      },
      {
        "name": "arg",
        "type": "char[]",
        "default": null,
        "description": ""
      },
      {
        "name": "argLen",
        "type": "int",
        "default": null,
        "description": ""
      }
    ],
    "full_declaration": "stock int StrBreak(const char[] source, char[] arg, int argLen) { \treturn BreakString(source, arg, argLen);"
  },
  {
    "name": "TrimString",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Removes whitespace characters from the beginning and end of a string.",
    "tags": {
      "param": [
        {
          "name": "str",
          "description": "The string to trim."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of bytes written (UTF-8 safe)."
    },
    "params": [
      {
        "name": "str",
        "type": "char[]",
        "default": null,
        "description": "The string to trim."
      }
    ],
    "full_declaration": "native int TrimString(char[] str);"
  },
  {
    "name": "SplitString",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Returns text in a string up until a certain character sequence is reached.",
    "tags": {
      "param": [
        {
          "name": "source",
          "description": "Source input string."
        },
        {
          "name": "split",
          "description": "A string which specifies a search point to break at."
        },
        {
          "name": "part",
          "description": "Buffer to store string part."
        },
        {
          "name": "partLen",
          "description": "Maximum length of the string part buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "-1 if no match was found; otherwise, an index into source marking the first index after the searched text.  The index is always relative to the start of the input string."
    },
    "params": [
      {
        "name": "source",
        "type": "char[]",
        "default": null,
        "description": "Source input string."
      },
      {
        "name": "split",
        "type": "char[]",
        "default": null,
        "description": "A string which specifies a search point to break at."
      },
      {
        "name": "part",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store string part."
      },
      {
        "name": "partLen",
        "type": "int",
        "default": null,
        "description": "Maximum length of the string part buffer."
      }
    ],
    "full_declaration": "native int SplitString(const char[] source, const char[] split, char[] part, int partLen);"
  },
  {
    "name": "ReplaceString",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Given a string, replaces all occurrences of a search string with a\nreplacement string.",
    "tags": {
      "param": [
        {
          "name": "text",
          "description": "String to perform search and replacements on."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of the string buffer."
        },
        {
          "name": "search",
          "description": "String to search for."
        },
        {
          "name": "replace",
          "description": "String to replace the search string with."
        },
        {
          "name": "caseSensitive",
          "description": "If true (default), search is case sensitive."
        }
      ],
      "error": [
        "'search' parameter is empty."
      ],
      "note": [],
      "return": "Number of replacements that were performed."
    },
    "params": [
      {
        "name": "text",
        "type": "char[]",
        "default": null,
        "description": "String to perform search and replacements on."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the string buffer."
      },
      {
        "name": "search",
        "type": "char[]",
        "default": null,
        "description": "String to search for."
      },
      {
        "name": "replace",
        "type": "char[]",
        "default": null,
        "description": "String to replace the search string with."
      },
      {
        "name": "caseSensitive",
        "type": "bool",
        "default": "",
        "description": "If true (default), search is case sensitive."
      }
    ],
    "full_declaration": "native int ReplaceString(char[] text, int maxlength, const char[] search, const char[] replace, bool caseSensitive=true);"
  },
  {
    "name": "ReplaceStringEx",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Given a string, replaces the first occurrence of a search string with a\nreplacement string.",
    "tags": {
      "param": [
        {
          "name": "text",
          "description": "String to perform search and replacements on."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of the string buffer."
        },
        {
          "name": "search",
          "description": "String to search for."
        },
        {
          "name": "replace",
          "description": "String to replace the search string with."
        },
        {
          "name": "searchLen",
          "description": "If higher than -1, its value will be used instead of a strlen() call on the search parameter."
        },
        {
          "name": "replaceLen",
          "description": "If higher than -1, its value will be used instead of a strlen() call on the replace parameter."
        },
        {
          "name": "caseSensitive",
          "description": "If true (default), search is case sensitive."
        }
      ],
      "error": [
        "'search' parameter is empty."
      ],
      "note": [],
      "return": "Index into the buffer (relative to the start) from where the last replacement ended, or -1 if no replacements were made."
    },
    "params": [
      {
        "name": "text",
        "type": "char[]",
        "default": null,
        "description": "String to perform search and replacements on."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the string buffer."
      },
      {
        "name": "search",
        "type": "char[]",
        "default": null,
        "description": "String to search for."
      },
      {
        "name": "replace",
        "type": "char[]",
        "default": null,
        "description": "String to replace the search string with."
      },
      {
        "name": "searchLen",
        "type": "int",
        "default": "",
        "description": "If higher than -1, its value will be used instead of a strlen() call on the search parameter."
      },
      {
        "name": "replaceLen",
        "type": "int",
        "default": "",
        "description": "If higher than -1, its value will be used instead of a strlen() call on the replace parameter."
      },
      {
        "name": "caseSensitive",
        "type": "bool",
        "default": "",
        "description": "If true (default), search is case sensitive."
      }
    ],
    "full_declaration": "native int ReplaceStringEx(char[] text, int maxlength, const char[] search, const char[] replace, int searchLen=-1, int replaceLen=-1, bool caseSensitive=true);"
  },
  {
    "name": "GetCharBytes",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Returns the number of bytes a character is using.  This is\nfor multi-byte characters (UTF-8).  For normal ASCII characters,\nthis will return 1.",
    "tags": {
      "param": [
        {
          "name": "source",
          "description": "Source input string."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of bytes the current character uses."
    },
    "params": [
      {
        "name": "source",
        "type": "char[]",
        "default": null,
        "description": "Source input string."
      }
    ],
    "full_declaration": "native int GetCharBytes(const char[] source);"
  },
  {
    "name": "IsCharAlpha",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "bool",
    "comment": "Returns whether a character is an ASCII alphabet character.",
    "tags": {
      "param": [
        {
          "name": "chr",
          "description": "Character to test."
        }
      ],
      "error": [],
      "note": [
        "Multi-byte characters will always return false."
      ],
      "return": "True if character is alphabetical, otherwise false."
    },
    "params": [
      {
        "name": "chr",
        "type": "int",
        "default": null,
        "description": "Character to test."
      }
    ],
    "full_declaration": "native bool IsCharAlpha(int chr);"
  },
  {
    "name": "IsCharNumeric",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "bool",
    "comment": "Returns whether a character is numeric.",
    "tags": {
      "param": [
        {
          "name": "chr",
          "description": "Character to test."
        }
      ],
      "error": [],
      "note": [
        "Multi-byte characters will always return false."
      ],
      "return": "True if character is numeric, otherwise false."
    },
    "params": [
      {
        "name": "chr",
        "type": "int",
        "default": null,
        "description": "Character to test."
      }
    ],
    "full_declaration": "native bool IsCharNumeric(int chr);"
  },
  {
    "name": "IsCharSpace",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "bool",
    "comment": "Returns whether a character is whitespace.",
    "tags": {
      "param": [
        {
          "name": "chr",
          "description": "Character to test."
        }
      ],
      "error": [],
      "note": [
        "Multi-byte characters will always return false."
      ],
      "return": "True if character is whitespace, otherwise false."
    },
    "params": [
      {
        "name": "chr",
        "type": "int",
        "default": null,
        "description": "Character to test."
      }
    ],
    "full_declaration": "native bool IsCharSpace(int chr);"
  },
  {
    "name": "IsCharMB",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Returns if a character is multi-byte or not.",
    "tags": {
      "param": [
        {
          "name": "chr",
          "description": "Character to test."
        }
      ],
      "error": [],
      "note": [],
      "return": "0 for a normal 7-bit ASCII character, otherwise number of bytes in multi-byte character."
    },
    "params": [
      {
        "name": "chr",
        "type": "int",
        "default": null,
        "description": "Character to test."
      }
    ],
    "full_declaration": "native int IsCharMB(int chr);"
  },
  {
    "name": "IsCharUpper",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "bool",
    "comment": "Returns whether an alphabetic character is uppercase.",
    "tags": {
      "param": [
        {
          "name": "chr",
          "description": "Character to test."
        }
      ],
      "error": [],
      "note": [
        "Multi-byte characters will always return false."
      ],
      "return": "True if character is uppercase, otherwise false."
    },
    "params": [
      {
        "name": "chr",
        "type": "int",
        "default": null,
        "description": "Character to test."
      }
    ],
    "full_declaration": "native bool IsCharUpper(int chr);"
  },
  {
    "name": "IsCharLower",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "bool",
    "comment": "Returns whether an alphabetic character is lowercase.",
    "tags": {
      "param": [
        {
          "name": "chr",
          "description": "Character to test."
        }
      ],
      "error": [],
      "note": [
        "Multi-byte characters will always return false."
      ],
      "return": "True if character is lowercase, otherwise false."
    },
    "params": [
      {
        "name": "chr",
        "type": "int",
        "default": null,
        "description": "Character to test."
      }
    ],
    "full_declaration": "native bool IsCharLower(int chr);"
  },
  {
    "name": "StripQuotes",
    "type": "native",
    "source_file": "string.inc",
    "return_type": "bool",
    "comment": "Strips a quote pair off a string if it exists.  That is, the following\nreplace rule is applied once:  ^\"(.*)\"$ -> ^\\1$\n\nNote that the leading and trailing quotes will only be removed if both\nexist.  Otherwise, the string is left unmodified.  This function should\nbe considered O(k) (all characters get shifted down).",
    "tags": {
      "param": [
        {
          "name": "text",
          "description": "String to modify (in place)."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if string was modified, false if there was no set of quotes."
    },
    "params": [
      {
        "name": "text",
        "type": "char[]",
        "default": null,
        "description": "String to modify (in place)."
      }
    ],
    "full_declaration": "native bool StripQuotes(char[] text);"
  },
  {
    "name": "CharToUpper",
    "type": "stock",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Converts a lowercase character to its uppercase counterpart.",
    "tags": {
      "param": [
        {
          "name": "chr",
          "description": "Character to convert."
        }
      ],
      "error": [],
      "note": [],
      "return": "Uppercase character on success, no change on failure."
    },
    "params": [
      {
        "name": "chr",
        "type": "int",
        "default": null,
        "description": "Character to convert."
      }
    ],
    "full_declaration": "stock int CharToUpper(int chr) { \tif (IsCharLower(chr)) \t{ \t\treturn (chr & ~(1<<5));"
  },
  {
    "name": "CharToLower",
    "type": "stock",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Converts an uppercase character to its lowercase counterpart.",
    "tags": {
      "param": [
        {
          "name": "chr",
          "description": "Character to convert."
        }
      ],
      "error": [],
      "note": [],
      "return": "Lowercase character on success, no change on failure."
    },
    "params": [
      {
        "name": "chr",
        "type": "int",
        "default": null,
        "description": "Character to convert."
      }
    ],
    "full_declaration": "stock int CharToLower(int chr) { \tif (IsCharUpper(chr)) \t{ \t\treturn (chr | (1<<5));"
  },
  {
    "name": "FindCharInString",
    "type": "stock",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Finds the first occurrence of a character in a string.",
    "tags": {
      "param": [
        {
          "name": "str",
          "description": "String."
        },
        {
          "name": "c",
          "description": "Character to search for."
        },
        {
          "name": "reverse",
          "description": "False (default) to search forward, true to search backward."
        }
      ],
      "error": [],
      "note": [],
      "return": "The index of the first occurrence of the character in the string, or -1 if the character was not found."
    },
    "params": [
      {
        "name": "str",
        "type": "char[]",
        "default": null,
        "description": "String."
      },
      {
        "name": "c",
        "type": "char",
        "default": null,
        "description": "Character to search for."
      },
      {
        "name": "reverse",
        "type": "bool",
        "default": "",
        "description": "False (default) to search forward, true to search backward."
      }
    ],
    "full_declaration": "stock int FindCharInString(const char[] str, char c, bool reverse = false) { \tint len = strlen(str);"
  },
  {
    "name": "StrCat",
    "type": "stock",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Concatenates one string onto another.",
    "tags": {
      "param": [
        {
          "name": "buffer",
          "description": "String to append to."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of entire buffer."
        },
        {
          "name": "source",
          "description": "Source string to concatenate."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of bytes written."
    },
    "params": [
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "String to append to."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of entire buffer."
      },
      {
        "name": "source",
        "type": "char[]",
        "default": null,
        "description": "Source string to concatenate."
      }
    ],
    "full_declaration": "stock int StrCat(char[] buffer, int maxlength, const char[] source) { \tint len = strlen(buffer);"
  },
  {
    "name": "ExplodeString",
    "type": "stock",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Breaks a string into pieces and stores each piece into an array of buffers.",
    "tags": {
      "param": [
        {
          "name": "text",
          "description": "The string to split."
        },
        {
          "name": "split",
          "description": "The string to use as a split delimiter."
        },
        {
          "name": "buffers",
          "description": "An array of string buffers (2D array)."
        },
        {
          "name": "maxStrings",
          "description": "Number of string buffers (first dimension size)."
        },
        {
          "name": "maxStringLength",
          "description": "Maximum length of each string buffer."
        },
        {
          "name": "copyRemainder",
          "description": "False (default) discard excess pieces, true to ignore delimiters after last piece."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of strings retrieved."
    },
    "params": [
      {
        "name": "text",
        "type": "char[]",
        "default": null,
        "description": "The string to split."
      },
      {
        "name": "split",
        "type": "char[]",
        "default": null,
        "description": "The string to use as a split delimiter."
      },
      {
        "name": "buffers",
        "type": "char[][]",
        "default": null,
        "description": "An array of string buffers (2D array)."
      },
      {
        "name": "maxStrings",
        "type": "int",
        "default": null,
        "description": "Number of string buffers (first dimension size)."
      },
      {
        "name": "maxStringLength",
        "type": "int",
        "default": null,
        "description": "Maximum length of each string buffer."
      },
      {
        "name": "copyRemainder",
        "type": "bool",
        "default": "",
        "description": "False (default) discard excess pieces, true to ignore delimiters after last piece."
      }
    ],
    "full_declaration": "stock int ExplodeString(const char[] text, const char[] split, char[][] buffers, int maxStrings,                     int maxStringLength, bool copyRemainder = false) { \tint reloc_idx, idx, total;  \tif (maxStrings < 1 || !split[0]) \t{ \t\treturn 0; \t}  \twhile ((idx = SplitString(text[reloc_idx], split, buffers[total], maxStringLength)) != -1) \t{ \t\treloc_idx += idx; \t\tif (++total == maxStrings) \t\t{ \t\t\tif (copyRemainder) \t\t\t{ \t\t\t\tstrcopy(buffers[total-1], maxStringLength, text[reloc_idx-idx]);"
  },
  {
    "name": "ImplodeStrings",
    "type": "stock",
    "source_file": "string.inc",
    "return_type": "int",
    "comment": "Joins an array of strings into one string, with a \"join\" string inserted in\nbetween each given string.  This function complements ExplodeString.",
    "tags": {
      "param": [
        {
          "name": "strings",
          "description": "An array of strings."
        },
        {
          "name": "numStrings",
          "description": "Number of strings in the array."
        },
        {
          "name": "join",
          "description": "The join string to insert between each string."
        },
        {
          "name": "buffer",
          "description": "Output buffer to write the joined string to."
        },
        {
          "name": "maxLength",
          "description": "Maximum length of the output buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "Number of bytes written to the output buffer."
    },
    "params": [
      {
        "name": "strings",
        "type": "char[][]",
        "default": null,
        "description": "An array of strings."
      },
      {
        "name": "numStrings",
        "type": "int",
        "default": null,
        "description": "Number of strings in the array."
      },
      {
        "name": "join",
        "type": "char[]",
        "default": null,
        "description": "The join string to insert between each string."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Output buffer to write the joined string to."
      },
      {
        "name": "maxLength",
        "type": "int",
        "default": null,
        "description": "Maximum length of the output buffer."
      }
    ],
    "full_declaration": "stock int ImplodeStrings(const char[][] strings, int numStrings, const char[] join, char[] buffer, int maxLength) { \tint total, length, part_length; \tint join_length = strlen(join);"
  },
  {
    "name": "SetTestContext",
    "type": "stock",
    "source_file": "testing.inc",
    "return_type": "void",
    "comment": "vim: set ts=4 sw=4 tw=99 noet :\n=============================================================================\nSourceMod (C)2004-2014 AlliedModders LLC.  All rights reserved.\n=============================================================================\n\nThis file is part of the SourceMod/SourcePawn SDK.\n\nThis program is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License, version 3.0, as published by the\nFree Software Foundation.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT\nANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\nFOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\ndetails.\n\nYou should have received a copy of the GNU General Public License along with\nthis program.  If not, see <http://www.gnu.org/licenses/>.\n\nAs a special exception, AlliedModders LLC gives you permission to link the\ncode of this program (as well as its derivative works) to \"Half-Life 2,\" the\n\"Source Engine,\" the \"SourcePawn JIT,\" and any Game MODs that run on software\nby the Valve Corporation.  You must obey the GNU General Public License in\nall respects for all other code used.  Additionally, AlliedModders LLC grants\nthis exception to all derivative works.  AlliedModders LLC defines further\nexceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),\nor <http://www.sourcemod.net/license.php>.\n\nVersion: $Id$",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "context",
        "type": "char[]",
        "default": null,
        "description": ""
      }
    ],
    "full_declaration": "stock void SetTestContext(const char[] context) { \tstrcopy(TestContext, sizeof(TestContext), context);"
  },
  {
    "name": "SMC_ParseStart",
    "type": "typedef",
    "source_file": "textparse.inc",
    "return_type": "void",
    "comment": "Called when parsing is started.",
    "tags": {
      "param": [
        {
          "name": "smc",
          "description": "The SMC Parse Handle."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "smc",
        "type": "SMCParser",
        "default": null,
        "description": "The SMC Parse Handle."
      }
    ],
    "full_declaration": "typedef SMC_ParseStart = function void (SMCParser smc);"
  },
  {
    "name": "SMC_NewSection",
    "type": "typedef",
    "source_file": "textparse.inc",
    "return_type": "SMCResult",
    "comment": "Called when the parser is entering a new section or sub-section.\n\nNote: Enclosing quotes are always stripped.",
    "tags": {
      "param": [
        {
          "name": "smc",
          "description": "The SMC Parser."
        },
        {
          "name": "name",
          "description": "String containing section name."
        },
        {
          "name": "opt_quotes",
          "description": "True if the section name was quote-enclosed in the file."
        }
      ],
      "error": [],
      "note": [],
      "return": "An SMCResult action to take."
    },
    "params": [
      {
        "name": "smc",
        "type": "SMCParser",
        "default": null,
        "description": "The SMC Parser."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "String containing section name."
      },
      {
        "name": "opt_quotes",
        "type": "bool",
        "default": null,
        "description": "True if the section name was quote-enclosed in the file."
      }
    ],
    "full_declaration": "typedef SMC_NewSection = function SMCResult (SMCParser smc, const char[] name, bool opt_quotes);"
  },
  {
    "name": "SMC_KeyValue",
    "type": "typedef",
    "source_file": "textparse.inc",
    "return_type": "SMCResult",
    "comment": "Called when the parser finds a new key/value pair.\n\nNote: Enclosing quotes are always stripped.",
    "tags": {
      "param": [
        {
          "name": "smc",
          "description": "The SMCParser."
        },
        {
          "name": "key",
          "description": "String containing key name."
        },
        {
          "name": "value",
          "description": "String containing value name."
        },
        {
          "name": "key_quotes",
          "description": "Whether or not the key was enclosed in quotes."
        },
        {
          "name": "value_quotes",
          "description": "Whether or not the value was enclosed in quotes."
        }
      ],
      "error": [],
      "note": [],
      "return": "An SMCResult action to take."
    },
    "params": [
      {
        "name": "smc",
        "type": "SMCParser",
        "default": null,
        "description": "The SMCParser."
      },
      {
        "name": "key",
        "type": "char[]",
        "default": null,
        "description": "String containing key name."
      },
      {
        "name": "value",
        "type": "char[]",
        "default": null,
        "description": "String containing value name."
      },
      {
        "name": "key_quotes",
        "type": "bool",
        "default": null,
        "description": "Whether or not the key was enclosed in quotes."
      },
      {
        "name": "value_quotes",
        "type": "bool",
        "default": null,
        "description": "Whether or not the value was enclosed in quotes."
      }
    ],
    "full_declaration": "typedef SMC_KeyValue = function SMCResult (SMCParser smc, const char[] key, const char[] value, bool key_quotes, bool value_quotes);"
  },
  {
    "name": "SMC_EndSection",
    "type": "typedef",
    "source_file": "textparse.inc",
    "return_type": "SMCResult",
    "comment": "Called when the parser finds the end of the current section.",
    "tags": {
      "param": [
        {
          "name": "smc",
          "description": "The SMCParser."
        }
      ],
      "error": [],
      "note": [],
      "return": "An SMCResult action to take."
    },
    "params": [
      {
        "name": "smc",
        "type": "SMCParser",
        "default": null,
        "description": "The SMCParser."
      }
    ],
    "full_declaration": "typedef SMC_EndSection = function SMCResult (SMCParser smc);"
  },
  {
    "name": "SMC_ParseEnd",
    "type": "typedef",
    "source_file": "textparse.inc",
    "return_type": "void",
    "comment": "Called when parsing is halted.",
    "tags": {
      "param": [
        {
          "name": "smc",
          "description": "The SMCParser."
        },
        {
          "name": "halted",
          "description": "True if abnormally halted, false otherwise."
        },
        {
          "name": "failed",
          "description": "True if parsing failed, false otherwise."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "smc",
        "type": "SMCParser",
        "default": null,
        "description": "The SMCParser."
      },
      {
        "name": "halted",
        "type": "bool",
        "default": null,
        "description": "True if abnormally halted, false otherwise."
      },
      {
        "name": "failed",
        "type": "bool",
        "default": null,
        "description": "True if parsing failed, false otherwise."
      }
    ],
    "full_declaration": "typedef SMC_ParseEnd = function void (SMCParser smc, bool halted, bool failed);"
  },
  {
    "name": "SMC_RawLine",
    "type": "typedef",
    "source_file": "textparse.inc",
    "return_type": "SMCResult",
    "comment": "Callback for whenever a new line of text is about to be parsed.",
    "tags": {
      "param": [
        {
          "name": "smc",
          "description": "The SMCParser."
        },
        {
          "name": "line",
          "description": "A string containing the raw line from the file."
        },
        {
          "name": "lineno",
          "description": "The line number it occurs on."
        }
      ],
      "error": [],
      "note": [],
      "return": "An SMCResult action to take."
    },
    "params": [
      {
        "name": "smc",
        "type": "SMCParser",
        "default": null,
        "description": "The SMCParser."
      },
      {
        "name": "line",
        "type": "char[]",
        "default": null,
        "description": "A string containing the raw line from the file."
      },
      {
        "name": "lineno",
        "type": "int",
        "default": null,
        "description": "The line number it occurs on."
      }
    ],
    "full_declaration": "typedef SMC_RawLine = function SMCResult (SMCParser smc, const char[] line, int lineno);"
  },
  {
    "name": "SMC_CreateParser",
    "type": "native",
    "source_file": "textparse.inc",
    "return_type": "SMCParser",
    "comment": "Creates a new SMC file format parser.  This is used to set parse hooks.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "A new Handle to an SMC Parse structure."
    },
    "params": [],
    "full_declaration": "native SMCParser SMC_CreateParser();"
  },
  {
    "name": "SMC_ParseFile",
    "type": "native",
    "source_file": "textparse.inc",
    "return_type": "SMCError",
    "comment": "Parses an SMC file.",
    "tags": {
      "param": [
        {
          "name": "smc",
          "description": "A Handle to an SMC Parse structure."
        },
        {
          "name": "file",
          "description": "A string containing the file path."
        },
        {
          "name": "line",
          "description": "An optional by reference cell to store the last line number read."
        },
        {
          "name": "col",
          "description": "An optional by reference cell to store the last column number read."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": "An SMCParseError result."
    },
    "params": [
      {
        "name": "smc",
        "type": "Handle",
        "default": null,
        "description": "A Handle to an SMC Parse structure."
      },
      {
        "name": "file",
        "type": "char[]",
        "default": null,
        "description": "A string containing the file path."
      },
      {
        "name": "line",
        "type": "int",
        "default": "",
        "description": "An optional by reference cell to store the last line number read."
      },
      {
        "name": "col",
        "type": "int",
        "default": "",
        "description": "An optional by reference cell to store the last column number read."
      }
    ],
    "full_declaration": "native SMCError SMC_ParseFile(Handle smc, const char[] file, int &line=0, int &col=0);"
  },
  {
    "name": "SMC_GetErrorString",
    "type": "native",
    "source_file": "textparse.inc",
    "return_type": "bool",
    "comment": "Gets an error string for an SMCError code.",
    "tags": {
      "param": [
        {
          "name": "error",
          "description": "The SMCParseError code."
        },
        {
          "name": "buffer",
          "description": "A string buffer for the error (contents undefined on failure)."
        },
        {
          "name": "buf_max",
          "description": "The maximum size of the buffer."
        }
      ],
      "error": [],
      "note": [
        "SMCError_Okay returns false.",
        "SMCError_Custom (which is thrown on SMCParse_HaltFail) returns false."
      ],
      "return": "True on success, false otherwise."
    },
    "params": [
      {
        "name": "error",
        "type": "SMCError",
        "default": null,
        "description": "The SMCParseError code."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "A string buffer for the error (contents undefined on failure)."
      },
      {
        "name": "buf_max",
        "type": "int",
        "default": null,
        "description": "The maximum size of the buffer."
      }
    ],
    "full_declaration": "native bool SMC_GetErrorString(SMCError error, char[] buffer, int buf_max);"
  },
  {
    "name": "SMC_SetParseStart",
    "type": "native",
    "source_file": "textparse.inc",
    "return_type": "void",
    "comment": "Sets the SMC_ParseStart function of a parse Handle.",
    "tags": {
      "param": [
        {
          "name": "smc",
          "description": "Handle to an SMC Parse."
        },
        {
          "name": "func",
          "description": "SMC_ParseStart function."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "smc",
        "type": "Handle",
        "default": null,
        "description": "Handle to an SMC Parse."
      },
      {
        "name": "func",
        "type": "SMC_ParseStart",
        "default": null,
        "description": "SMC_ParseStart function."
      }
    ],
    "full_declaration": "native void SMC_SetParseStart(Handle smc, SMC_ParseStart func);"
  },
  {
    "name": "SMC_SetParseEnd",
    "type": "native",
    "source_file": "textparse.inc",
    "return_type": "void",
    "comment": "Sets the SMC_ParseEnd of a parse handle.",
    "tags": {
      "param": [
        {
          "name": "smc",
          "description": "Handle to an SMC Parse."
        },
        {
          "name": "func",
          "description": "SMC_ParseEnd function."
        }
      ],
      "error": [
        "Invalid or corrupt Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "smc",
        "type": "Handle",
        "default": null,
        "description": "Handle to an SMC Parse."
      },
      {
        "name": "func",
        "type": "SMC_ParseEnd",
        "default": null,
        "description": "SMC_ParseEnd function."
      }
    ],
    "full_declaration": "native void SMC_SetParseEnd(Handle smc, SMC_ParseEnd func);"
  },
  {
    "name": "SMC_SetReaders",
    "type": "native",
    "source_file": "textparse.inc",
    "return_type": "void",
    "comment": "Sets the three main reader functions.",
    "tags": {
      "param": [
        {
          "name": "smc",
          "description": "An SMC parse Handle."
        },
        {
          "name": "ns",
          "description": "An SMC_NewSection function pointer."
        },
        {
          "name": "kv",
          "description": "An SMC_KeyValue function pointer."
        },
        {
          "name": "es",
          "description": "An SMC_EndSection function pointer."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "smc",
        "type": "Handle",
        "default": null,
        "description": "An SMC parse Handle."
      },
      {
        "name": "ns",
        "type": "SMC_NewSection",
        "default": null,
        "description": "An SMC_NewSection function pointer."
      },
      {
        "name": "kv",
        "type": "SMC_KeyValue",
        "default": null,
        "description": "An SMC_KeyValue function pointer."
      },
      {
        "name": "es",
        "type": "SMC_EndSection",
        "default": null,
        "description": "An SMC_EndSection function pointer."
      }
    ],
    "full_declaration": "native void SMC_SetReaders(Handle smc, SMC_NewSection ns, SMC_KeyValue kv, SMC_EndSection es);"
  },
  {
    "name": "SMC_SetRawLine",
    "type": "native",
    "source_file": "textparse.inc",
    "return_type": "void",
    "comment": "Sets a raw line reader on an SMC parser Handle.",
    "tags": {
      "param": [
        {
          "name": "smc",
          "description": "Handle to an SMC Parse."
        },
        {
          "name": "func",
          "description": "SMC_RawLine function."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "smc",
        "type": "Handle",
        "default": null,
        "description": "Handle to an SMC Parse."
      },
      {
        "name": "func",
        "type": "SMC_RawLine",
        "default": null,
        "description": "SMC_RawLine function."
      }
    ],
    "full_declaration": "native void SMC_SetRawLine(Handle smc, SMC_RawLine func);"
  },
  {
    "name": "CreateTimer",
    "type": "native",
    "source_file": "timers.inc",
    "return_type": "Handle",
    "comment": "Creates a basic timer.  Calling CloseHandle() on a timer will end the timer.",
    "tags": {
      "param": [
        {
          "name": "interval",
          "description": "Interval from the current game time to execute the given function."
        },
        {
          "name": "func",
          "description": "Function to execute once the given interval has elapsed."
        },
        {
          "name": "data",
          "description": "Handle or value to pass through to the timer callback function."
        },
        {
          "name": "flags",
          "description": "Flags to set (such as repeatability or auto-Handle closing)."
        }
      ],
      "error": [],
      "note": [],
      "return": "Handle to the timer object.  You do not need to call CloseHandle(). If the timer could not be created, INVALID_HANDLE will be returned."
    },
    "params": [
      {
        "name": "interval",
        "type": "float",
        "default": null,
        "description": "Interval from the current game time to execute the given function."
      },
      {
        "name": "func",
        "type": "Timer",
        "default": null,
        "description": "Function to execute once the given interval has elapsed."
      },
      {
        "name": "data",
        "type": "any",
        "default": "",
        "description": "Handle or value to pass through to the timer callback function."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Flags to set (such as repeatability or auto-Handle closing)."
      }
    ],
    "full_declaration": "native Handle CreateTimer(float interval, Timer func, any data=0, int flags=0);"
  },
  {
    "name": "KillTimer",
    "type": "native",
    "source_file": "timers.inc",
    "return_type": "void",
    "comment": "Kills a timer.  Use this instead of CloseHandle() if you need more options.",
    "tags": {
      "param": [
        {
          "name": "timer",
          "description": "Timer Handle to kill."
        },
        {
          "name": "autoClose",
          "description": "If autoClose is true, the data that was passed to CreateTimer() will be closed as a handle if TIMER_DATA_HNDL_CLOSE was not specified."
        }
      ],
      "error": [
        "Invalid timer handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "timer",
        "type": "Handle",
        "default": null,
        "description": "Timer Handle to kill."
      },
      {
        "name": "autoClose",
        "type": "bool",
        "default": "",
        "description": "If autoClose is true, the data that was passed to CreateTimer() will be closed as a handle if TIMER_DATA_HNDL_CLOSE was not specified."
      }
    ],
    "full_declaration": "native void KillTimer(Handle timer, bool autoClose=false);"
  },
  {
    "name": "TriggerTimer",
    "type": "native",
    "source_file": "timers.inc",
    "return_type": "void",
    "comment": "Manually triggers a timer so its function will be called.",
    "tags": {
      "param": [
        {
          "name": "timer",
          "description": "Timer Handle to trigger."
        },
        {
          "name": "reset",
          "description": "If reset is true, the elapsed time counter is reset so the full interval must pass again."
        }
      ],
      "error": [
        "Invalid timer handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "timer",
        "type": "Handle",
        "default": null,
        "description": "Timer Handle to trigger."
      },
      {
        "name": "reset",
        "type": "bool",
        "default": "",
        "description": "If reset is true, the elapsed time counter is reset so the full interval must pass again."
      }
    ],
    "full_declaration": "native void TriggerTimer(Handle timer, bool reset=false);"
  },
  {
    "name": "GetTickedTime",
    "type": "native",
    "source_file": "timers.inc",
    "return_type": "float",
    "comment": "Returns the simulated game time.\n\nThis time is internally maintained by SourceMod and is based on the game\ntick count and tick rate.  Unlike GetGameTime(), it will increment past\nmap changes and while no players are connected.  Unlike GetEngineTime(),\nit will not increment based on the system clock (i.e. it is still bound\nto the ticking process).",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "Time based on the game tick count."
    },
    "params": [],
    "full_declaration": "native float GetTickedTime();"
  },
  {
    "name": "GetMapTimeLeft",
    "type": "native",
    "source_file": "timers.inc",
    "return_type": "bool",
    "comment": "Returns an estimate of the time left before the map ends.  If the server\nhas not processed any frames yet (i.e. no players have joined the map yet),\nthen the time left returned will always be infinite.",
    "tags": {
      "param": [
        {
          "name": "timeleft",
          "description": "Variable to store the time, in seconds.  If the value is less than 0, the time limit is infinite."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if the operation is supported, false otherwise."
    },
    "params": [
      {
        "name": "timeleft",
        "type": "int",
        "default": null,
        "description": "Variable to store the time, in seconds.  If the value is less than 0, the time limit is infinite."
      }
    ],
    "full_declaration": "native bool GetMapTimeLeft(int &timeleft);"
  },
  {
    "name": "GetMapTimeLimit",
    "type": "native",
    "source_file": "timers.inc",
    "return_type": "bool",
    "comment": "Retrieves the current map time limit.  If the server has not processed any\nframes yet (i.e. no players have joined the map yet), then the time limit\nreturned will always be 0.",
    "tags": {
      "param": [
        {
          "name": "time",
          "description": "Set to the number of total seconds in the map time limit, or 0 if there is no time limit set."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false if operation is not supported."
    },
    "params": [
      {
        "name": "time",
        "type": "int",
        "default": null,
        "description": "Set to the number of total seconds in the map time limit, or 0 if there is no time limit set."
      }
    ],
    "full_declaration": "native bool GetMapTimeLimit(int &time);"
  },
  {
    "name": "ExtendMapTimeLimit",
    "type": "native",
    "source_file": "timers.inc",
    "return_type": "bool",
    "comment": "Extends the map time limit in a way that will notify all plugins.",
    "tags": {
      "param": [
        {
          "name": "time",
          "description": "Number of seconds to extend map time limit by. The number can be negative to decrease the time limit. If 0, the map will be set to have no time limit."
        }
      ],
      "error": [],
      "note": [],
      "return": "True on success, false if operation is not supported."
    },
    "params": [
      {
        "name": "time",
        "type": "int",
        "default": null,
        "description": "Number of seconds to extend map time limit by. The number can be negative to decrease the time limit. If 0, the map will be set to have no time limit."
      }
    ],
    "full_declaration": "native bool ExtendMapTimeLimit(int time);"
  },
  {
    "name": "GetTickInterval",
    "type": "native",
    "source_file": "timers.inc",
    "return_type": "float",
    "comment": "Returns the number of seconds in between game server ticks.\n\nNote: A tick, in this context, is a frame.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "Number of seconds in between ticks."
    },
    "params": [],
    "full_declaration": "native float GetTickInterval();"
  },
  {
    "name": "OnMapTimeLeftChanged",
    "type": "forward",
    "source_file": "timers.inc",
    "return_type": "void",
    "comment": "Notification that the map's time left has changed via a change in the time\nlimit or a change in the game rules (such as mp_restartgame).  This is useful\nfor plugins trying to create timers based on the time left in the map.\n\nCalling ExtendMapTimeLimit() from here, without proper precaution, will\ncause infinite recursion.\n\nIf the operation is not supported, this will never be called.\n\nIf the server has not yet processed any frames (i.e. no players have joined\nthe map yet), then this will be called once the server begins ticking, even\nif there is no time limit set.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [],
    "full_declaration": "forward void OnMapTimeLeftChanged();"
  },
  {
    "name": "IsServerProcessing",
    "type": "native",
    "source_file": "timers.inc",
    "return_type": "bool",
    "comment": "Returns whether or not the server is processing frames or not.\n\nThe server does not process frames until at least one client joins the game.\nIf server hibernation is disabled, once the first player has joined, even if that player\nleaves, the server's timers and entities will continue to work.",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "True if the server is ticking, false otherwise."
    },
    "params": [],
    "full_declaration": "native bool IsServerProcessing();"
  },
  {
    "name": "CreateDataTimer",
    "type": "stock",
    "source_file": "timers.inc",
    "return_type": "Handle",
    "comment": "Creates a timer associated with a new datapack, and returns the datapack.",
    "tags": {
      "param": [
        {
          "name": "interval",
          "description": "Interval from the current game time to execute the given function."
        },
        {
          "name": "func",
          "description": "Function to execute once the given interval has elapsed."
        },
        {
          "name": "datapack",
          "description": "The newly created datapack is passed though this by-reference parameter to the timer callback function."
        },
        {
          "name": "flags",
          "description": "Timer flags."
        }
      ],
      "error": [],
      "note": [
        "The datapack is automatically freed when the timer ends.",
        "The position of the datapack is not reset or changed for the timer function."
      ],
      "return": "Handle to the timer object.  You do not need to call CloseHandle()."
    },
    "params": [
      {
        "name": "interval",
        "type": "float",
        "default": null,
        "description": "Interval from the current game time to execute the given function."
      },
      {
        "name": "func",
        "type": "Timer",
        "default": null,
        "description": "Function to execute once the given interval has elapsed."
      },
      {
        "name": "datapack",
        "type": "Handle",
        "default": null,
        "description": "The newly created datapack is passed though this by-reference parameter to the timer callback function."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Timer flags."
      }
    ],
    "full_declaration": "stock Handle CreateDataTimer(float interval, Timer func, Handle &datapack, int flags=0) { \tdatapack = new DataPack();"
  },
  {
    "name": "CreateTopMenu",
    "type": "native",
    "source_file": "topmenus.inc",
    "return_type": "TopMenu",
    "comment": "Creates a TopMenu.",
    "tags": {
      "param": [
        {
          "name": "handler",
          "description": "Handler to use for drawing the root title."
        }
      ],
      "error": [],
      "note": [],
      "return": "A new TopMenu Handle, or INVALID_HANDLE on failure."
    },
    "params": [
      {
        "name": "handler",
        "type": "TopMenuHandler",
        "default": null,
        "description": "Handler to use for drawing the root title."
      }
    ],
    "full_declaration": "native TopMenu CreateTopMenu(TopMenuHandler handler);"
  },
  {
    "name": "LoadTopMenuConfig",
    "type": "native",
    "source_file": "topmenus.inc",
    "return_type": "bool",
    "comment": "Re-sorts the items in a TopMenu via a configuration file.\n\nThe format of the configuration file should be a Valve Key-Values\nformatted file that SourceMod can parse.  There should be one root\nsection, and one sub-section for each category.  Each sub-section's\nname should match the category name.\n\nEach sub-section may only contain key/value pairs in the form of:\nkey: \"item\"\nvalue: Name of the item as passed to AddToTopMenu().\n\nThe TopMenu will draw items in the order declared in the configuration\nfile.  If items do not appear in the configuration file, they are sorted\nper-player based on how the handler function renders for that player.\nThese items appear after the configuration sorted items.",
    "tags": {
      "param": [
        {
          "name": "topmenu",
          "description": "TopMenu Handle."
        },
        {
          "name": "file",
          "description": "File path."
        },
        {
          "name": "error",
          "description": "Error buffer."
        },
        {
          "name": "maxlength",
          "description": "Maximum size of the error buffer. Error buffer will be filled with a zero-terminated string if false is returned."
        }
      ],
      "error": [
        "Invalid TopMenu Handle."
      ],
      "note": [],
      "return": "True on success, false on failure."
    },
    "params": [
      {
        "name": "topmenu",
        "type": "Handle",
        "default": null,
        "description": "TopMenu Handle."
      },
      {
        "name": "file",
        "type": "char[]",
        "default": null,
        "description": "File path."
      },
      {
        "name": "error",
        "type": "char[]",
        "default": null,
        "description": "Error buffer."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum size of the error buffer. Error buffer will be filled with a zero-terminated string if false is returned."
      }
    ],
    "full_declaration": "native bool LoadTopMenuConfig(Handle topmenu, const char[] file, char[] error, int maxlength);"
  },
  {
    "name": "AddToTopMenu",
    "type": "native",
    "source_file": "topmenus.inc",
    "return_type": "TopMenuObject",
    "comment": "Adds an topobj to a TopMenu.",
    "tags": {
      "param": [
        {
          "name": "topmenu",
          "description": "TopMenu Handle."
        },
        {
          "name": "name",
          "description": "Object name (MUST be unique)."
        },
        {
          "name": "type",
          "description": "Object type."
        },
        {
          "name": "handler",
          "description": "Handler for topobj."
        },
        {
          "name": "parent",
          "description": "Parent topobj ID, or INVALID_TOPMENUOBJECT for none. Items must have a category parent. Categories must not have a parent."
        },
        {
          "name": "cmdname",
          "description": "Command name (for access overrides)."
        },
        {
          "name": "flags",
          "description": "Default access flags."
        },
        {
          "name": "info_string",
          "description": "Arbitrary storage (max 255 bytes)."
        }
      ],
      "error": [
        "Invalid TopMenu Handle."
      ],
      "note": [],
      "return": "A new TopMenuObject ID, or INVALID_TOPMENUOBJECT on failure."
    },
    "params": [
      {
        "name": "topmenu",
        "type": "Handle",
        "default": null,
        "description": "TopMenu Handle."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Object name (MUST be unique)."
      },
      {
        "name": "type",
        "type": "TopMenuObjectType",
        "default": null,
        "description": "Object type."
      },
      {
        "name": "handler",
        "type": "TopMenuHandler",
        "default": null,
        "description": "Handler for topobj."
      },
      {
        "name": "parent",
        "type": "TopMenuObject",
        "default": null,
        "description": "Parent topobj ID, or INVALID_TOPMENUOBJECT for none. Items must have a category parent. Categories must not have a parent."
      },
      {
        "name": "cmdname",
        "type": "char[]",
        "default": "",
        "description": "Command name (for access overrides)."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Default access flags."
      },
      {
        "name": "info_string",
        "type": "char[]",
        "default": "",
        "description": "Arbitrary storage (max 255 bytes)."
      }
    ],
    "full_declaration": "native TopMenuObject AddToTopMenu(Handle topmenu, \t\t\t\t\t\t\t\t  const char[] name, \t\t\t\t\t\t\t\t  TopMenuObjectType type, \t\t\t\t\t\t\t\t  TopMenuHandler handler, \t\t\t\t\t\t\t\t  TopMenuObject parent, \t\t\t\t\t\t\t\t  const char[] cmdname=\"\", \t\t\t\t\t\t\t\t  int flags=0, \t\t\t\t\t\t\t\t  const char[] info_string=\"\");"
  },
  {
    "name": "GetTopMenuInfoString",
    "type": "native",
    "source_file": "topmenus.inc",
    "return_type": "int",
    "comment": "Retrieves the info string of a top menu item.",
    "tags": {
      "param": [
        {
          "name": "topmenu",
          "description": "TopMenu Handle."
        },
        {
          "name": "parent",
          "description": "TopMenuObject ID."
        },
        {
          "name": "buffer",
          "description": "Buffer to store info string."
        },
        {
          "name": "maxlength",
          "description": "Maximum size of info string."
        }
      ],
      "error": [
        "Invalid TopMenu Handle or TopMenuObject ID."
      ],
      "note": [],
      "return": "Number of bytes written, not including the null terminator."
    },
    "params": [
      {
        "name": "topmenu",
        "type": "Handle",
        "default": null,
        "description": "TopMenu Handle."
      },
      {
        "name": "parent",
        "type": "TopMenuObject",
        "default": null,
        "description": "TopMenuObject ID."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store info string."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum size of info string."
      }
    ],
    "full_declaration": "native int GetTopMenuInfoString(Handle topmenu, TopMenuObject parent, char[] buffer, int maxlength);"
  },
  {
    "name": "GetTopMenuObjName",
    "type": "native",
    "source_file": "topmenus.inc",
    "return_type": "int",
    "comment": "Retrieves the name string of a top menu item.",
    "tags": {
      "param": [
        {
          "name": "topmenu",
          "description": "TopMenu Handle."
        },
        {
          "name": "topobj",
          "description": "TopMenuObject ID."
        },
        {
          "name": "buffer",
          "description": "Buffer to store info string."
        },
        {
          "name": "maxlength",
          "description": "Maximum size of info string."
        }
      ],
      "error": [
        "Invalid TopMenu Handle or TopMenuObject ID."
      ],
      "note": [],
      "return": "Number of bytes written, not including the null terminator."
    },
    "params": [
      {
        "name": "topmenu",
        "type": "Handle",
        "default": null,
        "description": "TopMenu Handle."
      },
      {
        "name": "topobj",
        "type": "TopMenuObject",
        "default": null,
        "description": "TopMenuObject ID."
      },
      {
        "name": "buffer",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store info string."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum size of info string."
      }
    ],
    "full_declaration": "native int GetTopMenuObjName(Handle topmenu, TopMenuObject topobj, char[] buffer, int maxlength);"
  },
  {
    "name": "RemoveFromTopMenu",
    "type": "native",
    "source_file": "topmenus.inc",
    "return_type": "void",
    "comment": "Removes an topobj from a TopMenu.\n\nPlugins' topobjs are automatically removed all TopMenus when the given\nplugin unloads or pauses.  In the case of unpausing, all items are restored.",
    "tags": {
      "param": [
        {
          "name": "topmenu",
          "description": "TopMenu Handle."
        },
        {
          "name": "topobj",
          "description": "TopMenuObject ID."
        }
      ],
      "error": [
        "Invalid TopMenu Handle."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "topmenu",
        "type": "Handle",
        "default": null,
        "description": "TopMenu Handle."
      },
      {
        "name": "topobj",
        "type": "TopMenuObject",
        "default": null,
        "description": "TopMenuObject ID."
      }
    ],
    "full_declaration": "native void RemoveFromTopMenu(Handle topmenu, TopMenuObject topobj);"
  },
  {
    "name": "DisplayTopMenu",
    "type": "native",
    "source_file": "topmenus.inc",
    "return_type": "bool",
    "comment": "Displays a TopMenu to a client.",
    "tags": {
      "param": [
        {
          "name": "topmenu",
          "description": "TopMenu Handle."
        },
        {
          "name": "client",
          "description": "Client index."
        },
        {
          "name": "position",
          "description": "Position to display from."
        }
      ],
      "error": [
        "Invalid TopMenu Handle, invalid client index, or client not in game."
      ],
      "note": [],
      "return": "True on success, false on failure."
    },
    "params": [
      {
        "name": "topmenu",
        "type": "Handle",
        "default": null,
        "description": "TopMenu Handle."
      },
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      },
      {
        "name": "position",
        "type": "TopMenuPosition",
        "default": null,
        "description": "Position to display from."
      }
    ],
    "full_declaration": "native bool DisplayTopMenu(Handle topmenu, int client, TopMenuPosition position);"
  },
  {
    "name": "DisplayTopMenuCategory",
    "type": "native",
    "source_file": "topmenus.inc",
    "return_type": "bool",
    "comment": "Displays a TopMenu category to a client.",
    "tags": {
      "param": [
        {
          "name": "topmenu",
          "description": "TopMenu Handle."
        },
        {
          "name": "category",
          "description": "Category topobj id."
        },
        {
          "name": "client",
          "description": "Client index."
        }
      ],
      "error": [
        "Invalid TopMenu Handle, invalid client index, or client not in game."
      ],
      "note": [],
      "return": "True on success, false on failure."
    },
    "params": [
      {
        "name": "topmenu",
        "type": "Handle",
        "default": null,
        "description": "TopMenu Handle."
      },
      {
        "name": "category",
        "type": "TopMenuObject",
        "default": null,
        "description": "Category topobj id."
      },
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client index."
      }
    ],
    "full_declaration": "native bool DisplayTopMenuCategory(Handle topmenu, TopMenuObject category, int client);"
  },
  {
    "name": "FindTopMenuCategory",
    "type": "native",
    "source_file": "topmenus.inc",
    "return_type": "TopMenuObject",
    "comment": "Finds a category's topobj ID in a TopMenu.",
    "tags": {
      "param": [
        {
          "name": "topmenu",
          "description": "TopMenu Handle."
        },
        {
          "name": "name",
          "description": "Object's unique name."
        }
      ],
      "error": [
        "Invalid TopMenu Handle."
      ],
      "note": [],
      "return": "TopMenuObject ID on success, or INVALID_TOPMENUOBJECT on failure."
    },
    "params": [
      {
        "name": "topmenu",
        "type": "Handle",
        "default": null,
        "description": "TopMenu Handle."
      },
      {
        "name": "name",
        "type": "char[]",
        "default": null,
        "description": "Object's unique name."
      }
    ],
    "full_declaration": "native TopMenuObject FindTopMenuCategory(Handle topmenu, const char[] name);"
  },
  {
    "name": "SetTopMenuTitleCaching",
    "type": "native",
    "source_file": "topmenus.inc",
    "return_type": "void",
    "comment": "Change the menu title caching behavior of the TopMenu. By default the\ntitles are cached to reduce overhead. If you need dynamic menu titles, which\ncan change everytime the menu is displayed to a user, set this to false.",
    "tags": {
      "param": [
        {
          "name": "topmenu",
          "description": "TopMenu Handle."
        },
        {
          "name": "cache_titles",
          "description": "Cache the menu titles and don't call the handler with TopMenuAction_DisplayTitle everytime the menu is drawn?"
        }
      ],
      "error": [
        "Invalid TopMenu Handle"
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "topmenu",
        "type": "Handle",
        "default": null,
        "description": "TopMenu Handle."
      },
      {
        "name": "cache_titles",
        "type": "bool",
        "default": null,
        "description": "Cache the menu titles and don't call the handler with TopMenuAction_DisplayTitle everytime the menu is drawn?"
      }
    ],
    "full_declaration": "native void SetTopMenuTitleCaching(Handle topmenu, bool cache_titles);"
  },
  {
    "name": "__ext_topmenus_SetNTVOptional",
    "type": "public",
    "source_file": "topmenus.inc",
    "return_type": "void",
    "comment": "Do not edit below this line!",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [],
    "full_declaration": "public void __ext_topmenus_SetNTVOptional() { \tMarkNativeAsOptional(\"CreateTopMenu\");"
  },
  {
    "name": "GetUserMessageType",
    "type": "native",
    "source_file": "usermessages.inc",
    "return_type": "UserMessageType",
    "comment": "Returns usermessage serialization type used for the current engine",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": "The supported usermessage type."
    },
    "params": [],
    "full_declaration": "native UserMessageType GetUserMessageType();"
  },
  {
    "name": "GetUserMessageId",
    "type": "native",
    "source_file": "usermessages.inc",
    "return_type": "UserMsg",
    "comment": "Returns the ID of a given message, or -1 on failure.",
    "tags": {
      "param": [
        {
          "name": "msg",
          "description": "String containing message name (case sensitive)."
        }
      ],
      "error": [],
      "note": [],
      "return": "A message index, or INVALID_MESSAGE_ID on failure."
    },
    "params": [
      {
        "name": "msg",
        "type": "char[]",
        "default": null,
        "description": "String containing message name (case sensitive)."
      }
    ],
    "full_declaration": "native UserMsg GetUserMessageId(const char[] msg);"
  },
  {
    "name": "GetUserMessageName",
    "type": "native",
    "source_file": "usermessages.inc",
    "return_type": "bool",
    "comment": "Retrieves the name of a message by ID.",
    "tags": {
      "param": [
        {
          "name": "msg_id",
          "description": "Message index."
        },
        {
          "name": "msg",
          "description": "Buffer to store the name of the message."
        },
        {
          "name": "maxlength",
          "description": "Maximum length of string buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": "True if message index is valid, false otherwise."
    },
    "params": [
      {
        "name": "msg_id",
        "type": "UserMsg",
        "default": null,
        "description": "Message index."
      },
      {
        "name": "msg",
        "type": "char[]",
        "default": null,
        "description": "Buffer to store the name of the message."
      },
      {
        "name": "maxlength",
        "type": "int",
        "default": null,
        "description": "Maximum length of string buffer."
      }
    ],
    "full_declaration": "native bool GetUserMessageName(UserMsg msg_id, char[] msg, int maxlength);"
  },
  {
    "name": "StartMessage",
    "type": "native",
    "source_file": "usermessages.inc",
    "return_type": "Handle",
    "comment": "Starts a usermessage (network message).",
    "tags": {
      "param": [
        {
          "name": "msgname",
          "description": "Message name to start."
        },
        {
          "name": "clients",
          "description": "Array containing player indexes to broadcast to."
        },
        {
          "name": "numClients",
          "description": "Number of players in the array."
        },
        {
          "name": "flags",
          "description": "Optional flags to set."
        }
      ],
      "error": [
        "Invalid message name, unable to start a message, invalid client, or client not connected."
      ],
      "note": [
        "Only one message can be active at a time.",
        "It is illegal to send any message while a non-intercept hook is in progress."
      ],
      "return": "A handle to a bf_write bit packing structure, or INVALID_HANDLE on failure."
    },
    "params": [
      {
        "name": "msgname",
        "type": "char[]",
        "default": null,
        "description": "Message name to start."
      },
      {
        "name": "clients",
        "type": "int[]",
        "default": null,
        "description": "Array containing player indexes to broadcast to."
      },
      {
        "name": "numClients",
        "type": "int",
        "default": null,
        "description": "Number of players in the array."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Optional flags to set."
      }
    ],
    "full_declaration": "native Handle StartMessage(const char[] msgname, const int[] clients, int numClients, int flags=0);"
  },
  {
    "name": "StartMessageEx",
    "type": "native",
    "source_file": "usermessages.inc",
    "return_type": "Handle",
    "comment": "Starts a usermessage (network message).",
    "tags": {
      "param": [
        {
          "name": "msg",
          "description": "Message index to start."
        },
        {
          "name": "clients",
          "description": "Array containing player indexes to broadcast to."
        },
        {
          "name": "numClients",
          "description": "Number of players in the array."
        },
        {
          "name": "flags",
          "description": "Optional flags to set."
        }
      ],
      "error": [
        "Invalid message name, unable to start a message, invalid client, or client not connected."
      ],
      "note": [
        "Only one message can be active at a time.",
        "It is illegal to send any message while a non-intercept hook is in progress."
      ],
      "return": "A handle to a bf_write bit packing structure, or INVALID_HANDLE on failure."
    },
    "params": [
      {
        "name": "msg",
        "type": "UserMsg",
        "default": null,
        "description": "Message index to start."
      },
      {
        "name": "clients",
        "type": "int[]",
        "default": null,
        "description": "Array containing player indexes to broadcast to."
      },
      {
        "name": "numClients",
        "type": "int",
        "default": null,
        "description": "Number of players in the array."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Optional flags to set."
      }
    ],
    "full_declaration": "native Handle StartMessageEx(UserMsg msg, const int[] clients, int numClients, int flags=0);"
  },
  {
    "name": "EndMessage",
    "type": "native",
    "source_file": "usermessages.inc",
    "return_type": "void",
    "comment": "Ends a previously started user message (network message).",
    "tags": {
      "param": [],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [],
    "full_declaration": "native void EndMessage();"
  },
  {
    "name": "MsgPostHook",
    "type": "typedef",
    "source_file": "usermessages.inc",
    "return_type": "void",
    "comment": "Called when a message hook has completed.",
    "tags": {
      "param": [
        {
          "name": "msg_id",
          "description": "Message index."
        },
        {
          "name": "sent",
          "description": "True if message was sent, false if blocked."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "msg_id",
        "type": "UserMsg",
        "default": null,
        "description": "Message index."
      },
      {
        "name": "sent",
        "type": "bool",
        "default": null,
        "description": "True if message was sent, false if blocked."
      }
    ],
    "full_declaration": "typedef MsgPostHook = function void (UserMsg msg_id, bool sent);"
  },
  {
    "name": "HookUserMessage",
    "type": "native",
    "source_file": "usermessages.inc",
    "return_type": "void",
    "comment": "Hooks a user message.",
    "tags": {
      "param": [
        {
          "name": "msg_id",
          "description": "Message index."
        },
        {
          "name": "hook",
          "description": "Function to use as a hook."
        },
        {
          "name": "intercept",
          "description": "If intercept is true, message will be fully intercepted, allowing the user to block the message.  Otherwise, the hook is normal and ignores the return value."
        },
        {
          "name": "post",
          "description": "Notification function."
        }
      ],
      "error": [
        "Invalid message index."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "msg_id",
        "type": "UserMsg",
        "default": null,
        "description": "Message index."
      },
      {
        "name": "hook",
        "type": "MsgHook",
        "default": null,
        "description": "Function to use as a hook."
      },
      {
        "name": "intercept",
        "type": "bool",
        "default": "",
        "description": "If intercept is true, message will be fully intercepted, allowing the user to block the message.  Otherwise, the hook is normal and ignores the return value."
      },
      {
        "name": "post",
        "type": "MsgPostHook",
        "default": "",
        "description": "Notification function."
      }
    ],
    "full_declaration": "native void HookUserMessage(UserMsg msg_id, MsgHook hook, bool intercept=false, MsgPostHook post=INVALID_FUNCTION);"
  },
  {
    "name": "UnhookUserMessage",
    "type": "native",
    "source_file": "usermessages.inc",
    "return_type": "void",
    "comment": "Removes one usermessage hook.",
    "tags": {
      "param": [
        {
          "name": "msg_id",
          "description": "Message index."
        },
        {
          "name": "hook",
          "description": "Function used for the hook."
        },
        {
          "name": "intercept",
          "description": "Specifies whether the hook was an intercept hook or not."
        }
      ],
      "error": [
        "Invalid message index."
      ],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "msg_id",
        "type": "UserMsg",
        "default": null,
        "description": "Message index."
      },
      {
        "name": "hook",
        "type": "MsgHook",
        "default": null,
        "description": "Function used for the hook."
      },
      {
        "name": "intercept",
        "type": "bool",
        "default": "",
        "description": "Specifies whether the hook was an intercept hook or not."
      }
    ],
    "full_declaration": "native void UnhookUserMessage(UserMsg msg_id, MsgHook hook, bool intercept=false);"
  },
  {
    "name": "StartMessageAll",
    "type": "stock",
    "source_file": "usermessages.inc",
    "return_type": "Handle",
    "comment": "Starts a usermessage (network message) that broadcasts to all clients.",
    "tags": {
      "param": [
        {
          "name": "msgname",
          "description": "Message name to start."
        },
        {
          "name": "flags",
          "description": "Optional flags to set."
        }
      ],
      "error": [],
      "note": [
        "See StartMessage or StartMessageEx()."
      ],
      "return": "A handle to a bf_write bit packing structure, or INVALID_HANDLE on failure."
    },
    "params": [
      {
        "name": "msgname",
        "type": "char[]",
        "default": null,
        "description": "Message name to start."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Optional flags to set."
      }
    ],
    "full_declaration": "stock Handle StartMessageAll(const char[] msgname, int flags=0) { \tint total = 0; \tint[] clients = new int[MaxClients]; \tfor (int i = 1; i <= MaxClients; i++) \t{ \t\tif (IsClientConnected(i)) \t\t{ \t\t\tclients[total++] = i; \t\t} \t}  \treturn StartMessage(msgname, clients, total, flags);"
  },
  {
    "name": "StartMessageOne",
    "type": "stock",
    "source_file": "usermessages.inc",
    "return_type": "Handle",
    "comment": "Starts a simpler usermessage (network message) for one client.",
    "tags": {
      "param": [
        {
          "name": "msgname",
          "description": "Message name to start."
        },
        {
          "name": "client",
          "description": "Client to send to."
        },
        {
          "name": "flags",
          "description": "Optional flags to set."
        }
      ],
      "error": [],
      "note": [
        "See StartMessage or StartMessageEx()."
      ],
      "return": "A handle to a bf_write bit packing structure, or INVALID_HANDLE on failure."
    },
    "params": [
      {
        "name": "msgname",
        "type": "char[]",
        "default": null,
        "description": "Message name to start."
      },
      {
        "name": "client",
        "type": "int",
        "default": null,
        "description": "Client to send to."
      },
      {
        "name": "flags",
        "type": "int",
        "default": "",
        "description": "Optional flags to set."
      }
    ],
    "full_declaration": "stock Handle StartMessageOne(const char[] msgname, int client, int flags=0) { \tint players[1]; \tplayers[0] = client;  \treturn StartMessage(msgname, players, 1, flags);"
  },
  {
    "name": "GetVectorLength",
    "type": "native",
    "source_file": "vector.inc",
    "return_type": "float",
    "comment": "Calculates a vector's length.",
    "tags": {
      "param": [
        {
          "name": "vec",
          "description": "Vector."
        },
        {
          "name": "squared",
          "description": "If true, the result will be squared (for optimization)."
        }
      ],
      "error": [],
      "note": [],
      "return": "Vector length (magnitude)."
    },
    "params": [
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Vector."
      },
      {
        "name": "squared",
        "type": "bool",
        "default": "",
        "description": "If true, the result will be squared (for optimization)."
      }
    ],
    "full_declaration": "native float GetVectorLength(const float vec[3], bool squared=false);"
  },
  {
    "name": "GetVectorDistance",
    "type": "native",
    "source_file": "vector.inc",
    "return_type": "float",
    "comment": "Calculates the distance between two vectors.",
    "tags": {
      "param": [
        {
          "name": "vec1",
          "description": "First vector."
        },
        {
          "name": "vec2",
          "description": "Second vector."
        },
        {
          "name": "squared",
          "description": "If true, the result will be squared (for optimization)."
        }
      ],
      "error": [],
      "note": [],
      "return": "Vector distance."
    },
    "params": [
      {
        "name": "vec1",
        "type": "float",
        "default": null,
        "description": "First vector."
      },
      {
        "name": "vec2",
        "type": "float",
        "default": null,
        "description": "Second vector."
      },
      {
        "name": "squared",
        "type": "bool",
        "default": "",
        "description": "If true, the result will be squared (for optimization)."
      }
    ],
    "full_declaration": "native float GetVectorDistance(const float vec1[3], const float vec2[3], bool squared=false);"
  },
  {
    "name": "GetVectorDotProduct",
    "type": "native",
    "source_file": "vector.inc",
    "return_type": "float",
    "comment": "Calculates the dot product of two vectors.",
    "tags": {
      "param": [
        {
          "name": "vec1",
          "description": "First vector."
        },
        {
          "name": "vec2",
          "description": "Second vector."
        }
      ],
      "error": [],
      "note": [],
      "return": "Dot product of the two vectors."
    },
    "params": [
      {
        "name": "vec1",
        "type": "float",
        "default": null,
        "description": "First vector."
      },
      {
        "name": "vec2",
        "type": "float",
        "default": null,
        "description": "Second vector."
      }
    ],
    "full_declaration": "native float GetVectorDotProduct(const float vec1[3], const float vec2[3]);"
  },
  {
    "name": "GetVectorCrossProduct",
    "type": "native",
    "source_file": "vector.inc",
    "return_type": "void",
    "comment": "Computes the cross product of two vectors.  Any input array can be the same\nas the output array.",
    "tags": {
      "param": [
        {
          "name": "vec1",
          "description": "First vector."
        },
        {
          "name": "vec2",
          "description": "Second vector."
        },
        {
          "name": "result",
          "description": "Resultant vector."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "vec1",
        "type": "float",
        "default": null,
        "description": "First vector."
      },
      {
        "name": "vec2",
        "type": "float",
        "default": null,
        "description": "Second vector."
      },
      {
        "name": "result",
        "type": "float",
        "default": null,
        "description": "Resultant vector."
      }
    ],
    "full_declaration": "native void GetVectorCrossProduct(const float vec1[3], const float vec2[3], float result[3]);"
  },
  {
    "name": "NormalizeVector",
    "type": "native",
    "source_file": "vector.inc",
    "return_type": "float",
    "comment": "Normalizes a vector.  The input array can be the same as the output array.",
    "tags": {
      "param": [
        {
          "name": "vec",
          "description": "Vector."
        },
        {
          "name": "result",
          "description": "Resultant vector."
        }
      ],
      "error": [],
      "note": [],
      "return": "Vector length."
    },
    "params": [
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Vector."
      },
      {
        "name": "result",
        "type": "float",
        "default": null,
        "description": "Resultant vector."
      }
    ],
    "full_declaration": "native float NormalizeVector(const float vec[3], float result[3]);"
  },
  {
    "name": "GetAngleVectors",
    "type": "native",
    "source_file": "vector.inc",
    "return_type": "void",
    "comment": "Returns vectors in the direction of an angle.",
    "tags": {
      "param": [
        {
          "name": "angle",
          "description": "Angle."
        },
        {
          "name": "fwd",
          "description": "Forward vector buffer or NULL_VECTOR."
        },
        {
          "name": "right",
          "description": "Right vector buffer or NULL_VECTOR."
        },
        {
          "name": "up",
          "description": "Up vector buffer or NULL_VECTOR."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "angle",
        "type": "float",
        "default": null,
        "description": "Angle."
      },
      {
        "name": "fwd",
        "type": "float",
        "default": null,
        "description": "Forward vector buffer or NULL_VECTOR."
      },
      {
        "name": "right",
        "type": "float",
        "default": null,
        "description": "Right vector buffer or NULL_VECTOR."
      },
      {
        "name": "up",
        "type": "float",
        "default": null,
        "description": "Up vector buffer or NULL_VECTOR."
      }
    ],
    "full_declaration": "native void GetAngleVectors(const float angle[3], float fwd[3], float right[3], float up[3]);"
  },
  {
    "name": "GetVectorAngles",
    "type": "native",
    "source_file": "vector.inc",
    "return_type": "void",
    "comment": "Returns angles from a vector.",
    "tags": {
      "param": [
        {
          "name": "vec",
          "description": "Vector."
        },
        {
          "name": "angle",
          "description": "Angle buffer."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Vector."
      },
      {
        "name": "angle",
        "type": "float",
        "default": null,
        "description": "Angle buffer."
      }
    ],
    "full_declaration": "native void GetVectorAngles(const float vec[3], float angle[3]);"
  },
  {
    "name": "GetVectorVectors",
    "type": "native",
    "source_file": "vector.inc",
    "return_type": "void",
    "comment": "Returns direction vectors from a vector.",
    "tags": {
      "param": [
        {
          "name": "vec",
          "description": "Vector."
        },
        {
          "name": "right",
          "description": "Right vector buffer or NULL_VECTOR."
        },
        {
          "name": "up",
          "description": "Up vector buffer or NULL_VECTOR."
        }
      ],
      "error": [],
      "note": [],
      "return": ""
    },
    "params": [
      {
        "name": "vec",
        "type": "float",
        "default": null,
        "description": "Vector."
      },
      {
        "name": "right",
        "type": "float",
        "default": null,
        "description": "Right vector buffer or NULL_VECTOR."
      },
      {
        "name": "up",
        "type": "float",
        "default": null,
        "description": "Up vector buffer or NULL_VECTOR."
      }
    ],
    "full_declaration": "native void GetVectorVectors(const float vec[3], float right[3], float up[3]);"
  }
]